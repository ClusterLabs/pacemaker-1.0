 /*
 * cluster_info.c
 * 
 * Author: Jia Ming Pan <jmltc@cn.ibm.com>
 * Copyright (c) 2005 International Business Machines
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *
 */

#include <portability.h>
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <regex.h>
#include <hb_api.h>
#include <heartbeat.h>
#include "cluster_info.h"

/*FIXME: remove hardcode path */
#define         CLIHB 			"/etc/init.d/heartbeat"
#ifndef         HA_RC_DIR
#define     	HA_RC_DIR 		"/etc/ha.d/"
#endif
#ifndef 	HA_LIBDIR
#define 	HA_LIBDIR 		"/usr/lib"
#endif

#define 	CONFIG_FILENAME 	HA_RC_DIR"/ha.cf"
#define         BACKUP_CONFIG_NAME 	CONFIG_NAME".bak"
#define 	BACKUP_KEYFILE 		KEYFILE".bak"

#define         CONFIG_COMMENT \
			"#This file was generated by CIM provider\n\n\n"


/* function call env, it's passed to the actual function */
#define FUNC_COMMON					\
	int 	func_id;	/* function name */	\
	const char * cmnd[8];	/* mgmt cmnds */	\
	struct {					\
		int major_len;				\
		const char ** major_field;		\
		int minor_len;				\
		const char ** minor_field;		\
	} fields					\

typedef struct GetFuncEnv_s {
	FUNC_COMMON;
	void *(*handle_func)(MClient*, const struct GetFuncEnv_s*, void*);
} GetFuncEnv;

typedef struct UpdateFuncEnv_s {
	FUNC_COMMON;
	int (*handle_func)(MClient*, void*, const struct UpdateFuncEnv_s*, void*);
} UpdateFuncEnv;

/* a simple string */
static void * returnString(MClient * client, const GetFuncEnv * f, void * out);

/* hashtable */
static void * returnTable(MClient * client, const GetFuncEnv * f, void * out);

/* array, elements are strings */
static void * returnStringArray(MClient * client, const GetFuncEnv * f, void * out);

/* array, elements are tables */
static void * returnTableArray(MClient * client, const GetFuncEnv * f, void * out);

/* table, one of its slots is a table array */
static void * returnArrayTable(MClient*, const GetFuncEnv*, void*);

/* 
 The apply functions,
 The second argument of these function is a table or an array,
 whose layout must be the same as the return one.
*/
static int applyTable(MClient*, void*, const UpdateFuncEnv*, void*);
static int applyTableArray(MClient*, void*, const UpdateFuncEnv*, void*);
static int applyArrayTable(MClient*, void*, const UpdateFuncEnv*, void*);
 
static int InsertOption(CIMTable *, const char *, const char * option);
static int StrIsEmpty(const char * str);

#define STR_CONS_ORDER        "rsc_order"
#define STR_CONS_LOCATION     "rsc_location"
#define STR_CONS_COLOCATION   "rsc_colocation"


/*
description:
	return CRM configuration
format:
	MSG_CRM_CONFIG
return:
	MSG_OK transition_idle_timeout symmetric_cluster(True|False)
 	  stonith_enabled(True|False) no_quorum_policy(freeze|stop|ignore)
 	  default_resource_stickiness have_quorum(True|False)
or
	MSG_FAIL
*/

static const char * crm_config [] = {
				"transition_idle_timeout", 
				"symmetric_cluster",
                	 	"stonith_enabled", 
				"no_quorum_policy",
	                        "default_resource_stickiness",
        	                "have_quorum"};
/*
format:
	MSG_HB_CONFIG
return:
	MSG_OK apiauth auto_failback baud debug debugfile deadping deadtime
	  hbversion hopfudge initdead keepalive logfacility logfile msgfmt
	  nice_failback node normalpoll stonith udpport warntime watchdog
or
	MSG_FAIL
*/
static const char * hb_config [] = {
				"apiauth", "auto_failback", "baud", 
				"debug", "debugfile", "deadping", 
				"deadtime", "hbversion", "hopfudge", 
				"initdead", "keepalive", "logfacility", 
				"logfile", "msgfmt", "nice_failback", 
				"node", "normalpoll", "stonith",
                 		"udpport", "warntime", "watchdog"};

/*
	MSG_NODE_CONFIG NODENAME
return:
	MSG_OK uname online(True|False) standbyTrue|False) unclean(True|False)
 	  shutdown(True|False) expected_up(True|False) is_dc(True|False)
	  node_ping("ping|member")
*/
static const char * node_info[] = {
				"uname", "online", "standby",
                                "unclean", "shutdown", "expected_up",
                                "is_dc", "node_ping"};

/*
description:
        return the operations of a given resource
format:
        MSG_RSC_OPS resource
return:
        MSG_OK id1 name1 interval1 timeout1 id2 name2 interval2 timeout2
                ... idn namen intervaln timeoutn
or
        MSG_FAIL
*/

static const char * operations 	[] = {"id", "name", "interval", "timeout"};
static const char * attributes 	[] = {"id", "name", "value"};

static const char * primitive 	[] = {"id", "class", "provider", "type"};
static const char * clone 	[] = {"id", "clone_max", "clone_node_max"};
static const char * master 	[] = {"id", "clone_max", "clone_node_max",
                			"master_max", "master_node_max"};

static const char * order_constraint	[] = {"id", "from","type","to"};
static const char * co_constraint 	[] = {"id", "from","to","score"};

/*
	rsc_location:
		MSG_OK id resource score 
                        expr_id1 attribute1 operation1 value1
			expr_id2 attribute2 operation2 value2 ...
			expr_idn attributen operationn valuen
*/

static const char * location_constraint [] = { "id", "resource", "score"};
static const char * location_constraint_rule [] =
			{ "id", "attribute", "operation", "value"};

#define _A1(a)		{a,NULL}
#define _A2(a,b)	{a,b,NULL}
#define _A3(a,b,c)	{a,b,c,NULL}
#define _A4(a,b,c,d)	{a,b,c,d,NULL}
#define _A5(a,b,c,d,e)  {a,b,c,d,e,NULL}

#define _MF1(a)		{sizeof(a)/sizeof(char*), a, 0, NULL}
#define _MF2(b)		{0, NULL, sizeof(b)/sizeof(char*), b}
#define _MF(a,b)	{sizeof(a)/sizeof(char*),a, sizeof(b)/sizeof(char*),b}

static const GetFuncEnv get_func_table [] = {
	/* cluster */
	{GET_CRM_CONFIG,_A1(MSG_CRM_CONFIG), _MF1(crm_config), returnTable },
	{GET_HB_CONFIG, _A1(MSG_HB_CONFIG),  _MF1(hb_config),  returnTable },
	{GET_DC, 	_A1(MSG_DC), 	     _MF1(NULL),       returnString},
	{GET_NODE_INFO, _A1(MSG_NODE_CONFIG),_MF1(node_info),  returnTable },
	{GET_NODE_LIST, _A1(MSG_ALLNODES),   _MF1(NULL), returnStringArray},

	/* resource */
	{GET_RSC_OPERATIONS, _A1(MSG_RSC_OPS), 
			_MF2(operations), returnTableArray
	},
	{GET_RSC_ATTRIBUTES, _A1(MSG_RSC_PARAMS), 
			_MF2(attributes), returnTableArray
	},

	{GET_RSC_TYPE, 	_A1(MSG_RSC_TYPE), 	_MF1(NULL), returnString},
	{GET_PRIMITIVE, _A1(MSG_RSC_ATTRS), 	_MF1(primitive), returnTable},
	{GET_CLONE, 	_A1(MSG_GET_CLONE), 	_MF1(clone), returnTable},
	{GET_MASTER, 	_A1(MSG_GET_MASTER), 	_MF1(master), returnTable},
	{GET_SUB_RSC, 	_A1(MSG_SUB_RSC), 	_MF1(NULL), returnStringArray},
	{GET_RSC_LIST, 	_A1(MSG_ALL_RSC), 	_MF1(NULL), returnStringArray},
	{GET_RSC_HOST, 	_A1(MSG_RSC_RUNNING_ON), _MF1(NULL), returnString},
	{GET_RSC_STATUS, _A1(MSG_RSC_STATUS), 	_MF1(NULL), returnString},

	/* metadata */
	{GET_RSC_CLASSES, _A1(MSG_RSC_CLASSES), _MF1(NULL), returnStringArray },
	{GET_RSC_TYPES, _A1(MSG_RSC_TYPE), 	_MF1(NULL), returnStringArray},
	{GET_RSC_PROVIDERS, _A1(MSG_RSC_PROVIDERS), _MF1(NULL), returnStringArray },

	/* constaint */
	{GET_ORDER_CONSTRAINT, _A2(MSG_GET_CONSTRAINT, STR_CONS_ORDER), 
		_MF1(order_constraint), returnTable
	},
	{GET_LOCATION_CONSTRAINT, _A2(MSG_GET_CONSTRAINT, STR_CONS_LOCATION),
		_MF(location_constraint,location_constraint_rule), 
		returnArrayTable 
	},
	{GET_COLOCATION_CONSTRAINT, _A2(MSG_GET_CONSTRAINT,STR_CONS_COLOCATION),
		_MF1(co_constraint), returnTable
	},
	{GET_ORDER_CONS_LIST, _A2(MSG_GET_CONSTRAINTS, STR_CONS_ORDER),
		_MF1(NULL), returnStringArray
	},
	{GET_LOCATION_CONS_LIST, _A2(MSG_GET_CONSTRAINTS, STR_CONS_LOCATION),
		_MF1(NULL), returnStringArray
	},
	{GET_COLOCATION_CONS_LIST, _A2(MSG_GET_CONSTRAINTS,STR_CONS_COLOCATION),
		_MF1(NULL), returnStringArray
	}
};

/*
description:
        add a new resource
format:
        MSG_ADD_RSC rsc_id rsc_class rsc_type rsc_provider group("" for NONE)
                advance(""|"clone"|"master") advance_id clone_max
                clone_node_max master_max master_node_max
                param_id1 param_name1 param_value1
                param_id2 param_name2 param_value2
                ...
                param_idn param_namen param_valuen
*/
static const char * resource [] = {
			"id", "class", "type", "provider", "groupid",
			"advance", "advance_id", "clone_max", "clone_node_max", 
			"master_max", "master_node_max"};
static const char * resource_attributes [] = { 
			"id", "name", "value"};

static const UpdateFuncEnv do_func_table [] = {
	{DEL_OPERATIONS,_A1(MSG_DEL_RSC_OP),  _MF1(NULL), NULL},
	{DEL_ATTRIBUTES,_A1(MSG_DEL_RSC_PARAM), _MF1(NULL), NULL},
	{DEL_RESOURCE, 	_A1(MSG_DEL_RSC), _MF1(NULL), NULL},
	{CREATE_RSC_GROUP, _A1(MSG_ADD_GRP), _MF1(NULL), NULL},
	{CREATE_RESOURCE, _A1(MSG_ADD_RSC), 
		_MF(resource, resource_attributes), applyArrayTable
	},
	{DEL_ORDER_CONSTRAINT, _A2(MSG_DEL_CONSTRAINT, STR_CONS_ORDER),
		_MF1(NULL), NULL},
	{DEL_LOCATION_CONSTRAINT, _A2(MSG_DEL_CONSTRAINT, STR_CONS_LOCATION),
		_MF1(NULL), NULL},
	{DEL_COLOCATION_CONSTRAINT,_A2(MSG_DEL_CONSTRAINT, STR_CONS_COLOCATION),
		_MF1(NULL), NULL},

	{UPDATE_CLONE, 	_A1(MSG_UPDATE_CLONE), _MF1(clone), applyTable},
	{UPDATE_MASTER, _A1(MSG_UPDATE_MASTER),_MF1(master), applyTable},
	{UPDATE_OPERATIONS, _A1(MSG_UP_RSC_OPS), 
		_MF2(operations), applyTableArray 
	},
	{UPDATE_ATTRIBUTES, _A1(MSG_UP_RSC_PARAMS), 
		_MF2(attributes),applyTableArray
	}, 
	{UPDATE_ORDER_CONSTRAINT, _A2(MSG_UP_CONSTRAINT, STR_CONS_ORDER),
		_MF1(order_constraint), applyTable
	},
	{UPDATE_LOCATION_CONSTRAINT, _A2(MSG_UP_CONSTRAINT, STR_CONS_LOCATION),
		_MF(location_constraint, location_constraint_rule), 
		applyArrayTable
	},
	{UPDATE_COLOCATION_CONSTRAINT, 
		_A2(MSG_UP_CONSTRAINT, STR_CONS_COLOCATION),
		_MF1(co_constraint), applyTable
	},
};


static const GetFuncEnv * 
find_get_func(int func_id)
{
	int i, len;
	const GetFuncEnv * func_table;

	len = sizeof(get_func_table)/sizeof(GetFuncEnv);
	func_table = get_func_table;

	for (i=0; i<len; i++){
		if (func_table[i].func_id == func_id){
			return &func_table[i];
		}
	}
	return NULL;
}

static const UpdateFuncEnv * 
find_do_func(int func_id)
{
	int i, len;
	const UpdateFuncEnv * func_table;

	len = sizeof(do_func_table)/sizeof(UpdateFuncEnv);
	func_table = do_func_table;
	for (i=0; i<len; i++){
		if (func_table[i].func_id == func_id){
			return &func_table[i];
		}
	}
	return NULL;
}
		
void *
cim_get(int func_id, const char * param, void * out)
{
	const GetFuncEnv * f;
	MClient * client;
	void * v = NULL;
	const char * arg;
	int i = 0;

	DEBUG_ENTER();
	
	if ((f = find_get_func(func_id)) == NULL ) {
		cl_log(LOG_ERR, "cim_get: can't find function %d", func_id);
		return NULL;
	}
	if ( (client = mclient_new()) == NULL ) {
		cl_log(LOG_ERR, "%s: can't create client", __FUNCTION__);	
               	return NULL;	
        }
	while ((arg = f->cmnd[i++])){
		cl_log(LOG_INFO, "cim_get: add arg %s", arg);
		mclient_cmnd_append(client, arg);
	}
	if(param){
		mclient_cmnd_append(client, param);
		cl_log(LOG_INFO, "cim_get: add param %s", param);
	}

	if( mclient_process(client) == HA_OK 
		&& f->handle_func ) {
		v = f->handle_func(client, f, out);
	}

	mclient_free(client);
	DEBUG_LEAVE();

	return v;
}

/* for array, put the array into in1, then the array length.*/
int
cim_update(int func_id, const char * param, void * in, void * out)
{
	const UpdateFuncEnv * f;
	MClient * client;
	const char * arg;
	int ret = HA_OK;
	int i = 0;

	DEBUG_ENTER();
	if ((f = find_do_func(func_id)) == NULL ) {
		cl_log(LOG_ERR, "cim_update: can't find function %d", func_id);
		return HA_FAIL; 
	}
	if ( (client = mclient_new()) == NULL ) {
		cl_log(LOG_ERR, "%s: can't create client", __FUNCTION__);	
               	return HA_FAIL;	
        }

	while ((arg = f->cmnd[i++])){
		cl_log(LOG_INFO, "cim_update: add arg %s", arg);
		mclient_cmnd_append(client, arg);
	}
	
	if(param){
		mclient_cmnd_append(client, param);
		cl_log(LOG_INFO, "cim_update: add param %s", param);
	}

	ret = HA_OK;
	if ( f->handle_func ){
		ret = f->handle_func(client, (void*)in, f, out); 
	}
	
	if ( ret == HA_OK ) {
		ret = mclient_process(client);
	}
	mclient_free(client);
	DEBUG_LEAVE();

	return ret;
}

static void * 
returnString(MClient * client, const GetFuncEnv * f, void * out)
{
	char * v; 
	DEBUG_ENTER();

	if (client->rlen == 0) {
		DEBUG_LEAVE();
		return cim_strdup("");
	}
	if ( (v = mclient_nth_value(client,0)) == NULL ){
		return NULL;
	}
	DEBUG_LEAVE();
	return cim_strdup(v);
}

static void *      
returnTable(MClient * client, const GetFuncEnv * f, void * out)
{
	CIMTable * t = NULL;
	int i;

	DEBUG_ENTER();
	if ((t = cim_table_new()) == NULL ) {
		return NULL;
	}

	if (client->rlen == 0) {
		goto out;
	}

	for(i=0; i<f->fields.major_len; i++){
		char * v = mclient_nth_value(client, i);
		if(v == NULL ) {
			cim_table_free(t);
			return NULL;
		}
		cim_table_strdup_replace(t, f->fields.major_field[i], v); 
	}
out:
	DEBUG_LEAVE();
	return t;
}


static void *
returnStringArray(MClient * client, const GetFuncEnv * f, void * out)
{
	int i, len;
	CIMArray * array;

	DEBUG_ENTER();	
	if ( ( array = cim_array_new()) == NULL ) {
		return NULL;
	}

	if (client->rlen == 0) {
		goto out;
	}

	len = client->rlen;
	for(i=0; i<len; i++){
		char * v = mclient_nth_value(client, i);
		if(v == NULL ) {
			cim_array_free(array);
			return NULL;
		}
		cim_array_append(array, makeStrData(v));
	}	/* for */

out:
	DEBUG_LEAVE();
	return array;
}

static void *      
returnTableArray(MClient * client, const GetFuncEnv * f, void * out)
{
	int i, len, minor_len;
	CIMArray * array;

	DEBUG_ENTER();	
	if ( ( array = cim_array_new()) == NULL ) {
		return NULL;
	}

	if (client->rlen == 0) {
		goto out;
	}

	minor_len = f->fields.minor_len;
	len = client->rlen/minor_len;

	for(i=0; i< len; i++){
		int j = 0;
		CIMTable * table = cim_table_new();
		if ( table == NULL ) {
			cim_array_free(array);
			return NULL;
		}
		for (j=0; j < minor_len; j++){
			char * v = NULL;
			v= mclient_nth_value(client, i*minor_len + j);
			if(v == NULL ) {
				cim_table_free(table);
				cim_array_free(array);
				return NULL;
			}
			cim_table_strdup_replace(table, 
					f->fields.minor_field[j], v);
		}	/* for j*/
		cim_array_append(array, makeTableData(table));
	} /*for i*/
out:
	DEBUG_LEAVE();
	return array;
}

static void *
returnArrayTable(MClient * client, const GetFuncEnv * f, void * out)
{
	CIMTable * t;
	CIMArray * a;
	int i, j, len, minor_len, major_len;
	const char ** major, ** minor;
	char * key;

	DEBUG_ENTER();
	if (( t=cim_table_new()) == NULL ) {
		DEBUG_LEAVE();
		return NULL;
	}

	if (client->rlen == 0) {
		DEBUG_LEAVE();
		return t;
	}

	if (( a=cim_array_new()) == NULL ) {
		cim_table_free(t);
		DEBUG_LEAVE();
		return NULL;
	}

	major_len = f->fields.major_len;
	minor_len = f->fields.minor_len;
	major = f->fields.major_field;
	minor = f->fields.minor_field;

	for (i=0; i<major_len; i++) {
		char * v = mclient_nth_value(client, i);
		cim_table_strdup_replace(t, major[i], v); 
	}

	len = (client->rlen - major_len)/minor_len;
	for(i=0; i<len; i++) {
		CIMTable * st = cim_table_new();
		if(st == NULL ) {
			cim_table_free(t);
			cim_array_free(a);
			DEBUG_LEAVE();
			return NULL;
		}

		for(j=0; j<minor_len; j++) {
			char * v = NULL;
			v = mclient_nth_value(client, 
					i*minor_len+j+major_len);
			if (v) {
				cim_table_strdup_replace(st, minor[j], v);
			}
			
		}
		cim_array_append(a, makeTableData(st));	
	}
	key = cim_strdup("array");
	if ( key ) {
		cim_table_replace(t, key, makeArrayData(a));		
	}

	DEBUG_LEAVE();
	return t;
}

/* update according to a table */
static int
applyTable(MClient * client, void * data, const UpdateFuncEnv * f, void * out)
{
	CIMTable * table = NULL;
	int i;

	DEBUG_ENTER();
	table = (CIMTable *)data;
	for(i=0; i<f->fields.major_len; i++) {
		char * d = NULL;
		d = cim_table_lookup_v(
			table, f->fields.major_field[i]).v.str;
		mclient_cmnd_append(client, d?d:"");	
	}
	DEBUG_LEAVE();
	return HA_OK;
}

static int
applyTableArray(MClient * client, void * data, 
		const UpdateFuncEnv * f, void * out)
{
	CIMArray * array;	
	int i;
	DEBUG_ENTER();

	if ((array = (CIMArray *) data) == NULL ) {
		DEBUG_LEAVE();
		return HA_FAIL;
	}

	for(i=0; i<cim_array_len(array); i++){
		int j;
		CIMTable * table = cim_array_index_v(array, i).v.table;
		for(j=0; j<f->fields.minor_len; j++) {
			char * str ;
			str = cim_table_lookup_v(table, 
					f->fields.minor_field[j]).v.str;
			mclient_cmnd_append(client, str?str:"");
		}
	}
	DEBUG_LEAVE();
	return HA_OK;
}
 
static int
applyArrayTable(MClient * client, void * data, 
			const UpdateFuncEnv * f, void * out)
{
	CIMTable * table = NULL;
	CIMArray * array = NULL;
	char * v = NULL;
	int i = 0, j =0, major_len, minor_len;
	const char ** major, **minor;

	DEBUG_ENTER();

	major_len = f->fields.major_len;
	minor_len = f->fields.minor_len;
	major = f->fields.major_field;
	minor = f->fields.minor_field;

	table = (CIMTable *)data;
	for (i=0; i<major_len; i++) {
		const char * id = major[i];
		cl_log(LOG_INFO, "1.going to look up %s", id);
		if((v = cim_table_lookup_v(table, id).v.str)) {
			mclient_cmnd_append(client, v);
		}else {
			mclient_cmnd_append(client, "");
		}
	}

	array = cim_table_lookup_v(table, "array").v.array;
	if ( array == NULL ) {
		cl_log(LOG_ERR, "%s: array is NULL.", __FUNCTION__);
		DEBUG_LEAVE();
		return HA_FAIL;
	}

	for(i=0; i<cim_array_len(array); i++) {
		table = cim_array_index_v(array, i).v.table;
		if (table == NULL ) {
			DEBUG_LEAVE();
			return HA_FAIL;
		}

		for(j=0; j<minor_len; j++){
			const char * id = minor[j];
			cl_log(LOG_INFO, "2.going to look up %s", id);
			if((v = cim_table_lookup_v(table, id).v.str)) {
				mclient_cmnd_append(client, v);
			}else {
				mclient_cmnd_append(client, "");
			}
		}
	}

	DEBUG_LEAVE();
	return HA_OK;
}

int
cim_get_hb_status ()
{
	char ** std_out = NULL;
	int     ret;
	int     status = HB_UNKNOWN;

	run_shell_cmnd(CLIHB" status", &ret, &std_out, NULL);
	if ( std_out == NULL || std_out[0] == NULL ) {
		return HB_UNKNOWN;
	} 

	if ( strstr ( std_out[0], "running") != NULL ) {
		status = HB_RUNNING;
	} else {
		status = HB_STOPED;
	}

	free_2d_zarray(std_out, cim_free);	
	return status;
}

int
cim_change_hb_state (int state)
{
	int status;
	const char * cmnd = NULL;
	switch(state) {
	case START_HB:
		cmnd = CLIHB" start"; break;
	case STOP_HB:
		cmnd = CLIHB" stop"; break;
	case RESTART_HB:
		cmnd = CLIHB" restart"; break;
	default:
		cl_log(LOG_ERR, "cim_change_hb_state: unknown opeation");
	}

	/* run it */
	system(cmnd);

	/* verify the status */
	status = cim_get_hb_status();
	if ( (state == START_HB || state == RESTART_HB) 
				&& (status == HB_RUNNING) ) {
		return HA_OK;
	} else if( state == STOP_HB && status == HB_STOPED ) {
		return HA_OK;
	}	
	return HA_FAIL;
}


static int
InsertOption(CIMTable * table, const char * directive, const char * option)
{
	cimdata_t * data;

	if (( data=cim_table_lookup(table, directive))!= NULL) {
		char buf[MAXLEN];
		char *p;

		p = data->v.str;
		/* copy original value */
		strncpy(buf, p, MAXLEN);
		/* append new value */
		strcat(buf, "\n");
		strcat(buf, option);
		cim_table_strdup_replace(table, directive, buf);
	} else { /* the first time */
		cim_table_strdup_replace(table, directive, option);
	}
	return HA_OK;
}

CIMTable *
cim_get_hacf_config ()
{
	FILE *       f = NULL;
	char	     buf[MAXLEN];
	char *	     cp;
	char 	     directive[MAXLEN];
	size_t	     dirlength;
	char  	     option[MAXLEN];
	size_t	     optionlength;
	CIMTable * info = NULL;
	const char * cfgfile = CONFIG_FILENAME;
	
	DEBUG_ENTER();
	info = cim_table_new();
	if ( info == NULL ) {
		return NULL;
	}

	if ((f = fopen(cfgfile, "r")) == NULL ) {
		cl_log(LOG_ERR, "Failed to open %s", cfgfile);
		cim_table_free(info);
		return NULL;
	}

	while (fgets(buf, MAXLEN, f) != NULL) {
		char *   bp = buf; 
		char     option_full[MAXLEN] = "";

		/* Skip over white space */
		bp += strspn(bp, WHITESPACE);
		/* Zap comments on the line */
		if ((cp = strchr(bp, COMMENTCHAR)) != NULL)  {
			*cp = EOS;
		}
		/* Strip '\n' and '\r' chars */
		if ((cp = strpbrk(bp, CRLF)) != NULL) {
			*cp = EOS;
		}

		/* Ignore blank (and comment) lines */
		if (*bp == EOS) {
			continue;
		}

		/* Now we expect a directive name */
		dirlength = strcspn(bp, WHITESPACE);
		strncpy(directive, bp, dirlength);
		directive[dirlength] = EOS;

		while (*bp != EOS) {
			optionlength = strcspn(bp, DELIMS);
			strncpy(option, bp, optionlength);
			option[optionlength] = EOS;
			bp += optionlength;
			
			if ( strcmp(option, directive) != 0 ) {	
				if ( strcmp(directive, "node") != 0) {
					strcat(option_full, option);	
					strcat(option_full, " ");
				}else{
					/* directive is "node" */
					InsertOption(info, directive, option);
				}
			}
			/* Skip over Delimiters */
			bp += strspn(bp, DELIMS);
		}

		if ( strcmp(directive, "node") != 0 ) {
			option_full[strlen(option_full) - 1] = EOS;
			InsertOption(info, directive, option_full);
		}
	}
	fclose(f);	
	DEBUG_LEAVE();
	return info;
}

/* set CONFIG_NAME */

static int
StrIsEmpty(const char * str)
{
	char ch;
	while ( (ch = *(str++) )){
		if ( ch ==' ' || ch == '\t'){
			continue;
		} else {
			return 0;
		}
	}
	return 1;
}

static void
write_file_foreach(void * key, void * value, void * user)
{
	FILE * 		f = (FILE *) user;
	cimdata_t *	v = (cimdata_t *) value;
	char **         values;
	int             i, len;

	values = split_string(v->v.str, &len, "\n");
	if ( values == NULL ) {
		return ;
	}
	
	for (i =0; i<len; i++) {
		if ( !StrIsEmpty(values[i]) ){
			fprintf(f, "%s\t\t%s\n", (char *)key, values[i]);
		}
	}
	if (values[0]) {
		cim_free(values[0]);
	}
	cim_free(values);
}

int
cim_set_cluster_config(CIMTable * info) 
{
        FILE * f = NULL;

        /* backup old file */
        if ( rename(CONFIG_NAME, BACKUP_CONFIG_NAME) != 0 ) {
		cl_log(LOG_WARNING, "Backup ha.cf failed.");
        }

        if ( ( f = fopen(CONFIG_NAME, "w") ) == NULL ) {
		cl_log(LOG_ERR, "Could not open ha.cf");
                return HA_FAIL;
        }
	cl_log(LOG_INFO, "Begin dump config infomation.");
	dump_cim_table(info, NULL);
	fprintf(f, CONFIG_COMMENT);
	cim_table_foreach(info, write_file_foreach, f);

        fclose(f);
        return HA_OK;
}

CIMTable *
cim_get_cluster_auth(void) 
{
        FILE *       	f = NULL;
        struct stat  	keyfilestat;
        int          	authnum = -1;
        char         	buf[MAXLEN];
        char         	key[MAXLEN];
        char         	method[MAXLEN];
        int          	i;
        int          	src;
	CIMTable * 	authinfo; 

	authinfo = cim_table_new();
	if ( authinfo == NULL ) {
		cl_log(LOG_ERR, "Alloc table failed.");		
                return NULL;
        }

        if ((f = fopen(KEYFILE, "r")) == NULL) {
                cl_log(LOG_ERR, "Cannot open keyfile [%s].  Stop."
                ,       KEYFILE);
                cim_table_free(authinfo);
		return NULL;
        } 

        if (fstat(fileno(f), &keyfilestat) < 0
            ||  keyfilestat.st_mode & (S_IROTH | S_IRGRP)) {
                cl_log(LOG_ERR, "Bad permissions on keyfile"
                       " [%s], 600 recommended.", KEYFILE);
                fclose(f);
                cim_table_free(authinfo);
                return NULL;
        }

        while(fgets(buf, MAXLEN, f) != NULL) {
                char *  bp = buf;

                bp += strspn(bp, WHITESPACE);
                if (*bp == COMMENTCHAR || *bp == EOS) {
                        continue;
                }
                if (*bp == 'a') {
                        if ((src=sscanf(bp, "auth %d", &authnum)) != 1) {
                                cl_log(LOG_ERR
                                ,       "Invalid auth line [%s] in " KEYFILE
                                ,        buf);
                        }
                        /* Parsing of this line now complete */
                        continue;
                }
                key[0] = EOS;
                if ((src=sscanf(bp, "%d%s%s", &i, method, key)) >= 2) {
                        if ((i < 0) || (i >= MAXAUTH)) {
                                ha_log(LOG_ERR, "Invalid authnum [%d] in "
                                       KEYFILE, i);
                                continue;
                        }
                        
                        /* found */
                        if ( i == authnum ) { break; }
                } else if (*bp != EOS) {
                        ha_log(LOG_ERR, "Auth line [%s] is invalid."
                        ,       buf);
                }
        }
        
        /* add auth method, key to dict */
        cim_table_strdup_replace(authinfo, "authmethod", method);
        cim_table_strdup_replace(authinfo, "authkey", key);

        fclose(f);
        return authinfo;
}

int 
cim_set_cluster_auth(CIMTable * table)
{
        FILE * f;
        cimdata_t * method, * key;        

        /* backup old file */ 
        if ( rename(KEYFILE, BACKUP_KEYFILE) != 0 ) {
		cl_log(LOG_WARNING, "Backup authkeys failed.");
        }

        if ( ( f = fopen(KEYFILE, "w") ) == NULL ) {
		cl_log(LOG_ERR, "Can not open authkeys.");
                return HA_FAIL;
        }

        /* set mode to 0600 */
        if ( chmod(KEYFILE, 0600) != 0 ) {
		cl_log(LOG_ERR, "Cat not chmod authkeys to 0600.");
                fclose(f);
                return HA_FAIL;
        }

	/* get new value */
        method = cim_table_lookup(table, "authmethod");
        key    = cim_table_lookup(table, "authkey");

	if (method == NULL || key == NULL ) {
		cl_log(LOG_ERR, "FATAL: method or key is NULL.");
		return HA_FAIL;
	}

	dump_cim_table(table, 0);
        /* write file */
	fprintf(f, CONFIG_COMMENT);
        fprintf(f, "auth %u\n", 1);
        fprintf(f, "%u %s %s\n", 1, method->v.str, key->v.str);

        fclose(f);
        return HA_OK;
}

CIMTable *
cim_get_software_identity(void)
{
	char ** out = NULL;
	int     ret;
	DEBUG_ENTER();
	run_shell_cmnd(HALIB"/heartbeat/heartbeat -V", &ret, &out, NULL);
	if ( out ) {
		CIMTable * 	table;
		char *		hbversion;

		table = cim_table_new();
		if ( table == NULL ) {
			free_2d_zarray(out, cim_free);
			return NULL;
		}
		hbversion = out[0];
		if ( hbversion ){
			hbversion[strlen(hbversion)-1]=EOS;
			cim_table_strdup_replace(table,"hbversion",hbversion); 
			DEBUG_LEAVE();
			return table;
		} else {
			cim_table_free(table);
		}
	}

	DEBUG_LEAVE();
	return NULL;
}


int
cim_get_resource_type(const char * rscid)
{
	char * type;
	int tid = TID_UNKNOWN;

	type = cim_get(GET_RSC_TYPE, rscid, NULL);

	if ( type == NULL ) {
		return TID_UNKNOWN;
	}

	if(strcmp(type, "native")== 0){
		tid = TID_RES_PRIMITIVE;
	} else if (strcmp(type, "group") == 0) {
		tid = TID_RES_GROUP;
	} else if (strcmp(type, "clone") == 0){
		tid = TID_RES_CLONE;
	} else if (strcmp(type, "master") == 0){
		tid = TID_RES_MASTER;
	}
	
	cim_free(type);
	return tid;
}
