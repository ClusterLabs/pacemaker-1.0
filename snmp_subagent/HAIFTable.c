/* $Id: HAIFTable.c,v 1.2 2004/02/17 22:12:01 lars Exp $ */
/* This file was generated by mib2c and is intended for use as a mib module
   for the ucd-snmp snmpd agent. */


#ifdef IN_UCD_SNMP_SOURCE
/* If we're compiling this file inside the ucd-snmp source tree */


/* This should always be included first before anything else */
#include <config.h>


/* minimal include directives */
#include "mibincl.h"
#include "util_funcs.h"


#else /* !IN_UCD_SNMP_SOURCE */

#include "config.h" /* linux-ha/config.h */

#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>

#ifdef HAVE_NET_SNMP
	#ifdef HAVE_NET_SNMP_UTIL_FUNCS_H
		#include <ucd-snmp/util_funcs.h>
	#else /* !HAVE_NET_SNMP_UTIL_FUNCS_H */
		#include "ucd_util_funcs.h"
	#endif /* HAVE_NET_SNMP_UTIL_FUNCS_H */ 

#else /* !HAVE_NET_SNMP */
	#include <ucd-snmp/util_funcs.h>
#endif /* HAVE_NET_SNMP */ 

#endif /* !IN_UCD_SNMP_SOURCE */


#include "HAIFTable.h"
#include <clplumbing/cl_log.h>
#include "haclient.h"


/* 
 * HAIFTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */


oid HAIFTable_variables_oid[] = { 1,3,6,1,4,1,4682,3 };


/* 
 * variable2 HAIFTable_variables:
 *   this variable defines function callbacks and type return information 
 *   for the HAIFTable mib section 
 */


struct variable2 HAIFTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define   HAIFNAME              4
  { HAIFNAME            , ASN_OCTET_STR , RONLY , var_HAIFTable, 2, { 1,2 } },
#define   HAIFSTATUS            5
  { HAIFSTATUS          , ASN_OCTET_STR , RONLY , var_HAIFTable, 2, { 1,3 } },

};
/*    (L = length of the oidsuffix) */


/*
 * init_HAIFTable():
 *   Initialization routine.  This is called when the agent starts up.
 *   At a minimum, registration of your variables should take place here.
 */
void init_HAIFTable(void) {
	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("HAIFTable", HAIFTable_variables, variable2,
               HAIFTable_variables_oid);
}

/*
 * header_ifInfo():
 *   This is a replacement for the default header_simple_table()
 *   and header_generic() routine. 
 *
 *   This table checks the incoming request to find out the 
 *   matching interface id in our cluster.
 */
int header_ifInfo(struct variable * vp,
			    oid             * name,
			    size_t          * length,
			    int               exact,
			    size_t          * var_len,
			    WriteMethod     * *write_method,
			    size_t          * index )
{
	oid newname[MAX_OID_LEN];
	size_t count = 0;
	int ret, i, found = 0;
	int32_t nid, iid;

	/* Set up some default values. 
	   Can be changed in var_xxx() later if necessary. */
	*write_method = 0;
	*var_len = sizeof(long);
	*index = 0;

	memcpy((char *)newname,(char *)vp->name, vp->namelen * sizeof(oid));

	/* preliminary boundary checking */
	ret = snmp_oid_compare(name, *length-2, newname, vp->namelen);
	if(ret > 0 || (exact && ret != 0))
		return MATCH_FAILED;

	if (HA_OK != get_count(IFINFO, &count)) {
		cl_log(LOG_ERR, "header_ifInfo get_count() error. \n");
		return MATCH_FAILED;
	}

	for (i = 0; i < count; i++) {
		get_int32_value(IFINFO, IF_NODE_ID, i, &nid);
		get_int32_value(IFINFO, IF_ID, i, &iid);

		newname[vp->namelen] = nid + 1; // index is off-by-one
		newname[vp->namelen + 1] = iid + 1; // ditto

		ret = snmp_oid_compare(name, *length, newname, vp->namelen + 2);

		if( (exact && (ret == 0)) || (!exact && (ret < 0)) ) {
			*index = i;
			found = 1;
			break;
		} 
	}

	if (found) {
		if(!exact) {
			memcpy( (char *)name,(char *)newname, 
				(vp->namelen + 2) * sizeof(oid));
			*length = vp->namelen + 2;
		}
		return MATCH_SUCCEEDED;
	} else {
		return MATCH_FAILED;
	}
}


/*
 * var_HAIFTable():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_HAIFTable(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{
	/* variables we may use later */
	static unsigned char string[SPRINT_MAX_LEN];
	size_t index;
	const char * str;
	int ret;
	
	if (header_ifInfo(vp,name,length,exact,var_len,write_method, &index)
	                                == MATCH_FAILED )
		return NULL;
	
	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch(vp->magic) {

		case HAIFNAME:
		
			*string = 0;
			ret = get_str_value(IFINFO, IF_NAME, index, &str);
			if (ret != HA_OK)
				return NULL;
			strncpy(string, str, SPRINT_MAX_LEN);
			*var_len = strlen(string);
			return (unsigned char *) string;
		
		case HAIFSTATUS:
		
			*string = 0;
			ret = get_str_value(IFINFO, IF_STATUS, index, &str);
			if (ret != HA_OK)
				return NULL;
			strncpy(string, str, SPRINT_MAX_LEN);
			*var_len = strlen(string);
			return (unsigned char *) string;
		
		default:
		  ERROR_MSG("");
	}
	return NULL;
}



