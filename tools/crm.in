#!/usr/bin/env python
#

# Copyright (C) 2008 Dejan Muhamedagic <dmuhamedagic@suse.de>
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
# 
# This software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
# 
# You should have received a copy of the GNU General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#

import shlex
import os
from tempfile import mkstemp
import subprocess
import sys
import time
import readline
import copy
import xml.dom.minidom
import signal
import re

class ErrorBuffer(object):
    '''
    Show error messages either immediately or buffered.
    '''
    def __init__(self):
        self.msg_list = []
        self.mode = "immediate"
    def buffer(self):
        self.mode = "keep"
    def release(self):
        if self.msg_list:
            print '\n'.join(self.msg_list)
            if interactive:
                raw_input("Press enter to continue... ")
            self.msg_list = []
        self.mode = "immediate"
    def writemsg(self,msg):
        if self.mode == "immediate":
            print msg
        else:
            self.msg_list.append(msg)
    def error(self,s):
        self.writemsg("ERROR: %s" % add_lineno(s))
    def warning(self,s):
        self.writemsg("WARNING: %s" % add_lineno(s))
    def info(self,s):
        self.writemsg("INFO: %s" % add_lineno(s))
def add_lineno(s):
    if lineno > 0:
        return "%d: %s" % (lineno,s)
    else: return s

def common_err(s):
    err_buf.error(s)
def common_warn(s):
    err_buf.warning(s)
def common_info(s):
    err_buf.info(s)
def no_prog_err(name):
    err_buf.error("%s not available, check your installation"%name)
def missing_prog_warn(name):
    err_buf.warning("could not find any %s on the system"%name)
def no_attribute_err(attr,obj_type):
    err_buf.error("required attribute %s not found in %s"%(attr,obj_type))
def bad_def_err(what,msg):
    err_buf.error("bad %s definition: %s"%(what,msg))
def unsupported_err(name):
    err_buf.error("%s is not supported"%name)
def no_such_obj_err(name):
    err_buf.error("%s object is not supported"%name)
def obj_cli_err(name):
    err_buf.error("object %s cannot be represented in the CLI notation"%name)
def missing_obj_err(node):
    err_buf.error("object %s:%s missing (shouldn't have happened)"% \
        (node.tagName,node.getAttribute("id")))
def constraint_norefobj_err(constraint_id,obj_id):
    err_buf.error("constraint %s references a resource %s which doesn't exist"% \
        (constraint_id,obj_id))
def obj_exists_err(name):
    err_buf.error("object %s already exists"%name)
def no_object_err(name):
    err_buf.error("object %s does not exist"%name)
def invalid_id_err(obj_id):
    err_buf.error("%s: invalid object id"%obj_id)
def id_used_err(node_id):
    err_buf.error("%s: id is already in use"%node_id)
def skill_err(s):
    err_buf.error("%s: this command is not allowed at this skill level"%' '.join(s))
def syntax_err(s,token = '',context = ''):
    pfx = "syntax"
    if context:
        pfx = "%s in %s" %(pfx,context)
    if type(s) == type(''):
        err_buf.error("%s near <%s>"%(pfx,s))
    elif token:
        err_buf.error("%s near <%s>: %s"%(pfx,token,' '.join(s)))
    else:
        err_buf.error("%s: %s"%(pfx,' '.join(s)))
def bad_attr_usage(cmd,args):
    err_buf.error("bad usage: %s %s"%(cmd,args))
def cib_parse_err(msg):
    err_buf.error("%s"%msg)
def cib_no_elem_err(el_name):
    err_buf.error("CIB contains no '%s' element!"%el_name)
def cib_ver_unsupported_err(validator,rel):
    err_buf.error("CIB not supported: validator '%s', release '%s'"% (validator,rel))
    err_buf.error("You may try the upgrade command")
def update_err(obj_id,cibadm_opt,node):
    if cibadm_opt == '-C':
        task = "create"
    elif cibadm_opt == '-D':
        task = "delete"
    else:
        task = "update"
    err_buf.error("could not %s %s"%(task,obj_id))
    err_buf.info("offending xml: %s" % node.toprettyxml())
def not_impl_info(s):
    err_buf.info("%s is not implemented yet" % s)

def ask(msg):
    print_msg = True
    while True:
        ans = raw_input(msg + ' ')
        if not ans or ans[0].lower() not in ('n','y'):
            if print_msg:
                print "Please answer with y[es] or n[o]"
                print_msg = False
        else:
            return ans[0].lower() == 'y'

from UserDict import DictMixin
class odict(DictMixin):
    def __init__(self, data=None, **kwdata):
        self._keys = []
        self._data = {}
    def __setitem__(self, key, value):
        if key not in self._data:
            self._keys.append(key)
        self._data[key] = value
    def __getitem__(self, key):
        return self._data[key]
    def __delitem__(self, key):
        del self._data[key]
        self._keys.remove(key)
    def keys(self):
        return list(self._keys)
    def copy(self):
        copyDict = odict()
        copyDict._data = self._data.copy()
        copyDict._keys = self._keys[:]
        return copyDict

global_aliases = {
    "quit": ("bye","exit"),
    "end": ("cd","up"),
}
def setup_aliases(obj):
    for cmd in obj.cmd_aliases.keys():
        for alias in obj.cmd_aliases[cmd]:
            obj.help_table[alias] = obj.help_table[cmd]
            obj.cmd_table[alias] = obj.cmd_table[cmd]

#
# Resource Agents interface (meta-data, parameters, etc)
#
def lrmadmin(opts, xml = False):
    '''
    Get information directly from lrmd using lrmadmin.
    '''
    lrmadmin_prog = "@sbindir@/lrmadmin"
    l = []
    #print "invoke: lrmadmin",opts
    if is_program(lrmadmin_prog) and is_process("lrmd"):
        cmd = add_sudo(lrmadmin_prog)
        l = stdin2list("%s %s" % (cmd,opts))
        if not xml:
            l = l[1:] # skip the first line
    return l
def pengine_meta():
    '''
    Do pengine metadata.
    '''
    pengine = "@CRM_DAEMON_DIR@/pengine"
    l = []
    if is_program(pengine):
        l = stdin2list("%s metadata" % pengine)
    return l
def get_nodes_text(n,tag):
    try:
        node = n.getElementsByTagName(tag)[0]
        for c in node.childNodes:
            if c.nodeType == c.TEXT_NODE:
                return c.data.strip()
    except: return ''
def ra_classes():
    '''
    List of RA classes.
    '''
    if wcache.is_cached("ra_classes"):
        return wcache.retrieve("ra_classes")
    l = lrmadmin("-C")
    return wcache.store("ra_classes",l)
def ra_providers(ra_type,ra_class = "ocf"):
    'List of providers for a class:type.'
    id = "ra_providers-%s-%s" % (ra_class,ra_type)
    if wcache.is_cached(id):
        return wcache.retrieve(id)
    l = lrmadmin("-P %s %s" % (ra_class,ra_type),True)
    return wcache.store(id,l)
def ra_providers_all(ra_class = "ocf"):
    '''
    List of providers for a class:type.
    '''
    id = "ra_providers_all-%s" % ra_class
    if wcache.is_cached(id):
        return wcache.retrieve(id)
    ocf_root = os.getenv("@OCF_ROOT_DIR@")
    if not ocf_root:
        ocf_root = "/usr/lib/ocf"
    dir = ocf_root + "/resource.d"
    l = []
    for s in os.listdir(dir):
        if os.path.isdir("%s/%s" % (dir,s)):
            l.append(s)
    return wcache.store(id,l)
def ra_types(ra_class = "ocf", ra_provider = ""):
    '''
    List of RA type for a class.
    '''
    if not ra_class:
        ra_class = "ocf"
    id = "ra_types-%s-%s" % (ra_class,ra_provider)
    if wcache.is_cached(id):
        return wcache.retrieve(id)
    if ra_provider:
        list = []
        for ra in lrmadmin("-T %s" % ra_class):
            if ra_provider in ra_providers(ra,ra_class):
                list.append(ra)
    else:
        list = lrmadmin("-T %s" % ra_class)
    list.sort()
    return wcache.store(id,list)

class RAInfo(object):
    '''
    A resource agent and whatever's useful about it.
    '''
    ra_tab = "    "  # four horses
    skip_ops = ("meta-data", "validate-all")
    act_attr = ("timeout", "interval", "depth")
    def __init__(self,ra_class,ra_type,ra_provider = "heartbeat"):
        self.ra_class = ra_class
        self.ra_type = ra_type
        self.ra_provider = ra_provider
        if not self.ra_provider:
            self.ra_provider = "heartbeat"
        self.mk_ra_node() # indirectly caches meta-data and doc
    def mk_ra_node(self):
        '''
        Return the resource_agent node.
        '''
        meta = self.meta()
        try:
            self.doc = xml.dom.minidom.parseString('\n'.join(meta))
        except:
            #common_err("could not parse meta-data for (%s,%s,%s)" \
            #    % (self.ra_class,self.ra_type,self.ra_provider))
            self.ra_node = None
            return
        try:
            self.ra_node = self.doc.getElementsByTagName("resource-agent")[0]
        except:
            common_err("meta-data contains no resource-agent element")
            self.ra_node = None
    def params(self):
        '''
        Construct a dict: parameters are keys and lists of flags
        (required and unique) are values. Cached too.
        '''
        id = "ra_params-%s-%s-%s"%(self.ra_class,self.ra_type,self.ra_provider)
        if wcache.is_cached(id):
            return wcache.retrieve(id)
        if not self.ra_node:
            return None
        d = {}
        for pset in self.ra_node.getElementsByTagName("parameters"):
            for c in pset.getElementsByTagName("parameter"):
                name = c.getAttribute("name")
                if not name:
                    continue
                required = c.getAttribute("required")
                unique = c.getAttribute("unique")
                d[name] = (required == '1',unique == '1')
        return wcache.store(id,d)
    def params_list(self):
        '''
        List of parameters.
        '''
        try:
            l = self.params().keys()
            l.sort()
            return l
        except:
            return []
    def reqd_params_list(self):
        '''
        List of required parameters.
        '''
        d = self.params()
        if not d: return []
        return [x for x in d if d[x][0]]
    def is_param_reqd(self,pname):
        '''
        Is pname a required parameter?
        '''
        return pname in self.reqd_params_list()
    def meta(self):
        '''
        RA meta-data as raw xml.
        '''
        id = "ra_meta-%s-%s-%s" % (self.ra_class,self.ra_type,self.ra_provider)
        if wcache.is_cached(id):
            return wcache.retrieve(id)
        if self.ra_class == "pengine":
            l = pengine_meta()
        else:
            l = lrmadmin("-M %s %s %s" % (self.ra_class,self.ra_type,self.ra_provider),True)
        return wcache.store(id, l)
    def meta_pretty(self):
        '''
        Print the RA meta-data in a human readable form.
        '''
        if not self.ra_node:
            return ''
        l = []
        title = self.meta_title()
        l.append(title)
        longdesc = get_nodes_text(self.ra_node,"longdesc")
        if longdesc:
            l.append(longdesc)
        if self.ra_class != "heartbeat":
            params = self.meta_parameters()
            if params:
                l.append(params.rstrip())
        actions = self.meta_actions()
        if actions:
            l.append(actions)
        return '\n\n'.join(l)
    def meta_title(self):
        if self.ra_class == "ocf":
            s = "%s:%s:%s" % (self.ra_class,self.ra_provider,self.ra_type)
        else:
            s = "%s:%s" % (self.ra_class,self.ra_type)
        shortdesc = get_nodes_text(self.ra_node,"shortdesc")
        if shortdesc and shortdesc != self.ra_type:
            s = "%s (%s)" % (shortdesc,s)
        return s
    def meta_param_head(self,n):
        type = default = None
        name = n.getAttribute("name")
        if not name:
            return None
        s = name
        if n.getAttribute("required") == "1":
            s = s + "*"
        try:
            content = n.getElementsByTagName("content")[0]
            type = content.getAttribute("type")
            default = content.getAttribute("default")
        except: pass
        if type and default:
            s = "%s (%s, [%s])" % (s,type,default)
        elif type:
            s = "%s (%s)" % (s,type)
        shortdesc = get_nodes_text(n,"shortdesc")
        if shortdesc and shortdesc != name:
            s = "%s: %s" % (s,shortdesc)
        return s
    def format_parameter(self,n):
        l = []
        head = self.meta_param_head(n)
        if not head:
            common_err("no name attribute for parameter")
            return ""
        l.append(head)
        longdesc = get_nodes_text(n,"longdesc")
        if longdesc:
            longdesc = self.ra_tab + longdesc.replace("\n","\n"+self.ra_tab) + '\n'
            l.append(longdesc)
        return '\n'.join(l)
    def meta_parameter(self,param):
        if not self.ra_node:
            return ''
        l = []
        for pset in self.ra_node.getElementsByTagName("parameters"):
            for c in pset.getElementsByTagName("parameter"):
                if c.getAttribute("name") == param:
                    return self.format_parameter(c)
    def meta_parameters(self):
        if not self.ra_node:
            return ''
        l = []
        for pset in self.ra_node.getElementsByTagName("parameters"):
            for c in pset.getElementsByTagName("parameter"):
                s = self.format_parameter(c)
                if s:
                    l.append(s)
        if l:
            return "Parameters (* denotes required, [] the default):\n\n" + '\n'.join(l)
    def meta_action_head(self,n):
        name = n.getAttribute("name")
        if not name:
            return ''
        if name in self.skip_ops:
            return ''
        s = "%-8s" % name
        for a in self.act_attr:
            v = n.getAttribute(a)
            if v:
                s = "%s %s=%s" % (s,a,v)
        return s
    def meta_actions(self):
        l = []
        for aset in self.ra_node.getElementsByTagName("actions"):
            for c in aset.getElementsByTagName("action"):
                s = self.meta_action_head(c)
                if s:
                    l.append(self.ra_tab + s)
        if l:
            return "Operations' defaults (advisory minimum):\n\n" + '\n'.join(l)

def cmd_end(cmd,dir = ".."):
    "Go up one level."
    levels.droplevel()
def cmd_exit(cmd):
    "Exit the crm program"
    cmd_end(cmd)
    if interactive:
        print "bye"
    try:
        readline.write_history_file(hist_file)
    except:
        pass
    for f in tmpfiles:
        os.unlink(f)
    sys.exit()

#
# help or make users feel less lonely
#
def add_shorthelp(topic,shorthelp,topic_help):
    '''
    Join topics ("%s,%s") if they share the same short
    description.
    '''
    for i in range(len(topic_help)):
        if topic_help[i][1] == shorthelp:
            topic_help[i][0] = "%s,%s" % (topic_help[i][0], topic)
            return
    topic_help.append([topic, shorthelp])
def dump_short_help(help_tab):
    topic_help = []
    for topic in help_tab:
        if topic == '.':
            continue
        # with odict, for whatever reason, python parses differently:
        # help_tab["..."] = ("...","...") and
        # help_tab["..."] = ("...","""
        # ...""")
        # a parser bug?
        if type(help_tab[topic][0]) == type(()):
            shorthelp = help_tab[topic][0][0]
        else:
            shorthelp = help_tab[topic][0]
        add_shorthelp(topic,shorthelp,topic_help)
    for t,d in topic_help:
        print "\t%-16s %s" % (t,d)
def overview(help_tab):
    print ""
    print help_tab['.'][1]
    print ""
    print "Available commands:"
    print ""
    dump_short_help(help_tab)
    print ""
def topic_help(help_tab,topic):
    if topic not in help_tab:
        print "There is no help for topic %s" % topic
        return
    if type(help_tab[topic][0]) == type(()):
        shorthelp = help_tab[topic][0][0]
        longhelp = help_tab[topic][0][1]
    else:
        shorthelp = help_tab[topic][0]
        longhelp = help_tab[topic][1]
    print longhelp or shorthelp
def cmd_help(help_tab,topic = ''):
    "help!"
    # help_tab is an odict (ordered dictionary):
    # help_tab[topic] = (short_help,long_help)
    # topic '.' is a special entry for the top level
    if not topic:
        overview(help_tab)
    else:
        topic_help(help_tab,topic)

def add_sudo(cmd):
    if user_prefs.crm_user:
        return "sudo -E -u %s %s"%(user_prefs.crm_user,cmd)
    return cmd
def pipe_string(cmd,s):
    rc = -1 # command failed
    cmd = add_sudo(cmd)
    p = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE)
    try:
        p.communicate(s)
        p.wait()
        rc = p.returncode
    except IOError, msg:
        common_err(msg)
    return rc
def xml2doc(cmd):
    cmd = add_sudo(cmd)
    p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
    try:
        doc = xml.dom.minidom.parse(p.stdout)
    except xml.parsers.expat.ExpatError,msg:
        common_err("cannot parse output of %s: %s"%(cmd,msg))
        p.wait()
        return None
    p.wait()
    return doc

def str2tmp(s):
    '''
    Write the given string to a temporary file. Return the name
    of the file.
    '''
    fd,tmp = mkstemp()
    try: f = os.fdopen(fd,"w")
    except IOError, msg:
        common_err(msg)
        return
    f.write(s)
    f.close()
    return tmp

def ext_cmd(cmd):
    if os.system(add_sudo(cmd)) != 0:
        return False
    else:
        return True

def get_stdin(cmd, stderr_on = True):
    '''
    Run a cmd, return stdin output.
    stderr_on controls whether to show output which comes on stderr.
    '''
    proc = subprocess.Popen(cmd, shell=True, \
        stdout=subprocess.PIPE, \
        stderr=stderr_on and None or subprocess.PIPE)
    outp = proc.communicate()[0]
    proc.wait()
    outp = outp.strip()
    return outp
def stdin2list(cmd, stderr_on = True):
    '''
    Run a cmd, fetch output, return it as a list of lines.
    stderr_on controls whether to show output which comes on stderr.
    '''
    s = get_stdin(cmd, stderr_on)
    return s.split('\n')

def is_program(prog):
    return os.system("which %s >/dev/null 2>&1"%prog) == 0
def find_program(envvar,*args):
    if envvar and os.getenv(envvar):
        return os.getenv(envvar)
    for prog in args:
        if is_program(prog):
            return prog

def is_id_valid(id):
    """
    Verify that the id follows the definition:
    http://www.w3.org/TR/1999/REC-xml-names-19990114/#ns-qualnames
    """
    if not id:
        return False
    id_re = "^[A-Za-z_][\w._-]*$"
    return re.match(id_re,id)
def check_filename(fname):
    """
    Verify that the string is a filename.
    """
    fname_re = "^[^/]+$"
    return re.match(fname_re,id)

class UserPrefs(object):
    '''
    Keep user preferences here.
    '''
    def __init__(self):
        self.skill_level = 2 #TODO: set back to 0?
        self.editor = find_program("EDITOR","vim","vi","emacs","nano")
        self.pager = find_program("PAGER","less","more","pg")
        self.dotty = find_program("","dotty")
        if not self.editor:
            missing_prog_warn("editor")
        if not self.pager:
            missing_prog_warn("pager")
        self.crm_user = ""
        self.xmlindent = "  "  # two spaces
    def check_skill_level(self,n):
        return self.skill_level >= n

class CliOptions(object):
    '''
    Manage user preferences
    '''
    skill_levels = {"operator":0, "administrator":1, "expert":2}
    help_table = odict()
    help_table["."] = ("user preferences","Various user preferences may be set here.")
    help_table["skill-level"] = ("set skill level", "")
    help_table["editor"] = ("set prefered editor program", "")
    help_table["pager"] = ("set prefered pager program", "")
    help_table["user"] = ("set the cluster user", """
If you need extra privileges to talk to the cluster (i.e. the cib
process), then set this to user. Typically, that is either "root"
or "hacluster". Don't forget to setup the sudoers file as well.

Example: user hacluster
""")
    help_table["quit"] = ("exit the program", "")
    help_table["help"] = ("show help", "")
    help_table["end"] = ("go back one level", "")
    cmd_aliases = global_aliases
    def __init__(self):
        self.cmd_table = {
            "skill-level": (self.set_skill_level,(1,1),0,(skills_list,)),
            "editor": (self.set_editor,(1,1),0),
            "pager": (self.set_pager,(1,1),0),
            "user": (self.set_crm_user,(0,1),0),
            "save": (self.save_options,(0,0),0),
            "show": (self.show_options,(0,0),0),
            "help": (self.help,(0,1),0),
            "quit": (cmd_exit,(0,0),0),
            "end": (cmd_end,(0,1),0),
        }
        setup_aliases(self)
    def set_skill_level(self,cmd,skill_level):
        """usage: skill-level <level>
        level: operator | administrator | expert"""
        if skill_level in self.skill_levels:
            user_prefs.skill_level = self.skill_levels[skill_level]
        else:
            common_err("no %s skill level"%skill_level)
            return False
    def get_skill_level(self):
        for s in self.skill_levels:
            if user_prefs.skill_level == self.skill_levels[s]:
                return s
    def set_editor(self,cmd,prog):
        "usage: editor <program>"
        if is_program(prog):
            user_prefs.editor = prog
        else:
            common_err("program %s does not exist"% prog)
            return False
    def set_pager(self,cmd,prog):
        "usage: pager <program>"
        if is_program(prog):
            user_prefs.pager = prog
        else:
            common_err("program %s does not exist"% prog)
            return False
    def set_crm_user(self,cmd,user = ''):
        "usage: user [<crm_user>]"
        user_prefs.crm_user = user
    def write_rc(self,f):
        print >>f, '%s "%s"' % ("editor",user_prefs.editor)
        print >>f, '%s "%s"' % ("pager",user_prefs.pager)
        print >>f, '%s "%s"' % ("user",user_prefs.crm_user)
        print >>f, '%s "%s"' % ("skill-level",self.get_skill_level())
    def show_options(self,cmd):
        "usage: show"
        self.write_rc(sys.stdout)
    def save_options(self,cmd):
        "usage: save"
        try: f = open(rc_file,"w")
        except os.error,msg:
            common_err("open: %s"%msg)
            return
        print >>f, 'options'
        self.write_rc(f)
        print >>f, 'end'
        f.close()
    def help(self,cmd,topic = ''):
        "usage: help [<topic>]"
        cmd_help(self.help_table,topic)

cib_dump = "cibadmin -Ql"
cib_piped = "cibadmin -p"
cib_upgrade = "cibadmin --upgrade --force"
cib_verify = "crm_verify -V -p"

class WCache(object):
    "Cache stuff. A naive implementation."
    def __init__(self):
        self.lists = {}
        self.stamp = time.time()
        self.max_cache_age = 600 # seconds
    def is_cached(self,name):
        if time.time() - self.stamp > self.max_cache_age:
            self.stamp = time.time()
            self.clear()
        return name in self.lists
    def store(self,name,lst):
        self.lists[name] = lst
        return lst
    def retrieve(self,name):
        if self.is_cached(name):
            return self.lists[name]
        else:
            return None
    def clear(self):
        self.lists = {}

def is_name_sane(name):
    if re.match("['/;]",name):
        common_err("%s: bad file name"%name)
        return False
    return True
def listshadows():
    return stdin2list("ls @CRM_CONFIG_DIR@ | fgrep shadow. | sed 's/^shadow\.//'")

class CibShadow(object):
    '''
    CIB shadow management class
    '''
    help_table = odict()
    help_table["."] = ("","""
CIB shadow management.
See the crm_shadow program.
""")
    help_table["new"] = ("create a new shadow CIB", "")
    help_table["delete"] = ("delete a shadow CIB", "")
    help_table["reset"] = ("copy live cib to a shadow CIB", "")
    help_table["commit"] = ("copy a shadow CIB to the cluster", "")
    help_table["use"] = ("change working CIB", '''
Choose a shadow CIB for further changes. If the name
provided is empty, then the live (cluster) CIB is used.
''')
    help_table["diff"] = ("diff between the shadow CIB and the live CIB", "")
    help_table["list"] = ("list all shadow CIBs", "")
    help_table["quit"] = ("exit the program", "")
    help_table["help"] = ("show help", "")
    help_table["end"] = ("go back one level", "")
    envvar = "CIB_shadow"
    extcmd = ">/dev/null </dev/null crm_shadow"
    cmd_aliases = global_aliases
    def __init__(self):
        self.cmd_table = {
            "new": (self.new,(1,2),1),
            "delete": (self.delete,(1,1),1,(shadows_list,)),
            "reset": (self.reset,(1,1),1,(shadows_list,)),
            "commit": (self.commit,(1,1),1,(shadows_list,)),
            "use": (self.use,(0,1),1,(shadows_live_list,)),
            "diff": (self.diff,(0,0),1),
            "list": (self.list,(0,0),1),
            "help": (self.help,(0,1),0),
            "quit": (cmd_exit,(0,0),0),
            "end": (cmd_end,(0,1),0),
        }
        self.chkcmd()
        setup_aliases(self)
    def chkcmd(self):
        try:
            os.system("%s 2>&1" % self.extcmd)
        except os.error:
            no_prog_err(self.extcmd)
            return False
        return True
    def new(self,cmd,name,force = ''):
        "usage: new <shadow_cib> [force]"
        if not is_name_sane(name):
            return False
        new_cmd = "%s -c '%s'" % (self.extcmd,name)
        if force:
            if force == "force" or force == "--force":
                new_cmd = "%s --force" % new_cmd
            else:
                syntax_err((new_cmd,force), context = 'new')
                return False
        if ext_cmd(new_cmd):
            common_info("%s shadow CIB created"%name)
            self.use("use",name)
    def delete(self,cmd,name):
        "usage: delete <shadow_cib>"
        if not is_name_sane(name):
            return False
        if cib_in_use == name:
            common_err("%s shadow CIB is in use"%name)
            return False
        if ext_cmd("%s -D '%s' --force" % (self.extcmd,name)):
            common_info("%s shadow CIB deleted"%name)
        else:
            common_err("failed to delete %s shadow CIB"%name)
            return False
    def reset(self,cmd,name):
        "usage: reset <shadow_cib>"
        if not is_name_sane(name):
            return False
        if ext_cmd("%s -r '%s'" % (self.extcmd,name)):
            common_info("copied live CIB to %s"%name)
        else:
            common_err("failed to copy live CIB to %s"%name)
            return False
    def commit(self,cmd,name):
        "usage: commit <shadow_cib>"
        if not is_name_sane(name):
            return False
        if ext_cmd("%s -C '%s' --force" % (self.extcmd,name)):
            common_info("commited '%s' shadow CIB to the cluster"%name)
            wcache.clear()
        else:
            common_err("failed to commit the %s shadow CIB"%name)
            return False
    def diff(self,cmd):
        "usage: diff"
        return ext_cmd("%s -d" % self.extcmd)
    def list(self,cmd):
        "usage: list"
        multicolumn(listshadows())
    def use(self,cmd,name = ''):
        "usage: use [<shadow_cib>]"
        # Choose a shadow cib for further changes. If the name
        # provided is empty, then choose the live (cluster) cib.
        # Don't allow ' in shadow names
        if not is_name_sane(name):
            return False
        global cib_in_use
        if not name or name == "live":
            name = ""
            os.unsetenv(self.envvar)
        else:
            if not ext_cmd("test -r '@CRM_CONFIG_DIR@/shadow.%s'"%name):
                common_err("%s: no such shadow CIB"%name)
                return False
            os.putenv(self.envvar,name)
        cib_in_use = name
    def help(self,cmd,topic = ''):
        cmd_help(self.help_table,topic)

def manage_attr(cmd,attr_ext_commands,*args):
    if len(args) < 3:
        bad_attr_usage(cmd,' '.join(args))
        return False
    attr_cmd = None
    try:
        attr_cmd = attr_ext_commands[args[1]]
    except KeyError:
        bad_attr_usage(cmd,' '.join(args))
        return False
    if not attr_cmd:
        bad_attr_usage(cmd,' '.join(args))
        return False
    if args[1] == 'set':
        if len(args) == 4:
            return ext_cmd(attr_cmd%(args[0],args[2],args[3]))
        else:
            bad_attr_usage(cmd,' '.join(args))
            return False
    elif args[1] in ('delete','show'):
        if len(args) == 3:
            return ext_cmd(attr_cmd%(args[0],args[2]))
        else:
            bad_attr_usage(cmd,' '.join(args))
            return False
    else:
        bad_attr_usage(cmd,' '.join(args))
        return False

def resources_xml():
    if wcache.is_cached("rsc_xml"):
        return wcache.retrieve("rsc_xml")
    doc = xml2doc("%s -o resources" % cib_dump)
    if not doc:
        return []
    wcache.store("rsc_xml",doc)
def rsc2node(id):
    if wcache.is_cached("rsc_%s_node" % id):
        return wcache.retrieve("rsc_%s_node" % id)
    doc = resources_xml()
    if not doc:
        return []
    nodes = get_interesting_nodes(doc,[])
    for n in nodes:
        if is_resource(n) and n.getAttribute("id") == id:
            return wcache.store("rsc_%s_node" % id, n)
def get_meta_param(id,param):
    return get_stdin(RscMgmt.rsc_meta['show'] % (id,param), stderr_on = False)
def is_rsc_running(id):
    rsc_node = rsc2node(id)
    if not rsc_node:
        return False
    if not is_resource(rsc_node):
        return False
    test_id = rsc_clone(id) or id
    outp = get_stdin(RscMgmt.rsc_status % test_id, stderr_on = False)
    return outp.find("running") > 0 and outp.find("NOT") == -1
def is_rsc_clone(rsc_id):
    rsc_node = rsc2node(rsc_id)
    return is_clone(rsc_node)
def is_rsc_ms(rsc_id):
    rsc_node = rsc2node(rsc_id)
    return is_ms(rsc_node)
def rsc_clone(rsc_id):
    '''Get a clone of a resource.'''
    rsc_node = rsc2node(rsc_id)
    if not rsc_node or not rsc_node.parentNode:
        return None
    pnode = rsc_node.parentNode
    if is_group(pnode):
        pnode = pnode.parentNode
    if is_clonems(pnode):
        return pnode.getAttribute("id")
def is_process(s):
    proc = subprocess.Popen("ps -e -o pid,command | grep -qs '%s'" % s, \
        shell=True, stdout=subprocess.PIPE)
    proc.wait()
    return proc.returncode == 0
def cluster_stack():
    if is_process("heartbeat:.[m]aster"):
        return "heartbeat"
    elif is_process("[a]isexec"):
        return "openais"
    return ""
def get_cloned_rsc(rsc_id):
    rsc_node = rsc2node(rsc_id)
    if not rsc_node:
        return ""
    for c in rsc_node.childNodes:
        if is_child_rsc(c):
            return c.getAttribute("id")
    return ""
def get_max_clone(id):
    v = get_meta_param(id,"clone-max")
    try:
        cnt = int(v)
    except:
        cnt = len(listnodes())
    return cnt
def cleanup_resource(rsc,node):
    if is_rsc_clone(rsc) or is_rsc_ms(rsc):
        base = get_cloned_rsc(rsc)
        if not base:
            return False
        clone_max = get_max_clone(rsc)
        rc = True
        for n in range(clone_max):
            if not ext_cmd(RscMgmt.rsc_cleanup % ("%s:%d" % (base,n), node)):
                rc = False
    else:
        rc = ext_cmd(RscMgmt.rsc_cleanup%(rsc,node))
    return rc

class RscMgmt(object):
    '''
    Resources management class
    '''
    rsc_status_all = "crm_resource -L"
    rsc_status = "crm_resource -W -r '%s'"
    rsc_showxml = "crm_resource -q -r '%s'"
    rsc_startstop = "crm_resource --meta -r '%s' -p target-role -v '%s'"
    rsc_manage = "crm_resource --meta -r '%s' -p is-managed -v '%s'"
    rsc_migrate = "crm_resource -M -r '%s'"
    rsc_migrateto = "crm_resource -M -r '%s' -H '%s'"
    rsc_unmigrate = "crm_resource -U -r '%s'"
    rsc_cleanup = "crm_resource -C -r '%s' -H '%s'"
    rsc_param =  {
        'set': "crm_resource -r '%s' -p '%s' -v '%s'",
        'delete': "crm_resource -r '%s' -d '%s'",
        'show': "crm_resource -r '%s' -g '%s'",
    }
    rsc_meta =  {
        'set': "crm_resource --meta -r '%s' -p '%s' -v '%s'",
        'delete': "crm_resource --meta -r '%s' -d '%s'",
        'show': "crm_resource --meta -r '%s' -g '%s'",
    }
    rsc_failcount = {
        'set': "crm_failcount -r '%s' -U '%s' -v '%s'",
        'delete': "crm_failcount -r '%s' -U '%s' -D",
        'show': "crm_failcount -r '%s' -U '%s' -G",
    }
    rsc_refresh = "crm_resource -R"
    rsc_refresh_node = "crm_resource -R -H '%s'"
    rsc_reprobe = "crm_resource -P"
    rsc_reprobe_node = "crm_resource -P -H '%s'"
    help_table = odict()
    help_table["."] = ("","Resource management.")
    help_table["status"] = ("show status of resources", "")
    help_table["start"] = ("start a resource", "")
    help_table["stop"] = ("stop a resource", "")
    help_table["manage"] = ("put a resource into managed mode", "")
    help_table["unmanage"] = ("put a resource into unmanaged mode", "")
    help_table["migrate"] = ("migrate a resource to another node", "")
    help_table["unmigrate"] = ("migrate a resource to its prefered node", "")
    help_table["param"] = ("manage a parameter of a resource","""
Manage or display a parameter of a resource (also known as an
instance_attribute).

Usage:

        param <rsc> set <param> <value>
        param <rsc> delete <param>
        param <rsc> show <param>

Example:

        param ip_0 show ip
""")
    help_table["meta"] = ("manage a meta attribute","""
Show/edit/delete a meta attribute of a resource. Currently, all
meta attributes of a resource may be managed with other commands
such as 'resource stop'.

Usage:

        meta <rsc> set <attr> <value>
        meta <rsc> delete <attr>
        meta <rsc> show <attr>

Example:

        meta ip_0 set target-role stopped
""")
    help_table["failcount"] = ("manage failcounts", """
Show/edit/delete the failcount of a resource.

Usage:

        failcount <rsc> set <node> <value>
        failcount <rsc> delete <node>
        failcount <rsc> show <node>

Example:

        failcount fs_0 delete node2
""")
    help_table["cleanup"] = ("cleanup resource status","")
    help_table["refresh"] = ("refresh CIB from the LRM status","")
    help_table["reprobe"] = ("probe for resources not started by the CRM","")
    help_table["quit"] = ("exit the program", "")
    help_table["help"] = ("show help", "")
    help_table["end"] = ("go back one level", "")
    cmd_aliases = global_aliases.copy()
    cmd_aliases.update({
        "status": ("show","list",),
        "migrate": ("move",),
        "unmigrate": ("unmove",),
    })
    def __init__(self):
        self.cmd_table = {
            "status": (self.status,(0,1),0,(rsc_list,)),
            "start": (self.start,(1,1),0,(rsc_list,)),
            "stop": (self.stop,(1,1),0,(rsc_list,)),
            "manage": (self.manage,(1,1),0,(rsc_list,)),
            "unmanage": (self.unmanage,(1,1),0,(rsc_list,)),
            "migrate": (self.migrate,(1,2),0,(rsc_list,nodes_list)),
            "unmigrate": (self.unmigrate,(1,1),0,(rsc_list,)),
            "param": (self.param,(3,4),1,(rsc_list,attr_cmds)),
            "meta": (self.meta,(3,4),1,(rsc_list,attr_cmds)),
            "failcount": (self.failcount,(3,4),0,(rsc_list,attr_cmds,nodes_list)),
            "cleanup": (self.cleanup,(1,2),1,(rsc_list,nodes_list)),
            "refresh": (self.refresh,(0,1),0,(nodes_list,)),
            "reprobe": (self.reprobe,(0,1),0,(nodes_list,)),
            "help": (self.help,(0,1),0),
            "quit": (cmd_exit,(0,0),0),
            "end": (cmd_end,(0,1),0),
        }
        setup_aliases(self)
    def status(self,cmd,rsc = None):
        "usage: status [<rsc>]"
        if rsc:
            return ext_cmd(self.rsc_status % rsc)
        else:
            return ext_cmd(self.rsc_status_all)
    def start(self,cmd,rsc):
        "usage: start <rsc>"
        return ext_cmd(self.rsc_startstop%(rsc,"Started"))
    def stop(self,cmd,rsc):
        "usage: stop <rsc>"
        return ext_cmd(self.rsc_startstop%(rsc,"Stopped"))
    def manage(self,cmd,rsc):
        "usage: manage <rsc>"
        return ext_cmd(self.rsc_manage%(rsc,"true"))
    def unmanage(self,cmd,rsc):
        "usage: unmanage <rsc>"
        return ext_cmd(self.rsc_manage%(rsc,"false"))
    def migrate(self,cmd,*args):
        """usage: migrate <rsc> [<node>]"""
        if len(args) == 1:
            return ext_cmd(self.rsc_migrate%args[0])
        else:
            return ext_cmd(self.rsc_migrateto%(args[0],args[1]))
    def unmigrate(self,cmd,rsc):
        "usage: unmigrate <rsc>"
        return ext_cmd(self.rsc_unmigrate%rsc)
    def cleanup(self,cmd,*args):
        "usage: cleanup <rsc> [<node>]"
        # Cleanup a resource on a node. Omit node to cleanup on
        # all live nodes.
        if len(args) == 2: # remove
            return cleanup_resource(args[0],args[1])
        else:
            rv = True
            for n in listnodes():
                if not cleanup_resource(args[0],n):
                    rv = False
            return rv
    def failcount(self,cmd,*args):
        """usage:
        failcount <rsc> set <node> <value>
        failcount <rsc> delete <node>
        failcount <rsc> show <node>"""
        d = lambda: manage_attr(cmd,self.rsc_failcount,*args)
        return d()
    def param(self,cmd,*args):
        """usage:
        param <rsc> set <param> <value>
        param <rsc> delete <param>
        param <rsc> show <param>"""
        d = lambda: manage_attr(cmd,self.rsc_param,*args)
        return d()
    def meta(self,cmd,*args):
        """usage:
        meta <rsc> set <attr> <value>
        meta <rsc> delete <attr>
        meta <rsc> show <attr>"""
        d = lambda: manage_attr(cmd,self.rsc_meta,*args)
        return d()
    def refresh(self,cmd,*args):
        'usage: refresh [<node>]'
        if len(args) == 1:
            return ext_cmd(self.rsc_refresh_node%args[0])
        else:
            return ext_cmd(self.rsc_refresh)
    def reprobe(self,cmd,*args):
        'usage: reprobe [<node>]'
        if len(args) == 1:
            return ext_cmd(self.rsc_reprobe_node%args[0])
        else:
            return ext_cmd(self.rsc_reprobe)
    def help(self,cmd,topic = ''):
        cmd_help(self.help_table,topic)

def print_node(uname,id,type,other,inst_attr):
    """
    Try to pretty print a node from the cib. Sth like:
    uname(id): type
        attr1: v1
        attr2: v2
    """
    if uname == id:
        print "%s: %s" % (uname,type)
    else:
        print "%s(%s): %s" % (uname,id,type)
    for a in other:
        print "\t%s: %s" % (a,other[a])
    for a,v in inst_attr:
        print "\t%s: %s" % (a,v)

class NodeMgmt(object):
    '''
    Nodes management class
    '''
    node_standby = "crm_standby -U '%s' -v '%s'"
    node_delete = "cibadmin -D -o nodes -X '<node uname=\"%s\"/>'"
    hb_delnode = "@libdir@/heartbeat/hb_delnode '%s'"
    dc = "crmadmin -D"
    node_attr = {
        'set': "crm_attribute -t nodes -U '%s' -n '%s' -v '%s'",
        'delete': "crm_attribute -D -t nodes -U '%s' -n '%s'",
        'show': "crm_attribute -G -t nodes -U '%s' -n '%s'",
    }
    node_status = {
        'set': "crm_attribute -t status -U '%s' -n '%s' -v '%s'",
        'delete': "crm_attribute -D -t status -U '%s' -n '%s'",
        'show': "crm_attribute -G -t status -U '%s' -n '%s'",
    }
    help_table = odict()
    help_table["."] = ("","Nodes management.")
    help_table["show"] = ("show node", "")
    help_table["standby"] = ("put node into standby", "")
    help_table["online"] = ("bring node online", "")
    help_table["delete"] = ("delete node", "")
    help_table["attribute"] = ("manage attributes", """
Edit node attributes. This kind of attribute should refer to
relatively static properties, such as memory size.

Usage:

        attribute <node> set <attr> <value>
        attribute <node> delete <attr>
        attribute <node> show <attr>

Example:

        attribute node_1 set memory_size 4096
""")
    help_table["status-attr"] = ("manage status attributes", """
Edit node attributes which are in the CIB status section, i.e.
attributes which hold properties of a more volatile nature. One
typical example is attribute generated by the 'pingd' utility.

Usage:
...............
        status-attr <node> set <attr> <value>
        status-attr <node> delete <attr>
        status-attr <node> show <attr>
...............
Example:
...............
        status-attr node_1 show pingd
""")
    help_table["quit"] = ("exit the program", "")
    help_table["help"] = ("show help", "")
    help_table["end"] = ("go back one level", "")
    cmd_aliases = global_aliases.copy()
    cmd_aliases.update({
        "show": ("list",),
    })
    def __init__(self):
        self.cmd_table = {
            "status": (self.status,(0,1),0,(nodes_list,)),
            "show": (self.show,(0,1),0,(nodes_list,)),
            "standby": (self.standby,(0,1),0,(nodes_list,)),
            "online": (self.online,(0,1),0,(nodes_list,)),
            "delete": (self.delete,(1,1),0,(nodes_list,)),
            "attribute": (self.attribute,(3,4),0,(nodes_list,attr_cmds)),
            "status-attr": (self.status_attr,(3,4),0,(nodes_list,attr_cmds)),
            "help": (self.help,(0,1),0),
            "quit": (cmd_exit,(0,0),0),
            "end": (cmd_end,(0,1),0),
        }
        setup_aliases(self)
    def status(self,cmd,node = None):
        'usage: status [<node>]'
        return ext_cmd("%s -o nodes"%cib_dump)
    def show(self,cmd,node = None):
        'usage: show [<node>]'
        doc = xml2doc("%s -o nodes"%cib_dump)
        if not doc:
            return False
        nodes_node = get_conf_elem(doc, "nodes")
        if not nodes_node:
            return False
        for c in nodes_node.childNodes:
            if not is_element(c) or c.tagName != "node":
                continue
            if node and c.getAttribute("uname") != node:
                continue
            type = uname = id = ""
            other = inst_attr = []
            for attr in c.attributes.keys():
                v = c.getAttribute(attr)
                if attr == "type":
                    type = v
                elif attr == "uname":
                    uname = v
                elif attr == "id":
                    id = v
                else:
                    other[attr] = v
            for c2 in c.childNodes:
                if not is_element(c2):
                    continue
                if c2.tagName == "instance_attributes":
                    inst_attr = nvpairs2list(c2)
            print_node(uname,id,type,other,inst_attr)
    def standby(self,cmd,node = None):
        'usage: standby [<node>]'
        if not node:
            node = this_node
        return ext_cmd(self.node_standby%(node,"on"))
    def online(self,cmd,node = None):
        'usage: online [<node>]'
        if not node:
            node = this_node
        return ext_cmd(self.node_standby%(node,"off"))
    def delete(self,cmd,node):
        'usage: delete <node>'
        rv = True
        if cluster_stack() == "heartbeat":
            rv = ext_cmd(self.hb_delnode%node)
        if rv:
            rv = ext_cmd(self.node_delete%node)
        return rv
    def attribute(self,cmd,*args):
        """usage:
        attribute <node> set <rsc> <value>
        attribute <node> delete <rsc>
        attribute <node> show <rsc>"""
        d = lambda: manage_attr(cmd,self.node_attr,*args)
        return d()
    def status_attr(self,cmd,*args):
        """usage:
        status-attr <node> set <rsc> <value>
        status-attr <node> delete <rsc>
        status-attr <node> show <rsc>"""
        d = lambda: manage_attr(cmd,self.node_status,*args)
        return d()
    def help(self,cmd,topic = ''):
        cmd_help(self.help_table,topic)

def edit_file(fname):
    'Edit a file.'
    if not fname:
        return
    if not user_prefs.editor:
        return
    return os.system("%s %s" % (user_prefs.editor,fname))

def page_string(s):
    'Write string through a pager.'
    if not s:
        return
    w,h = get_winsize()
    if s.count('\n') <= h:
        print s
    elif not user_prefs.pager or not interactive:
        print s
    else:
        pipe_string(user_prefs.pager,s)

def lines2cli(s):
    '''
    Convert a string into a list of lines. Replace continuation
    characters. Strip white space, left and right. Drop empty lines.
    '''
    cl = []
    l = s.split('\n')
    cum = []
    for p in l:
        p = p.strip()
        if p.endswith('\\'):
            p = p.rstrip('\\')
            cum.append(p)
        else:
            cum.append(p)
            cl.append(''.join(cum).strip())
            cum = []
    if cum: # in case s ends with backslash
        cl.append(''.join(cum))
    return [x for x in cl if x]

def get_winsize():
    try:
        import curses
        curses.setupterm()
        w = curses.tigetnum('cols')
        h = curses.tigetnum('lines')
    except:
        try:
            w = os.environ['COLS']
            h = os.environ['LINES']
        except:
            w = 80; h = 25
    return w,h
def multicolumn(l):
    '''
    A ls-like representation of a list of strings.
    A naive approach.
    '''
    min_gap = 2
    w,h = get_winsize()
    max_len = 0
    for s in l:
        if len(s) > max_len:
            max_len = len(s)
    cols = w/(max_len + min_gap)  # approx.
    col_len = w/cols
    for i in range(len(l)/cols):
        s = ''
        for j in range(i*cols,(i+1)*cols):
            if not j < len(l):
                break
            if not s:
                s = "%-*s" % (col_len,l[j])
            elif (j+1)%cols == 0:
                s = "%s%s" % (s,l[j])
            else:
                s = "%s%-*s" % (s,col_len,l[j])
        print s

class RA(object):
    '''
    CIB shadow management class
    '''
    help_table = odict()
    help_table["."] = ("","""
Resource Agents (RA) lists and documentation.
""")
    help_table["classes"] = ("list classes and providers", """
Print all resource agents' classes and, where appropriate, a list
of available providers.

Usage:
...............
        classes
...............
""")
    help_table["list"] = ("list RA for a class (and provider)", """
List available resource agents for the given class. If the class
is `ocf`, supply a provider to get agents which are available
only from that provider.

Usage:
...............
        list <class> [<provider>]
...............
Example:
...............
        list ocf pacemaker
...............
""")
    help_table["meta"] = ("show meta data for a RA", """
Show the meta-data of a resource agent type. This is where users
can find information on how to use a resource agent.

Usage:
...............
        meta <type> <class> [<provider>]
...............
Example:
...............
        meta apache ocf
        meta ipmilan stonith
...............
""")
    help_table["providers"] = ("show providers for a RA", """
List providers for a resource agent type.

Usage:
...............
        providers <type>
...............
Example:
...............
        providers apache
...............
""")
    help_table["quit"] = ("exit the program", "")
    help_table["help"] = ("show help", "")
    help_table["end"] = ("go back one level", "")
    provider_classes = ["ocf"]
    cmd_aliases = global_aliases
    def __init__(self):
        self.cmd_table = {
            "classes": (self.classes,(0,0),0),
            "list": (self.list,(1,2),1),
            "providers": (self.providers,(1,1),1),
            "meta": (self.meta,(2,3),1),
            "help": (self.help,(0,1),0),
            "quit": (cmd_exit,(0,0),0),
            "end": (cmd_end,(0,1),0),
        }
        setup_aliases(self)
    def classes(self,cmd):
        "usage: classes"
        for c in ra_classes():
            if c in self.provider_classes:
                print "%s / %s" % (c,' '.join(ra_providers_all(c)))
            else:
                print "%s" % c
    def providers(self,cmd,ra_type):
        "usage: providers <ra>"
        print ' '.join(ra_providers(ra_type))
    def list(self,cmd,c,p = None):
        "usage: list <class> [<provider>]"
        if not c in ra_classes():
            common_err("class %s does not exist" % c)
            return False
        if p and not p in ra_providers_all(c):
            common_err("there is no provider %s for class %s" % (p,c))
            return False
        multicolumn(ra_types(c,p))
    def meta(self,cmd,ra_type,ra_class,ra_provider = "heartbeat"):
        "usage: meta <ra> <class> [<provider>]"
        ra = RAInfo(ra_class,ra_type,ra_provider)
        try:
            page_string(ra.meta_pretty())
        except:
            return False
    def help(self,cmd,topic = ''):
        cmd_help(self.help_table,topic)

class CibConfig(object):
    '''
    The configuration class
    '''
    help_table = odict()
    help_table["."] = ("","CIB configuration.")
    help_table["verify"] = ("verify the CIB before commit", "Verify the CIB (before commit)")
    help_table["erase"] = ("erase the CIB", "Erase the CIB (careful!).")
    help_table["ptest"] = ("show cluster actions if changes were committed", """
Show PE (policy engine) motions using ptest.

A CIB is constructed using the current user edited version and
the status from the current CIB. This CIB is run through ptest
to show changes. If you have graphviz installed and X11 session,
dotty is run to display the changes graphically.
""")
    help_table["refresh"] = ("refresh from CIB", """
Load the CIB from scratch. All changes are lost. The user is
asked for confirmation beforehand
""")
    help_table["show"] = ("display CIB objects", """
The `show` command displays objects. It may display all objects
or a set of objects. Specify 'changed' to see what changed.

Usage:
...............
        show [xml] [<id> ...]
        show [xml] changed
...............
""")
    help_table["edit"] = ("edit CIB objects", """
This command invokes the editor with the object description. As
with the `show` command, the user may choose to edit all objects
or a set of objects.
If the user insists, he or she may edit the XML edition of the
object.

Usage:
...............
        edit [xml] [<id> ...]
        edit [xml] changed
...............
""")
    help_table["delete"] = ("delete CIB objects", """
The user may delete one or more objects by specifying a list of
ids. If the object to be deleted belongs to a container object,
such as group, and it is the only resource in that container,
then the container is deleted as well.

Usage:
...............
        delete <id> [<id> ...]
...............
""")
    help_table["rename"] = ("rename a CIB object", """
Rename an object. It is recommended to use this command to rename
a resource, because it will take care of updating all related
constraints. Changing ids with the edit command won't have the
same effect.

If you want to rename a resource, it must be stopped.

Usage:
...............
        rename <old_id> <new_id>
...............
""")
    help_table["save"] = ("save the CIB to a file", """
Save the configuration to a file. Optionally, as XML.

Usage:
...............
        save [xml] <file>
...............
Example:
...............
        save myfirstcib.txt
...............
""")
    help_table["load"] = ("import the CIB from a file", """
Load a part of configuration (or all of it) from a local file or
a network URL. The `replace` method replaces the current
configuration with the one from the source. The `update` tries to
import the contents into the current configuration.  The file may
be a CLI file or an XML file.

Usage:
...............
        load [xml] method URL

        method :: replace | update
...............
Example:
...............
        load xml replace myfirstcib.xml
        load xml replace http://storage.big.com/cibs/bigcib.xml
...............
""")
    help_table["template"] = ("edit and import a configuration from a template", """
The specified template is loaded into the editor. It's up to the
user to make a good CRM configuration out of it.

Usage:
...............
        template [xml] url
...............
Example:
...............
        template two-apaches.txt
...............
""")
    help_table["commit"] = ("commit the changes to the CIB", """
The changes at the configure level are not immediately applied to
the CIB, but by this command or on exiting the configure level.
Sometimes, the program will refuse to apply the changes, usually
for good reason. If you know what you're doing, you may say
'commit force' to force the changes.
""")
    help_table["upgrade"] = ("upgrade the CIB to version 1.0", """
If you get the "CIB not supported" error, which typically means
that the current CIB version is coming from the older release,
you may try to upgrade it to the latest revision. The command
used is:

    cibadmin --upgrade --force

If we don't recognize the current CIB as the old one, but you're
sure that it is, you may force the command.

Usage:
...............
        upgrade [force]
...............
""")
    help_table["node"] = ("define a cluster node", """
The node command describes a cluster node. Nodes in the CIB are
commonly created automatically by the CRM. Hence, you should not
need to do this yourself unless you also want to define node
attributes. Note that it is also possible to manage node
attributes at the `node` level.

Usage:
...............
        node <uname>[:<type>]
          [attributes <param>=<value> [<param>=<value>...]]

        type :: normal | member | ping
...............
Example:
...............
        node node1
        node big_node attributes memory=64
...............
""")
    help_table["primitive"] = ("define a resource", """
The primitive command describes a resource.

Usage:
...............
        primitive <rsc> [<class>:[<provider>:]]<type>
          [params attr_list]
          [meta attr_list]
          [operations id_spec]
            [op op_type [<attribute>=<value>...] ...]

        attr_list :: [$id=<id>] <attr>=<val> [<attr>=<val>...] | $id-ref=<id>
        id_spec :: $id=<id> | $id-ref=<id>
        op_type :: start | stop | monitor
...............
Example:
...............
        primitive apcfence stonith:apcsmart \\
          params ttydev=/dev/ttyS0 hostlist="node1 node2" \\
          op start timeout=60s \\
          op monitor interval=30m timeout=60s

        primitive www8 apache \\
          params configfile=/etc/apache/www8.conf \\
          operations $id-ref=apache_ops
...............
""")
    help_table["group"] = ("define a group", """
The `group` command creates a group of resources.

Usage:
...............
        group <name> <rsc> [<rsc>...]
          [meta attr_list]
          [params attr_list]

        attr_list :: [$id=<id>] <attr>=<val> [<attr>=<val>...] | $id-ref=<id>
...............
Example:
...............
        group internal_www disk0 fs0 internal_ip apache \\
          meta target-role=stopped
...............
""")
    help_table["clone"] = ("define a clone", """
The `clone` command creates a resource clone. It may contain a
single primitive resource or one group of resources.

Usage:
...............
        clone <name> <rsc>
          [meta attr_list]
          [params attr_list]

        attr_list :: [$id=<id>] <attr>=<val> [<attr>=<val>...] | $id-ref=<id>
...............
Example:
...............
        clone cl_fence apc_1 \\
          meta clone-node-max=1 globally-unique=false
...............
""")
    help_table["ms"] = ("define a master-slave resource", """
The `ms` command creates a master/slave resource type. It may contain a
single primitive resource or one group of resources.

Usage:
...............
        ms <name> <rsc>
          [meta attr_list]
          [params attr_list]

        attr_list :: [$id=<id>] <attr>=<val> [<attr>=<val>...] | $id-ref=<id>
...............
Example:
...............
        ms disk1 drbd1 \\
          meta notify=true globally-unique=false
...............
""")
    help_table["location"] = ("a location preference", """
`location` defines the preference of nodes for the given
resource. The location constraints consist of one or more rules
which specify a score to be awarded if the rule matches.

Usage:
...............
        location <id> <rsc> {node_pref|rules}

        node_pref :: <score>: <node>

        rules ::
          rule [id_spec] [$role=<role>] <score>: <expression>
          [rule [id_spec] [$role=<role>] <score>: <expression> ...]

        id_spec :: $id=<id> | $id-ref=<id>
        score :: <number> | <attribute> | [-]inf
        expression :: <single_exp> [bool_op <simple_exp> ...]
                      | <date_expr>
        bool_op :: or | and
        single_exp :: <attribute> [type:]<binary_op> <value>
                      | <unary_op> <attribute>
        type :: string | version | number
        binary_op :: lt | gt | lte | gte | eq | ne
        unary_op :: defined | not_defined

        date_expr :: date_op <start> [<end>]  (TBD)
...............
Examples:
...............
        location conn_1 internal_www 100: node1

        location conn_1 internal_www \\
          rule 100: #uname eq node1 \\
          rule pingd: defined pingd

        location conn_2 dummy_float \\
          rule -inf: not_defined pingd or pingd lte 0
...............
""")
    help_table["colocation"] = ("colocate resources", """
This constraint expresses the placement relation between two
resources.

Usage:
...............
        colocation <id> <score>: <rsc>[:<role>] <rsc>[:<role>]
...............
Example:
...............
        colocation dummy_and_apache -inf: apache dummy
...............
""")
    help_table["order"] = ("order resources", """
This constraint expresses the order of actions on two resources.

Usage:
...............
        order <id> score-type: <first-rsc>[:<action>] <then-rsc>[:<action>]
          [symmetrical=<bool>]

        score-type :: advisory | mandatory | <score>
...............
Example:
...............
        order c_apache_1 mandatory: apache:start ip_1
...............
""")
    help_table["property"] = ("set a cluster property", """
Set the cluster (`crm_config`) options.

Usage:
...............
        property [$id=<set_id>]
            <option>=<value> [<option>=<value>...]
...............
Example:
...............
        property stonith-enabled=true
...............
""")
    help_table["rsc_defaults"] = ("set resource defaults", """
Set defaults for the resource meta attributes.

Usage:
...............
        rsc_defaults [$id=<set_id>]
            <option>=<value> [<option>=<value>...]
...............
Example:
...............
        rsc_defaults failure-timeout=3m
...............
""")
    help_table["op_defaults"] = ("set resource operations defaults", """
Set defaults for the operations meta attributes.

Usage:
...............
        op_defaults [$id=<set_id>]
            <option>=<value> [<option>=<value>...]
...............
Example:
...............
        op_defaults record-pending=true
...............
""")
    help_table["monitor"] = ("add monitor operation to a primitive", """
Add monitor operation to a primitive.

Usage:
...............
        monitor <rsc>[:<role>] <interval>[:<timeout>]
...............
Example:
...............
        monitor apcfence 60m:60s
...............
""")
    help_table["quit"] = ("exit the program", "")
    help_table["help"] = ("show help", "")
    help_table["end"] = ("go back one level", "")
    cmd_aliases = global_aliases.copy()
    cmd_aliases.update({
        "colocation": ("collocation",),
        "ms": ("master",),
    })
    def __init__(self):
        self.cmd_table = {
            "erase": (self.erase,(0,0),1),
            "verify": (self.verify,(0,0),1),
            "refresh": (self.refresh,(0,0),1),
            "ptest": (self.ptest,(0,0),1),
            "commit": (self.commit,(0,1),1),
            "upgrade": (self.upgrade,(0,1),1),
            "show": (self.show,(0,),1,(id_xml_list,id_list,loop)),
            "edit": (self.edit,(0,),1,(id_xml_list,id_list,loop)),
            "delete": (self.delete,(1,),1,(id_list,loop)),
            "rename": (self.rename,(2,2),1,(id_list,)),
            "save": (self.save,(1,2),1),
            "load": (self.load,(2,3),1),
            "template": (self.template,(1,2),1),
            "node": (self.conf_node,(1,),1),
            "primitive": (self.conf_primitive,(2,),1,(null_list, \
                    ra_classes_list, primitive_complete_complex, loop)),
            "group": (self.conf_group,(2,),1,(null_list,f_prim_id_list,loop)),
            "clone": (self.conf_clone,(2,),1,(null_list,f_children_id_list)),
            "ms": (self.conf_ms,(2,),1,(null_list,f_children_id_list)),
            "location": (self.conf_location,(2,),1,(null_list,rsc_id_list)),
            "colocation": (self.conf_colocation,(2,),1,(null_list,null_list,rsc_id_list,rsc_id_list)),
            "order": (self.conf_order,(2,),1,(null_list,null_list,rsc_id_list,rsc_id_list)),
            "property": (self.conf_property,(1,),1,(property_complete,loop)),
            "rsc_defaults": (self.conf_rsc_defaults,(1,),1),
            "op_defaults": (self.conf_op_defaults,(1,),1),
            "monitor": (self.conf_monitor,(2,2),1),
            "ra": RA,
            "cib": CibShadow,
            "help": (self.help,(0,1),1),
            "end": (self.end,(0,1),1),
            "quit": (self.exit,(0,0),1),
            "_test": (self.check_structure,(0,0),1),
        }
        setup_aliases(self)
        if not build_completions:
            cib_factory.initialize()
    def check_structure(self,cmd):
        return cib_factory.check_structure()
    def _mkset_obj(self,*args):
        if args and args[0] == "xml":
            obj = lambda: CibObjectSetRaw(*args[1:])
        else:
            obj = lambda: CibObjectSetCli(*args)
        return obj()
    def show(self,cmd,*args):
        "usage: show [xml] [<id>...]"
        set_obj = self._mkset_obj(*args)
        set_obj.show()
    def edit(self,cmd,*args):
        "usage: edit [xml] [<id>...]"
        set_obj = self._mkset_obj(*args)
        set_obj.edit()
    def verify(self,cmd):
        "usage: verify"
        set_obj = self._mkset_obj("xml")
        return set_obj.verify()
    def save(self,cmd,*args):
        "usage: save [xml] <filename>"
        if args[0] == "xml":
            f = args[1]
            set_obj = self._mkset_obj("xml")
        else:
            f = args[0]
            set_obj = self._mkset_obj()
        return set_obj.save_to_file(f)
    def load(self,cmd,*args):
        "usage: load [xml] {replace|update} {<url>|<path>}"
        if args[0] == "xml":
            url = args[2]
            method = args[1]
            set_obj = self._mkset_obj("xml","NOOBJ")
        else:
            url = args[1]
            method = args[0]
            set_obj = self._mkset_obj("NOOBJ")
        set_obj.import_file(method,url)
    def template(self,cmd,*args):
        "usage: template [xml] {<url>|<path>}"
        if batch:
            common_info("template not allowed in batch mode")
            return
        if args[0] == "xml":
            url = args[1]
            set_obj = self._mkset_obj("xml","NOOBJ")
        else:
            url = args[0]
            set_obj = self._mkset_obj("NOOBJ")
        set_obj.import_template(url)
    def delete(self,cmd,*args):
        "usage: delete <id> [<id>...]"
        return cib_factory.delete(*args)
    def rename(self,cmd,old_id,new_id):
        "usage: rename <old_id> <new_id>"
        return cib_factory.rename(old_id,new_id)
    def erase(self,cmd):
        "usage: erase"
        return cib_factory.erase()
    def refresh(self,cmd):
        "usage: refresh"
        if interactive and cib_factory.has_cib_changed():
            if not ask("All changes will be dropped. Do you want to proceed?"):
                return
        cib_factory.refresh()
    def ptest(self,cmd):
        "usage: ptest"
        set_obj = self._mkset_obj("xml")
        set_obj.ptest()
    def commit(self,cmd,force = None):
        "usage: commit [force]"
        if not cib_factory.has_cib_changed():
            common_info("apparently there is nothing to commit")
            common_info("try changing something first")
            return
        wcache.clear()
        if not force:
            rc = self.verify("verify")
            if rc not in (0,1):
                common_warn("crm_verify(8) found errors in the CIB")
                common_info("use commit force if you know what you are doing")
                return False
            else:
                return cib_factory.commit()
        elif force == "force":
            return cib_factory.commit(True)
        else:
            syntax_err((cmd,force))
            return False
    def upgrade(self,cmd,force = None):
        "usage: upgrade [force]"
        if not force:
            return cib_factory.upgrade_cib_06to10()
        elif force == "force":
            return cib_factory.upgrade_cib_06to10(True)
        else:
            syntax_err((cmd,force))
            return False
    def __conf_object(self,cmd,*args):
        "The configure object command."
        f = lambda: cib_factory.create_object(cmd,*args)
        return f()
    def conf_node(self,cmd,*args):
        """usage: node <uname>[:<type>]
           [attributes <param>=<value> [<param>=<value>...]]"""
        return self.__conf_object(cmd,*args)
    def conf_primitive(self,cmd,*args):
        """usage: primitive <rsc> [<class>:[<provider>:]]<type>
        [params <param>=<value> [<param>=<value>...]]
        [meta <attribute>=<value> [<attribute>=<value>...]]
        [operations id_spec
            [op op_type [<attribute>=<value>...] ...]]"""
        return self.__conf_object(cmd,*args)
    def conf_group(self,cmd,*args):
        """usage: group <name> <rsc> [<rsc>...]
        [params <param>=<value> [<param>=<value>...]]
        [meta <attribute>=<value> [<attribute>=<value>...]]"""
        return self.__conf_object(cmd,*args)
    def conf_clone(self,cmd,*args):
        """usage: clone <name> <rsc>
        [params <param>=<value> [<param>=<value>...]]
        [meta <attribute>=<value> [<attribute>=<value>...]]"""
        return self.__conf_object(cmd,*args)
    def conf_ms(self,cmd,*args):
        """usage: ms <name> <rsc>
        [params <param>=<value> [<param>=<value>...]]
        [meta <attribute>=<value> [<attribute>=<value>...]]"""
        return self.__conf_object(cmd,*args)
    def conf_location(self,cmd,*args):
        """usage: location <id> <rsc> {node_pref|rules}

        node_pref :: <score>: <node>

        rules ::
          rule [id_spec] [$role=<role>] <score>: <expression>
          [rule [id_spec] [$role=<role>] <score>: <expression> ...]

        id_spec :: $id=<id> | $id-ref=<id>"""
        return self.__conf_object(cmd,*args)
    def conf_colocation(self,cmd,*args):
        """usage: colocation <id> <score>: <rsc>[:<role>] <rsc>[:<role>]
        """
        return self.__conf_object(cmd,*args)
    def conf_order(self,cmd,*args):
        """usage: order <id> score-type: <first-rsc>[:<action>] <then-rsc>[:<action>]
        [symmetrical=<bool>]"""
        return self.__conf_object(cmd,*args)
    def conf_property(self,cmd,*args):
        "usage: property [$id=<set_id>] <option>=<value>"
        return self.__conf_object(cmd,*args)
    def conf_rsc_defaults(self,cmd,*args):
        "usage: rsc_defaults [$id=<set_id>] <option>=<value>"
        return self.__conf_object(cmd,*args)
    def conf_op_defaults(self,cmd,*args):
        "usage: op_defaults [$id=<set_id>] <option>=<value>"
        return self.__conf_object(cmd,*args)
    def conf_monitor(self,cmd,*args):
        "usage: monitor <rsc>[:<role>] <interval>[:<timeout>]"
        return self.__conf_object(cmd,*args)
    def end_game(self, no_questions_asked = False):
        if cib_factory.has_cib_changed():
            if no_questions_asked or not interactive or \
                ask("There are changes pending. Do you want to commit them?"):
                cib_factory.commit()
        cib_factory.reset()
        wcache.clear()
    def end(self,cmd,dir = ".."):
        "usage: end"
        self.end_game()
        cmd_end(cmd,dir)
    def help(self,cmd,topic = ''):
        "usage: help [<topic>]"
        cmd_help(self.help_table,topic)
    def exit(self,cmd):
        "usage: exit"
        self.end_game()
        cmd_exit(cmd)

def is_element(xmlnode):
    return xmlnode and xmlnode.nodeType == xmlnode.ELEMENT_NODE

def nameandid(xmlnode,level):
    if xmlnode.nodeType == xmlnode.ELEMENT_NODE:
        print level*' ',xmlnode.tagName,xmlnode.getAttribute("id"),xmlnode.getAttribute("name")

def xmltraverse(xmlnode,fun,ts=0):
    for c in xmlnode.childNodes:
        if is_element(c):
            fun(c,ts)
            xmltraverse(c,fun,ts+1)

def xmltraverse_thin(xmlnode,fun,ts=0):
    '''
    Skip elements which may be resources themselves.
    NB: Call this only on resource (or constraint) nodes, but
    never on cib or configuration!
    '''
    for c in xmlnode.childNodes:
        if is_element(c) and not c.tagName in ('primitive','group'):
            xmltraverse_thin(c,fun,ts+1)
    fun(xmlnode,ts)

def xml_processnodes(xmlnode,node_filter,proc):
    '''
    Process with proc all nodes that match filter.
    '''
    node_list = []
    for child in xmlnode.childNodes:
        if node_filter(child):
            node_list.append(child)
        if child.hasChildNodes():
            xml_processnodes(child,node_filter,proc)
    if node_list:
        proc(node_list)

# filter the cib
def is_whitespace(node):
    return node.nodeType == node.TEXT_NODE and not node.data.strip()
def is_comment(node):
    return node.nodeType == node.COMMENT_NODE
def is_status_node(node):
    return is_element(node) and node.tagName == "status"

container_tags = ("group", "clone", "ms", "master")
clonems_tags = ("clone", "ms", "master")
resource_tags = ("primitive","group","clone","ms","master")
constraint_tags = ("rsc_location","rsc_colocation","rsc_order")
constraint_rsc_refs = ("rsc","with-rsc","first","then")
children_tags = ("group", "primitive")
nvpairs_tags = ("meta_attributes", "instance_attributes")
defaults_tags = ("rsc_defaults","op_defaults")
def is_emptynvpairs(node):
    return is_element(node) \
        and node.tagName in nvpairs_tags \
        and not node.hasChildNodes()
def is_group(node):
    return is_element(node) \
        and node.tagName == "group"
def is_ms(node):
    return is_element(node) \
        and node.tagName in ("master","ms")
def is_clone(node):
    return is_element(node) \
        and node.tagName == "clone"
def is_clonems(node):
    return is_element(node) \
        and node.tagName in clonems_tags
def is_container(node):
    return is_element(node) \
        and node.tagName in container_tags
def is_primitive(node):
    return is_element(node) \
        and node.tagName == "primitive"
def is_resource(node):
    return is_element(node) \
        and node.tagName in resource_tags
def is_child_rsc(node):
    return is_element(node) \
        and node.tagName in children_tags
def is_constraint(node):
    return is_element(node) \
        and node.tagName in constraint_tags
def is_defaults(node):
    return is_element(node) \
        and node.tagName in defaults_tags
def rsc_constraint(rsc_id,cons_node):
    if not is_element(cons_node):
        return False
    for attr in cons_node.attributes.keys():
        if attr in constraint_rsc_refs \
                and rsc_id == cons_node.getAttribute(attr):
            return True
    return False

resource_cli_names = ("primitive","group","clone","ms","master")
constraint_cli_names = ("location","colocation","order")
def is_resource_cli(s):
    return s in resource_cli_names
def is_constraint_cli(s):
    return s in constraint_cli_names

def sort_container_children(node_list):
    '''
    Make sure that attributes's nodes are first, followed by the
    elements (primitive/group). The order of elements is not
    disturbed, they are just shifted to end!
    '''
    for node in node_list:
        children = []
        for c in node.childNodes:
            if is_element(c) and c.tagName in children_tags:
                children.append(c)
        for c in children:
            node.removeChild(c)
        for c in children:
            node.appendChild(c)
def rmnodes(node_list):
    for node in node_list:
        node.parentNode.removeChild(node)
        node.unlink()
def printid(node_list):
    for node in node_list:
        id = node.getAttribute("id")
        if id: print "node id:",id
def sanitize_cib(doc):
    xml_processnodes(doc,is_status_node,rmnodes)
    #xml_processnodes(doc,is_element,printid)
    #xml_processnodes(doc,is_emptynvpairs,rmnodes)
    xml_processnodes(doc,is_whitespace,rmnodes)
    xml_processnodes(doc,is_comment,rmnodes)
    xml_processnodes(doc,is_container,sort_container_children)

def rename_id(node,old_id,new_id):
    if node.getAttribute("id") == old_id:
        node.setAttribute("id", new_id)
def rename_rscref(c_node,old_id,new_id):
    for attr in c_node.attributes.keys():
        if attr in constraint_rsc_refs and \
                c_node.getAttribute(attr) == old_id:
            c_node.setAttribute(attr, new_id)
def silly_constraint(c_node,rsc_id):
    'Remove a constraint from rsc_id to rsc_id.'
    cnt = 0
    for attr in c_node.attributes.keys():
        if attr in constraint_rsc_refs and \
                c_node.getAttribute(attr) == rsc_id:
            cnt += 1
    return cnt == 2

class IdMgmt(object):
    '''
    Make sure that ids are unique.
    '''
    def __init__(self):
        self._id_store = {}
        self.ok = True # error var
    def new(self,node,pfx):
        '''
        Create a unique id for the xml node.
        '''
        name = node.getAttribute("name")
        if node.tagName == "nvpair":
            node_id = "%s-%s" % (pfx,name)
        elif node.tagName == "op":
            interval = node.getAttribute("interval")
            if interval:
                node_id = "%s-%s-%s" % (pfx,name,interval)
            else:
                node_id = "%s-%s" % (pfx,name)
        else:
            try:
                hint = hints_list[node.tagName]
            except: hint = ''
            if hint:
                node_id = "%s-%s" % (pfx,hint)
            else:
                node_id = "%s" % pfx
        if self.is_used(node_id):
            for cnt in range(99): # shouldn't really get here
                try_id = "%s-%d" % (node_id,cnt)
                if not self.is_used(try_id):
                    node_id = try_id
                    break
        self.save(node_id)
        return node_id
    def check_node(self,node,lvl):
        node_id = node.getAttribute("id")
        if not node_id:
            return
        if id_in_use(node_id):
            self.ok = False
            return
    def _store_node(self,node,lvl):
        self.save(node.getAttribute("id"))
    def _drop_node(self,node,lvl):
        self.remove(node.getAttribute("id"))
    def check_xml(self,node):
        self.ok = True
        xmltraverse_thin(node,self.check_node)
        return self.ok
    def store_xml(self,node):
        if not self.check_xml(node):
            return False
        xmltraverse_thin(node,self._store_node)
        return True
    def remove_xml(self,node):
        xmltraverse_thin(node,self._drop_node)
    def replace_xml(self,oldnode,newnode):
        self.remove_xml(oldnode)
        if not self.store_xml(newnode):
            self.store_xml(oldnode)
            return False
        return True
    def is_used(self,node_id):
        return node_id in self._id_store
    def save(self,node_id):
        if not node_id: return
        self._id_store[node_id] = 1
    def rename(self,old_id,new_id):
        if not old_id or not new_id: return
        if not self.is_used(old_id): return
        if self.is_used(new_id): return
        self.remove(old_id)
        self.save(new_id)
    def remove(self,node_id):
        if not node_id: return
        try:
            del self._id_store[node_id]
        except KeyError:
            pass
    def clear(self):
        self._id_store = {}

def id_in_use(obj_id):
    if id_store.is_used(obj_id):
        id_used_err(obj_id)
        return True
    return False

#
# resource type definition
#
def disambiguate_ra_type(s):
    '''
    Unravel [class:[provider:]type]
    '''
    l = s.split(':')
    if not l or len(l) > 3:
        return None
    if len(l) == 3:
        return l
    elif len(l) == 2:
        ra_class,ra_type = l
    else:
        ra_class = "ocf"
        ra_type = l[0]
    ra_provider = ''
    if ra_class == "ocf":
        pl = ra_providers(ra_type,ra_class)
        if pl and len(pl) == 1:
            ra_provider = pl[0]
    return ra_class,ra_provider,ra_type
def ra_type_validate(s, ra_class, provider, rsc_type):
    '''
    Only ocf ra class supports providers.
    '''
    if not rsc_type:
        common_err("bad resource type specification %s"%s)
        return False
    if ra_class == "ocf":
        if not provider:
            common_err("provider could not be determined for %s"%s)
            return False
    else:
        if provider:
            common_warn("ra class %s does not support providers"%ra_class)
            return False
    return True

#
# CLI parsing utilities
# WARNING: ugly code ahead (to be replaced some day by a proper
# yacc parser, if there's such a thing)
#
def cli_parse_rsctype(s, pl):
    '''
    Parse the resource type.
    '''
    ra_class,provider,rsc_type = disambiguate_ra_type(s)
    if not ra_type_validate(s,ra_class,provider,rsc_type):
        return None
    pl.append(["class",ra_class])
    if ra_class == "ocf":
        pl.append(["provider",provider])
    pl.append(["type",rsc_type])
def cli_parse_attr_strict(s,pl):
    '''
    Parse attributes in the 'p=v' form.
    '''
    if s and '=' in s[0]:
        n,v = s[0].split('=',1)
        pl.append([n,v])
        cli_parse_attr_strict(s[1:],pl)
def cli_parse_attr(s,pl):
    '''
    Parse attributes in the 'p=v' form.
    Allow also the 'p' form (no value) unless p is one of the
    attr_list_keyw words.
    '''
    attr_lists_keyw = ("params","meta","operations","op","attributes")
    if s:
        if s[0] in attr_lists_keyw:
            return
        if '=' in s[0]:
            n,v = s[0].split('=',1)
        else:
            n = s[0]; v = None
        pl.append([n,v])
        cli_parse_attr(s[1:],pl)
def check_operation(pl):
    op_name = find_value(pl,"name")
    if not re.match("^[a-z][a-z_-]*$", op_name):
        common_err("%s: bad action name" % op_name)
        return False
    if op_name == "monitor" and not find_value(pl,"interval"):
        common_err("monitor requires interval")
        return False
    return True
def parse_resource(s):
    el_type = s[0]
    if el_type == "master": # ugly kludge :(
        el_type = "ms"
    attr_lists_keyw = ["params","meta"]
    cli_list = []
    # the head
    head = []
    head.append(["id",s[1]])
    i = 3
    if el_type == "primitive":
        cli_parse_rsctype(s[2],head)
        if not find_value(head,"type"):
            syntax_err(s[2:], context = "primitive")
            return False
    else:
        cl = []
        cl.append(s[2])
        if el_type == "group":
            while i < len(s):
                if s[i] in attr_lists_keyw:
                    break
                else:
                    cl.append(s[i])
                    i += 1 # skip to the next token
        head.append(["$children",cl])
    cli_list.append([el_type,head])
    # the rest
    state = 0 # 1: reading operations; 2: operations read
    while len(s) > i+1:
        pl = []
        keyw = s[i]
        if keyw in attr_lists_keyw:
            if state == 1:
                state = 2
        elif el_type == "primitive" and state == 0 and keyw == "operations":
            state = 1
        elif el_type == "primitive" and state <= 1 and keyw == "op":
            if state == 0:
                state = 1
            pl.append(["name",s[i+1]])
        else:
            syntax_err(s[i:], context = 'primitive')
            return False
        if keyw == "op":
            if len(s) > i+2:
                cli_parse_attr(s[i+2:],pl)
            if not check_operation(pl):
                return False
        else:
            cli_parse_attr(s[i+1:],pl)
            if len(pl) == 0:
                syntax_err(s[i:], context = 'primitive')
                return False
        i += len(pl)+1
        # interval is obligatory for ops, supply 0 if not there
        if keyw == "op" and not find_value(pl,"interval"):
            pl.append(["interval","0"])
        cli_list.append([keyw,pl])
    if len(s) > i:
        syntax_err(s[i:], context = 'primitive')
        return False
    return cli_list
def parse_op(s):
    if len(s) != 3:
        syntax_err(s, context = s[0])
        return False
    cli_list = []
    head_pl = []
    # this is an op
    cli_list.append(["op",head_pl])
    if not cli_parse_rsc_role(s[1],head_pl):
        return False
    if not cli_parse_op_times(s[2],head_pl):
        return False
    # rename rsc-role to role
    for i in range(len(head_pl)):
        if head_pl[i][0] == "rsc-role":
            head_pl[i][0] = "role"
            break
    # add the operation name
    head_pl.append(["name",s[0]])
    return cli_list

score_type = {'advisory': '0','mandatory': 'INFINITY'}
def cli_parse_score(score,pl):
    if score.endswith(':'):
        score = score.rstrip(':')
    else:
        syntax_err(score, context = 'score')
        return False
    if score in score_type:
        pl.append(["score",score_type[score]])
    elif re.match("^[+-]?(inf|infinity|INFINITY|[[0-9]+)$",score):
        score = score.replace("infinity","INFINITY")
        score = score.replace("inf","INFINITY")
        pl.append(["score",score])
    else:
        pl.append(["score-attribute",score])
    return True
binary_ops = ('lt','gt','lte','gte','eq','ne')
binary_types = ('string' , 'version' , 'number')
unary_ops = ('defined','not_defined')
def is_binary_op(s):
    l = s.split(':')
    if len(l) == 2:
        return l[0] in binary_types and l[1] in binary_ops
    elif len(l) == 1:
        return l[0] in binary_ops
    else:
        return False
def set_binary_op(s,pl):
    l = s.split(':')
    if len(l) == 2:
        pl.append(["type",l[0]])
        pl.append(["operation",l[1]])
    else:
        pl.append(["operation",l[0]])
def cli_get_expression(s,pl):
    if len(s) > 1 and s[0] in unary_ops:
        pl.append(["operation",s[0]])
        pl.append(["attribute",s[1]])
    elif len(s) > 2 and is_binary_op(s[1]):
        pl.append(["attribute",s[0]])
        set_binary_op(s[1],pl)
        pl.append(["value",s[2]])
    else:
        return False
    return True
def parse_rule(s):
    if s[0] != "rule":
        syntax_err(s,context = "rule")
        return 0,None
    rule_list = []
    head_pl = []
    rule_list.append([s[0],head_pl])
    i = 1
    cli_parse_attr_strict(s[i:],head_pl)
    i += len(head_pl)
    if find_value(head_pl,"$id-ref"):
        return i,rule_list
    if not cli_parse_score(s[i],head_pl):
        return i,None
    i += 1
    bool_op = ''
    while len(s) > i+1:
        pl = []
        if not cli_get_expression(s[i:],pl):
            syntax_err(s[i:],context = "rule")
            return i,None
        rule_list.append(["expression",pl])
        i += len(pl)
        if len(s) > i and s[i] in ('or','and'):
            if bool_op and bool_op != s[i]:
                common_err("rule contains different bool operations: %s" % ' '.join(s))
                return i,None
            else:
                bool_op = s[i]
                i += 1
        if len(s) > i and s[i] == "rule":
            break
    if bool_op:
        head_pl.append(["boolean-op",bool_op])
    return i,rule_list
def parse_location(s):
    cli_list = []
    head_pl = []
    head_pl.append(["id",s[1]])
    head_pl.append(["rsc",s[2]])
    cli_list.append([s[0],head_pl])
    if len(s) == 5: # the short node preference form
        if not cli_parse_score(s[3],head_pl):
            return False
        head_pl.append(["node",s[4]])
        return cli_list
    i = 3
    while i < len(s):
        numtoks,l = parse_rule(s[i:])
        if not l:
            return False
        cli_list += l
        i += numtoks
    if len(s) < i:
        syntax_err(s[i:],context = "location")
        return False
    return cli_list

def cli_opt_symmetrical(s,pl):
    if not s:
        return True
    pl1 = []
    cli_parse_attr(s,pl1)
    if len(pl1) != 1 or not find_value(pl1,"symmetrical"):
        syntax_err(s,context = "order")
        return False
    pl += pl1
    return True
roles = ('Stopped', 'Started', 'Master', 'Slave')
def cli_parse_rsc_role(s,pl,attr_pfx = ''):
    l = s.split(':')
    pl.append([attr_pfx+"rsc",l[0]])
    if len(l) == 2:
        if l[1] not in roles:
            bad_def_err("resource role",s)
            return False
        pl.append([attr_pfx+"rsc-role",l[1]])
    elif len(l) > 2:
        bad_def_err("resource role",s)
        return False
    return True
def cli_parse_op_times(s,pl):
    l = s.split(':')
    pl.append(["interval",l[0]])
    if len(l) == 2:
        pl.append(["timeout",l[1]])
    elif len(l) > 2:
        bad_def_err("op times",s)
        return False
    return True

def parse_colocation(s):
    cli_list = []
    head_pl = []
    cli_list.append([s[0],head_pl])
    if len(s) != 5:
        syntax_err(s,context = "colocation")
        return False
    head_pl.append(["id",s[1]])
    if not cli_parse_score(s[2],head_pl):
        return False
    if not cli_parse_rsc_role(s[3],head_pl):
        return False
    if not cli_parse_rsc_role(s[4],head_pl,'with-'):
        return False
    return cli_list
actions = ( 'start', 'promote', 'demote', 'stop')
def cli_parse_rsc_action(s,pl,rsc_pos):
    l = s.split(':')
    pl.append([rsc_pos,l[0]])
    if len(l) == 2:
        if l[1] not in actions:
            bad_def_err("resource action",s)
            return False
        pl.append([rsc_pos+"-action",l[1]])
    elif len(l) > 1:
        bad_def_err("resource action",s)
        return False
    return True

def parse_order(s):
    cli_list = []
    head_pl = []
    cli_list.append([s[0],head_pl])
    if len(s) < 5 or len(s) > 6:
        syntax_err(s,context = "order")
        return False
    head_pl.append(["id",s[1]])
    if not cli_parse_score(s[2],head_pl):
        return False
    if not cli_parse_rsc_action(s[3],head_pl,'first'):
        return False
    if not cli_parse_rsc_action(s[4],head_pl,'then'):
        return False
    if not cli_opt_symmetrical(s[5:],head_pl):
        return False
    return cli_list

def parse_constraint(s):
    if s[0] == "location":
        return parse_location(s)
    elif s[0] == "colocation":
        return parse_colocation(s)
    elif s[0] == "order":
        return parse_order(s)
def parse_property(s):
    cli_list = []
    head_pl = []
    cli_list.append([s[0],head_pl])
    cli_parse_attr(s[1:],head_pl)
    if len(head_pl) < 0 or len(s) > len(head_pl)+1:
        syntax_err(s, context = s[0])
        return False
    return cli_list
def cli_parse_uname(s, pl):
    l = s.split(':')
    if not l or len(l) > 2:
        return None
    pl.append(["uname",l[0]])
    if len(l) == 2:
        pl.append(["type",l[1]])
def parse_node(s):
    cli_list = []
    # the head
    head = []
    # optional $id
    id = ''
    opt_id_l = []
    i = 1
    cli_parse_attr_strict(s[i:],opt_id_l)
    if opt_id_l:
        id = find_value(opt_id_l,"$id")
        i += 1
    # uname[:type]
    cli_parse_uname(s[i],head)
    uname = find_value(head,"uname")
    if not uname:
        return False
    head.append(["id",id and id or uname])
    # drop type if default
    type = find_value(head,"type")
    if type == CibNode.default_type:
        head.remove(["type",type])
    cli_list.append([s[0],head])
    if len(s) == i:
        return cli_list
    # the rest
    i += 1
    keyw = CibNode.node_attributes_keyw # some day there may be more than one
    while len(s) > i+1:
        if s[i] != keyw:
            syntax_err(s[i:], context = 'node')
            return False
        pl = []
        cli_parse_attr(s[i+1:],pl)
        if len(pl) == 0:
            syntax_err(s[i:], context = 'node')
            return False
        i += len(pl)+1
        cli_list.append([keyw,pl])
    if len(s) > i:
        syntax_err(s[i:], context = 'node')
        return False
    return cli_list

def parse_cli(s):
    '''
    Input: a list of tokens (or a CLI format string).
    Return: a list of items; each item is a tuple
        with two members: a string (tag) and a nvpairs or
        attributes dict.
    '''
    if type(s) == type(u''):
        s = s.encode('ascii')
    if type(s) == type(''):
        try: s = shlex.split(s)
        except ValueError, msg:
            common_err(msg)
            return False
    while '\n' in s:
        s.remove('\n')
    if s and s[0].startswith('#'):
        return None
    if len(s) > 1 and (s[0] == "property" or s[0] in defaults_tags):
        return parse_property(s)
    if len(s) > 1 and s[0] == "node":
        return parse_node(s)
    if len(s) < 3: # we want at least two tokens
        syntax_err(s)
        return False
    if is_resource_cli(s[0]):
        return parse_resource(s)
    elif is_constraint_cli(s[0]):
        return parse_constraint(s)
    elif s[0] == "monitor":
        return parse_op(s)
    else:
        syntax_err(s)
        return False

#
# XML generate utilities
#
hints_list = {
    "instance_attributes": "instance_attributes",
    "meta_attributes": "meta_attributes",
    "operations": "ops",
    "rule": "rule",
    "expression": "expression",
}
match_list = {
    "node": ("uname"),
    "crm_config": (),
    "rsc_defaults": (),
    "op_defaults": (),
    "cluster_property_set": (),
    "instance_attributes": (),
    "meta_attributes": (),
    "operations": (),
    "nvpair": ("name",),
    "op": ("name","interval"),
    "rule": ("score","score-attribute","role"),
    "expression": ("attribute","operation","value"),
}
def set_id_used_attr(node):
    node.setAttribute("__id_used", "Yes")
def is_id_used_attr(node):
    return node.getAttribute("__id_used") == "Yes"
def remove_id_used_attr(node,lvl):
    if is_element(node) and is_id_used_attr(node):
        node.removeAttribute("__id_used")
def remove_id_used_attributes(node):
    if node:
        xmltraverse(node, remove_id_used_attr)
def lookup_node(node,oldnode,location_only = False):
    '''
    Find a child of oldnode which matches node.
    '''
    #print "match:",node.tagName,oldnode.getAttribute("id")
    if not oldnode:
        return None
    try:
        attr_list = match_list[node.tagName]
    except KeyError:
        attr_list = []
    for c in oldnode.childNodes:
        if not is_element(c):
            continue
        if not location_only and is_id_used_attr(c):
            continue
        if node.tagName == c.tagName:
            failed = False
            for a in attr_list:
                if node.getAttribute(a) != c.getAttribute(a):
                    failed = True
                    break
            if not failed:
                return c
    return None

def set_id(node,oldnode,id_hint,id_required = True):
    '''
    Set the id attribute for the node.
    Procedure:
    - if the node already contains "id", keep it
    - if the old node contains "id", copy that
    - if neither is true, then create a new one using id_hint
      (exception: if not id_required, then no new id is generated)
    Finally, save the new id in id_store.
    '''
    old_id = None
    new_id = node.getAttribute("id")
    if oldnode and oldnode.getAttribute("id"):
        old_id = oldnode.getAttribute("id")
    if not new_id:
        new_id = old_id
    if not new_id:
        if id_required:
            new_id = id_store.new(node,id_hint)
    else:
        id_store.save(new_id)
    if new_id:
        node.setAttribute("id",new_id)
        if oldnode and old_id == new_id:
            set_id_used_attr(oldnode)

def mkxmlsimple(e,oldnode,id_hint):
    '''
    Create an xml node from the (name,dict) pair. The name is the
    name of the element. The dict contains a set of attributes.
    '''
    node = cib_factory.createElement(e[0])
    for n,v in e[1]:
        if n == "$children": # this one's skipped
            continue
        if n.startswith('$'):
            n = n.lstrip('$')
        if (type(v) != type('') and type(v) != type(u'')) \
                or v: # skip empty strings
            node.setAttribute(n,v)
    set_id(node,lookup_node(node,oldnode),id_hint)
    return node

def find_value(pl,name):
    for n,v in pl:
        if n == name:
            return v
    return None
def find_operation(rsc_node,name,interval):
    op_node_l = rsc_node.getElementsByTagName("operations")
    for ops in op_node_l:
        for c in ops.childNodes:
            if not is_element(c):
                continue
            if c.tagName != "op":
                continue
            if c.getAttribute("name") == name \
                    and c.getAttribute("interval") == interval:
                return c
def mkxmlnvpairs(e,oldnode,id_hint):
    '''
    Create xml from the (name,dict) pair. The name is the name of
    the element. The dict contains a set of nvpairs. Stuff such
    as instance_attributes.
    NB: Other tags not containing nvpairs are fine if the dict is empty.
    '''
    node = cib_factory.createElement(e[0])
    match_node = lookup_node(node,oldnode)
    id_ref = find_value(e[1],"$id-ref")
    if id_ref:
        id_ref_2 = cib_factory.resolve_id_ref(e[0],id_ref)
        node.setAttribute("id-ref",id_ref_2)
        if e[0] != "operations":
            return node # id_ref is the only attribute (if not operations)
        e[1].remove(["$id-ref",id_ref])
    v = find_value(e[1],"$id")
    if v:
        node.setAttribute("id",v)
        e[1].remove(["$id",v])
    else:
        if e[0] == "operations": # operations don't need no id
            set_id(node,match_node,id_hint,id_required = False)
        else:
            set_id(node,match_node,id_hint)
    try:
        hint = hints_list[e[0]]
    except: hint = ''
    hint = hint and "%s_%s" % (id_hint,hint) or id_hint
    nvpair_pfx = node.getAttribute("id") or hint
    for n,v in e[1]:
        nvpair = cib_factory.createElement("nvpair")
        node.appendChild(nvpair)
        nvpair.setAttribute("name",n)
        if v != None:
            nvpair.setAttribute("value",v)
        set_id(nvpair,lookup_node(nvpair,match_node),nvpair_pfx)
    return node

def mkxmlop(e,oldnode,id_hint):
    '''
    Create an operation xml from the (name,dict) pair.
    '''
    node = cib_factory.createElement(e[0])
    for n,v in e[1]:
        node.setAttribute(n,v)
    tmp = cib_factory.createElement("operations")
    oldops = lookup_node(tmp,oldnode) # first find old operations
    set_id(node,lookup_node(node,oldops),id_hint)
    return node

conv_list = {
    "params": "instance_attributes",
    "meta": "meta_attributes",
    "property": "cluster_property_set",
    "rsc_defaults": "meta_attributes",
    "op_defaults": "meta_attributes",
    "attributes": "instance_attributes",
}
def mkxmlnode(e,oldnode,id_hint):
    '''
    Create xml from the (name,dict) pair. The name is the name of
    the element. The dict contains either a set of nvpairs or a
    set of attributes. The id is either generated or copied if
    found in the provided xml. Stuff such as instance_attributes.
    '''
    if e[0] in conv_list:
        e[0] = conv_list[e[0]]
    if e[0] in ("instance_attributes","meta_attributes","operations","cluster_property_set"):
        return mkxmlnvpairs(e,oldnode,id_hint)
    elif e[0] == "op":
        return mkxmlop(e,oldnode,id_hint)
    else:
        return mkxmlsimple(e,oldnode,id_hint)

def new_cib():
    doc = xml.dom.minidom.Document()
    cib = doc.createElement("cib")
    doc.appendChild(cib)
    configuration = doc.createElement("configuration")
    cib.appendChild(configuration)
    crm_config = doc.createElement("crm_config")
    configuration.appendChild(crm_config)
    rsc_defaults = doc.createElement("rsc_defaults")
    configuration.appendChild(rsc_defaults)
    op_defaults = doc.createElement("op_defaults")
    configuration.appendChild(op_defaults)
    nodes = doc.createElement("nodes")
    configuration.appendChild(nodes)
    resources = doc.createElement("resources")
    configuration.appendChild(resources)
    constraints = doc.createElement("constraints")
    configuration.appendChild(constraints)
    return doc,cib,crm_config,rsc_defaults,op_defaults,nodes,resources,constraints
def mk_topnode(doc, tag):
    "Get configuration element or create/append if there's none."
    try:
        e = doc.getElementsByTagName(tag)[0]
    except:
        e = doc.createElement(tag)
        conf = doc.getElementsByTagName("configuration")[0]
        if conf:
            conf.appendChild(e)
        else:
            return None
    return e
def get_conf_elem(doc, tag):
    try:
        return doc.getElementsByTagName(tag)[0]
    except:
        return None
def read_cib(cmd):
    doc = xml2doc(cmd)
    if not doc:
        return doc,None
    cib = doc.childNodes[0]
    if not is_element(cib) or cib.tagName != "cib":
        cib_no_elem_err("cib")
        return doc,None
    return doc,cib

def set_nvpair(set_node,name,value):
    n_id = set_node.getAttribute("id")
    for c in set_node.childNodes:
        if is_element(c) and c.getAttribute("name") == name:
            c.setAttribute("value",value)
            return
    np = cib_factory.createElement("nvpair")
    np.setAttribute("name",name)
    np.setAttribute("value",value)
    new_id = id_store.new(np,n_id)
    np.setAttribute("id",new_id)
    set_node.appendChild(np)

def xml_cmp(n,m):
    #if hash(n.toxml()) != hash(m.toxml()):
    #   print n.toprettyxml(); print m.toprettyxml()
    return hash(n.toxml()) == hash(m.toxml())

def show_unrecognized_elems(doc):
    try:
        conf = doc.getElementsByTagName("configuration")[0]
    except:
        common_warn("CIB has no configuration element")
        return
    for topnode in conf.childNodes:
        if not is_element(topnode):
            continue
        if is_defaults(topnode):
            continue
        if not topnode.tagName in cib_topnodes:
            common_warn("unrecognized CIB element %s" % c.tagName)
            continue
        for c in topnode.childNodes:
            if not is_element(topnode):
                continue
            if not c.tagName in cib_object_map:
                common_warn("unrecognized CIB element %s" % c.tagName)

def get_interesting_nodes(node,nodes):
    for c in node.childNodes:
        if is_element(c) and c.tagName in cib_object_map:
            nodes.append(c)
        get_interesting_nodes(c,nodes)
    return nodes

def filter_on_tag(nl,tag):
    return [node for node in nl if node.tagName == tag]
def nodes(node_list):
    return filter_on_tag(node_list,"node")
def primitives(node_list):
    return filter_on_tag(node_list,"primitive")
def groups(node_list):
    return filter_on_tag(node_list,"group")
def clones(node_list):
    return filter_on_tag(node_list,"clone")
def mss(node_list):
    return filter_on_tag(node_list,"master")
def constraints(node_list):
    return filter_on_tag(node_list,"rsc_location") \
        + filter_on_tag(node_list,"rsc_colocation") \
        + filter_on_tag(node_list,"rsc_order")
def properties(node_list):
    return filter_on_tag(node_list,"cluster_property_set") \
        + filter_on_tag(node_list,"rsc_defaults") \
        + filter_on_tag(node_list,"op_defaults")
def processing_sort(nl):
    '''
    It's usually important to process cib objects in this order,
    i.e. simple objects first.
    '''
    return nodes(nl) + primitives(nl) + groups(nl) + mss(nl) + clones(nl) \
        + constraints(nl) + properties(nl)

def filter_on_type(cl,obj_type):
    if type(cl[0]) == type([]):
        return [cli_list for cli_list in cl if cli_list[0][0] == obj_type]
    else:
        return [obj for obj in cl if obj.obj_type == obj_type]
def nodes_cli(cl):
    return filter_on_type(cl,"node")
def primitives_cli(cl):
    return filter_on_type(cl,"primitive")
def groups_cli(cl):
    return filter_on_type(cl,"group")
def clones_cli(cl):
    return filter_on_type(cl,"clone")
def mss_cli(cl):
    return filter_on_type(cl,"ms") + filter_on_type(cl,"master")
def constraints_cli(node_list):
    return filter_on_type(node_list,"location") \
        + filter_on_type(node_list,"colocation") \
        + filter_on_type(node_list,"order")
def properties_cli(cl):
    return filter_on_type(cl,"property") \
        + filter_on_type(cl,"rsc_defaults") \
        + filter_on_type(cl,"op_defaults")
def ops_cli(cl):
    return filter_on_type(cl,"op")
def processing_sort_cli(cl):
    '''
    Return the given list in this order:
    nodes, primitives, groups, ms, clones, constraints, rest
    Both a list of objects (CibObject) and list of cli
    representations accepted.
    '''
    return nodes_cli(cl) + primitives_cli(cl) + groups_cli(cl) + mss_cli(cl) + clones_cli(cl) \
        + constraints_cli(cl) + properties_cli(cl) + ops_cli(cl)

def referenced_resources_cli(cli_list):
    id_list = []
    head = cli_list[0]
    obj_type = head[0]
    if obj_type == "location":
        id_list.append(find_value(head[1],"rsc"))
    elif obj_type == "colocation":
        id_list.append(find_value(head[1],"rsc"))
        id_list.append(find_value(head[1],"with-rsc"))
    elif obj_type == "order":
        id_list.append(find_value(head[1],"first"))
        id_list.append(find_value(head[1],"then"))
    return id_list

#
# CLI format generation utilities (from XML)
#
def cli_format(pl,format):
    if format:
        return ' \\\n\t'.join(pl)
    else:
        return ' '.join(pl)
def cli_pairs(pl):
    'Return a string of name="value" pairs (passed in a list of pairs).'
    l = []
    for n,v in pl:
        l.append(v == None and n or '%s="%s"'%(n,v))
    return ' '.join(l)
def nvpairs2list(node, add_id = False):
    '''
    Convert nvpairs to a list of pairs.
    The id attribute is normally skipped, since they tend to be
    long and therefore obscure the relevant content. For some
    elements, however, they are included (e.g. properties).
    '''
    pl = []
    # if there's id-ref, there can be then _only_ id-ref
    value = node.getAttribute("id-ref")
    if value:
        pl.append(["$id-ref",value])
        return pl
    if add_id:
        value = node.getAttribute("id")
        if value:
            pl.append(["$id",value])
    for c in node.childNodes:
        if not is_element(c):
            continue
        if c.tagName == "attributes":
            pl = nvpairs2list(c)
        name = c.getAttribute("name")
        if "value" in c.attributes.keys():
            value = c.getAttribute("value")
        else:
            value = None
        pl.append([name,value])
    return pl
def cli_op(node):
    pl = []
    for name in node.attributes.keys():
        if name == "name":
            action = node.getAttribute(name)
        elif name != "id": # skip the id
            pl.append([name,node.getAttribute(name)])
    return "op %s %s"%(action,cli_pairs(pl))
def cli_operations(node,format = True):
    l = []
    node_id = node.getAttribute("id")
    s = ''
    if node_id:
        s = '$id="%s"' % node_id
    idref = node.getAttribute("id-ref")
    if idref:
        s = '%s $id-ref="%s"' % (s,idref)
    if s:
        l.append("operations %s" % s)
    for c in node.childNodes:
        if is_element(c) and c.tagName == "op":
            l.append(cli_op(c))
    return cli_format(l,format)
def exp2cli(node):
    operation = node.getAttribute("operation")
    attribute = node.getAttribute("attribute")
    value = node.getAttribute("value")
    if not value:
        return "%s %s" % (operation,attribute)
    else:
        return "%s %s %s" % (attribute,operation,value)
def get_score(node):
    score = node.getAttribute("score")
    if not score:
        score = node.getAttribute("score-attribute")
    else:
        if score.find("INFINITY") >= 0:
            score = score.replace("INFINITY","inf")
    return score + ":"
def cli_rule(node):
    s = []
    node_id = node.getAttribute("id")
    if node_id:
        s.append('$id="%s"' % node_id)
    else:
        idref = node.getAttribute("id-ref")
        if idref:
            return '$id-ref="%s"' % idref
    rsc_role = node.getAttribute("role")
    if rsc_role:
        s.append('$role="%s"' % rsc_role)
    s.append(get_score(node))
    bool_op = node.getAttribute("boolean-op")
    if not bool_op:
        bool_op = "and"
    exp = []
    for c in node.childNodes:
        if is_element(c) and c.tagName == "expression":
            exp.append(exp2cli(c))
    expression = (" %s "%bool_op).join(exp)
    return "%s %s" % (' '.join(s),expression)
def node_head(node):
    obj_type = cib_object_map[node.tagName][0]
    node_id = node.getAttribute("id")
    uname = node.getAttribute("uname")
    s = obj_type
    if node_id != uname:
        s = '%s $id="%s"' % (s, node_id)
    s = '%s %s' % (s, uname)
    type = node.getAttribute("type")
    if type != CibNode.default_type:
        s = '%s:%s' % (s, type)
    return s
def primitive_head(node):
    obj_type = cib_object_map[node.tagName][0]
    node_id = node.getAttribute("id")
    ra_type = node.getAttribute("type")
    ra_class = node.getAttribute("class")
    ra_provider = node.getAttribute("provider")
    s1 = s2 = ''
    if ra_class:
        s1 = "%s:"%ra_class
    if ra_provider:
        s2 = "%s:"%ra_provider
    return "%s %s %s"%(obj_type,node_id,''.join((s1,s2,ra_type)))
def cont_head(node):
    obj_type = cib_object_map[node.tagName][0]
    node_id = node.getAttribute("id")
    children = []
    for c in node.childNodes:
        if not is_element(c):
            continue
        if (obj_type == "group" and is_primitive(c)) or \
                is_child_rsc(c):
            children.append(c.getAttribute("id"))
        elif obj_type in clonems_tags and is_child_rsc(c):
            children.append(c.getAttribute("id"))
    return "%s %s %s"%(obj_type,node_id,' '.join(children))
def location_head(node):
    obj_type = cib_object_map[node.tagName][0]
    node_id = node.getAttribute("id")
    rsc = node.getAttribute("rsc")
    s = "%s %s %s"%(obj_type,node_id,rsc)
    pref_node = node.getAttribute("node")
    if pref_node:
        return "%s %s %s" % (s,get_score(node),pref_node)
    else:
        return s
def mkrscrole(node,n):
    rsc = node.getAttribute(n)
    rsc_role = node.getAttribute(n + "-role")
    if rsc_role:
        return "%s:%s"%(rsc,rsc_role)
    else:
        return rsc
def mkrscaction(node,n):
    rsc = node.getAttribute(n)
    rsc_action = node.getAttribute(n + "-action")
    if rsc_action:
        return "%s:%s"%(rsc,rsc_action)
    else:
        return rsc
def simple_constraint_head(node):
    obj_type = cib_object_map[node.tagName][0]
    node_id = node.getAttribute("id")
    score = get_score(node)
    col = []
    if obj_type == "colocation":
        col.append(mkrscrole(node,"rsc"))
        col.append(mkrscrole(node,"with-rsc"))
    else:
        col.append(mkrscaction(node,"first"))
        col.append(mkrscaction(node,"then"))
    symm = node.getAttribute("symmetrical")
    if symm:
        col.append("symmetrical=%s"%symm)
    return "%s %s %s %s"%(obj_type,node_id,score,' '.join(col))

class CibObjectSet(object):
    '''
    Edit or display a set of cib objects.
    repr() for objects representation and
    save() used to store objects into internal structures
    are defined in subclasses.
    '''
    def __init__(self, *args):
        self.obj_list = []
    def _open_url(self,src):
        import urllib
        try:
            return urllib.urlopen(src)
        except:
            pass
        if src == "-":
            return sys.stdin
        try:
            return open(src)
        except:
            pass
        common_err("could not open %s" % src)
        return False
    def edit_save(self,s,erase = False):
        '''
        Save string s to a tmp file. Invoke editor to edit it.
        Parse/save the resulting file. In case of syntax error,
        allow user to reedit. If erase is True, erase the CIB
        first.
        If no changes are done, return silently.
        '''
        tmp = str2tmp(s)
        if not tmp:
            return
        filehash = hash(s)
        while True:
            if edit_file(tmp) != 0:
                break
            try: f = open(tmp,'r')
            except IOError, msg:
                common_err(msg)
                break
            s = ''.join(f)
            f.close()
            if hash(s) == filehash: # file unchanged
                break
            if erase:
                cib_factory.erase()
            if not self.save(s):
                if ask("There was a parsing problem. Do you want to edit again?"):
                    continue
            break
        try: os.unlink(tmp)
        except: pass
    def edit(self):
        if batch:
            common_info("edit not allowed in batch mode")
            return
        err_buf.buffer() # keep error messages
        s = self.repr()
        err_buf.release() # show them, but get an ack from the user
        return self.edit_save(s)
    def import_template(self,template):
        f = self._open_url(template)
        if not f:
            return
        s = ''.join(f)
        if f != sys.stdin:
            f.close()
        return self.edit_save(s,erase = True)
    def save_to_file(self,fname):
        if fname == "-":
            f = sys.stdout
        else:
            if not batch and os.access(fname,os.F_OK):
                if not ask("File %s exists. Do you want to overwrite it?"%fname):
                    return
            try: f = open(fname,"w")
            except IOError, msg:
                common_err(msg)
                return
        f.write(self.repr())
        f.write('\n')
        if f != sys.stdout:
            f.close()
    def show(self):
        err_buf.buffer() # keep error messages
        s = self.repr()
        err_buf.release() # show them, but get an ack from the user
        page_string(s)
    def import_file(self,method,fname):
        if method == "replace":
            if interactive and cib_factory.has_cib_changed():
                if not ask("This operation will erase all changes. Do you want to proceed?"):
                    return False
            cib_factory.erase()
        f = self._open_url(fname)
        if not f:
            return False
        s = ''.join(f)
        if f != sys.stdin:
            f.close()
        return self.save(s)
    def repr(self):
        '''
        Return a string with objects's representations (either
        CLI or XML).
        '''
        return ''
    def save(self,s):
        '''
        For each object:
            - try to find a corresponding object in obj_list
            - if not found: create new
            - if found: replace the object in the obj_list with
              the new object
        See below for specific implementations.
        '''
        pass
    def lookup_cli(self,cli_list):
        for obj in self.obj_list:
            if obj.matchcli(cli_list):
                return obj
    def lookup(self,xml_obj_type,obj_id):
        for obj in self.obj_list:
            if obj.match(xml_obj_type,obj_id):
                return obj
    def drop_remaining(self):
        'Any remaining objects in obj_list are deleted.'
        l = [x.obj_id for x in self.obj_list]
        cib_factory.delete(*l)

class CibObjectSetCli(CibObjectSet):
    '''
    Edit or display a set of cib objects (using cli notation).
    '''
    def __init__(self, *args):
        CibObjectSet.__init__(self, *args)
        self.obj_list = cib_factory.mkobj_list("cli",*args)
    def repr(self):
        "Return a string containing cli format of all objects."
        if not self.obj_list:
            return ''
        return '\n'.join(obj.repr_cli() \
            for obj in processing_sort_cli(self.obj_list))
    def process(self,cli_list):
        obj = self.lookup_cli(cli_list)
        if obj:
            if obj.update_from_cli(cli_list) != False:
                self.obj_list.remove(obj)
            else:
                return False
        else:
            return cib_factory.create_from_cli(cli_list)
    def save(self,s):
        '''
        Save a user supplied cli format configuration.
        On syntax error, no changes are done and user is
        typically asked to review the configuration (for instance
        on editting).
        On processing errors, there's no way back.
        TODO: Implement undo configuration changes.
        '''
        global lineno
        l = []
        rc = True
        save_lineno = lineno
        lineno = 0
        for cli_text in lines2cli(s):
            lineno += 1
            cli_list = parse_cli(cli_text)
            if cli_list:
                l.append(cli_list)
            elif cli_list == False:
                rc = False
        lineno = save_lineno
        # we can't proceed if there was a syntax error, but we
        # can ask the user to fix problems
        if not rc:
            return rc
        if l:
            for cli_list in processing_sort_cli(l):
                self.process(cli_list)
        self.drop_remaining()
        return rc

class CibObjectSetRaw(CibObjectSet):
    '''
    Edit or display one or more CIB objects (XML).
    '''
    def __init__(self, *args):
        CibObjectSet.__init__(self, *args)
        self.obj_list = cib_factory.mkobj_list("xml",*args)
    def repr(self):
        "Return a string containing xml of all objects."
        doc = cib_factory.objlist2doc(self.obj_list)
        s = doc.toprettyxml(user_prefs.xmlindent)
        doc.unlink()
        return s
    def process(self,node):
        obj = self.lookup(node.tagName,node.getAttribute("id"))
        if obj:
            if obj.update_from_node(node) != False:
                self.obj_list.remove(obj)
            else:
                return False
        else:
            return cib_factory.create_from_node(node)
    def save(self,s):
        try:
            doc = xml.dom.minidom.parseString(s)
        except xml.parsers.expat.ExpatError,msg:
            cib_parse_err(msg)
            return False
        sanitize_cib(doc)
        show_unrecognized_elems(doc)
        newnodes = get_interesting_nodes(doc,[])
        if newnodes:
            for node in processing_sort(newnodes):
                self.process(node)
        self.drop_remaining()
        doc.unlink()
        return True
    def verify(self):
        return pipe_string(cib_verify,self.repr())
    def ptest(self):
        ptest = "ptest -X -VV"
        if user_prefs.dotty:
            fd,tmpfile = mkstemp()
            ptest = "%s -D %s" % (ptest,tmpfile)
        else:
            tmpfile = None
        doc = cib_factory.objlist2doc(self.obj_list)
        cib = doc.childNodes[0]
        running_doc,running_cib = read_cib(cib_dump)
        if not running_doc:
            return
        status = get_conf_elem(running_doc, "status")
        if not status:
            common_err("the running cib contains no status")
            return
        cib.appendChild(doc.importNode(status,1))
        pipe_string(ptest,doc.toprettyxml())
        doc.unlink()
        if tmpfile:
            p = subprocess.Popen("%s %s" % (user_prefs.dotty,tmpfile), shell=True, bufsize=0, stdin=None, stdout=None, stderr=None, close_fds=True)
            common_info("starting %s to show transition graph"%user_prefs.dotty)
            tmpfiles.append(tmpfile)
        else:
            common_info("install graphviz to see a transition graph")

class CibObject(object):
    '''
    The top level object of the CIB. Resources and constraints.
    '''
    def __init__(self,xml_obj_type,obj_id = None):
        if not xml_obj_type in cib_object_map:
            unsupported_err(xml_obj_type)
            return
        self.obj_type = cib_object_map[xml_obj_type][0]
        self.parent_type = cib_object_map[xml_obj_type][2]
        self.xml_obj_type = xml_obj_type
        self.origin = "" # where did it originally come from?
        self.nocli = False # we don't support this one
        self.updated = False # was the object updated
        self.parent = None # object superior (group/clone/ms)
        self.children = [] # objects inferior
        if obj_id:
            if not self.mknode(obj_id):
                self = None # won't do :(
        else:
            self.obj_id = None
            self.node = None
    def repr_cli(self,node = None,format = True):
        '''
        CLI representation for the node. Defined in subclasses.
        '''
        return ''
    def cli2node(self,cli,oldnode = None):
        '''
        Convert CLI representation to a DOM node.
        Defined in subclasses.
        '''
        return None
    def save_xml(self,node):
        self.obj_id = node.getAttribute("id")
        self.node = node
        return self.cli_use_validate()
    def mknode(self,obj_id):
        if id_in_use(obj_id):
            return False
        if self.xml_obj_type in defaults_tags:
            tag = "meta_attributes"
        else:
            tag = self.xml_obj_type
        self.node = cib_factory.createElement(tag)
        self.obj_id = obj_id
        self.node.setAttribute("id",self.obj_id)
        self.origin = "user"
        return True
    def mkcopy(self):
        '''
        Create a new object with the same obj_id and obj_type
        (for the purpose of CibFactory.delete_objects)
        '''
        obj_copy = CibObject(self.xml_obj_type)
        obj_copy.obj_id = self.obj_id
        obj_copy.obj_type = self.obj_type
        return obj_copy
    def can_be_renamed(self):
        '''
        Return False if this object can't be renamed.
        '''
        if is_resource(self.node) and is_rsc_running(self.obj_id):
            common_err("cannot rename a running resource (%s)" % self.obj_id)
            return False
        if self.node.tagName == "node":
            common_err("cannot rename nodes")
            return False
        return True
    def attr_exists(self,attr):
        if not attr in self.node.attributes.keys():
            no_attribute_err(attr,self.obj_id)
            return False
        return True
    def cli_use_validate(self):
        '''
        Check validity of the object, as we know it. It may
        happen that we don't recognize a construct, but that the
        object is still valid for the CRM. In that case, the
        object is marked as "CLI read only", i.e. we will neither
        convert it to CLI nor try to edit it in that format.

        The validation procedure:
        we convert xml to cli and then back to xml. If the two
        xml representations match then we can understand the xml.
        '''
        if not self.node:
            return True
        if not self.attr_exists("id"):
            return False
        cli_text = self.repr_cli()
        if not cli_text:
            return False
        xml2 = self.cli2node(cli_text)
        if not xml2:
            return False
        rc = xml_cmp(self.node,xml2)
        xml2.unlink()
        return rc
    def matchcli(self,cli_list):
        head = cli_list[0]
        return self.obj_type == head[0] \
            and self.obj_id == find_value(head[1],"id")
    def match(self,xml_obj_type,obj_id):
        return self.xml_obj_type == xml_obj_type and self.obj_id == obj_id
    def obj_string(self):
        return "%s:%s" % (self.obj_type,self.obj_id)
    def set_updated(self):
        self.updated = False
        self.origin = 'cib'
        for child in self.children:
            child.set_updated()
    def propagate_updated(self):
        if self.parent:
            self.parent.updated = self.updated
            self.parent.propagate_updated()
    def update_links(self):
        '''
        Update the structure links for the object (self.children,
        self.parent). Update also the dom nodes, if necessary.
        '''
        self.children = []
        if self.obj_type not in container_tags:
            return
        for c in self.node.childNodes:
            if is_child_rsc(c):
                child = cib_factory.find_object_for_node(c)
                if not child:
                    missing_obj_err(c)
                    continue
                child.parent = self
                self.children.append(child)
                if not c.isSameNode(child.node):
                    child.node.parentNode.removeChild(child.node)
                    child.node.unlink()
                    child.node = c
    def update_from_cli(self,cli_list):
        'Update ourselves from the cli intermediate.'
        if not cib_factory.verify_cli(cli_list):
            return False
        oldnode = self.node
        id_store.remove_xml(oldnode)
        newnode = self.cli2node(cli_list)
        if not newnode:
            id_store.store_xml(oldnode)
            return True
        if xml_cmp(oldnode,newnode):
            newnode.unlink()
            return True # the new and the old versions are equal
        oldnode.parentNode.replaceChild(newnode,oldnode)
        self.node = newnode
        cib_factory.adjust_children(self,cli_list)
        oldnode.unlink()
        self.updated = True
        self.propagate_updated()
        return True
    def update_from_node(self,node):
        'Update ourselves from a doc node.'
        if not node:
            return False
        oldxml = self.node
        newxml = node
        if xml_cmp(oldxml,newxml):
            return True # the new and the old versions are equal
        if not id_store.replace_xml(oldxml,newxml):
            return False
        oldxml.unlink()
        self.node = cib_factory.doc.importNode(newxml,1)
        cib_factory.topnode[self.parent_type].appendChild(self.node)
        self.update_links()
        self.updated = True
        self.propagate_updated()
    def find_child_in_node(self,child):
        for c in self.node.childNodes:
            if not is_element(c):
                continue
            if c.tagName == child.obj_type and \
                    c.getAttribute("id") == child.obj_id:
                return c
        return None
    def filter(self,*args):
        "Filter objects."
        if not args:
            return True
        if args[0] == "NOOBJ":
            return False
        if args[0] == "changed":
            return self.updated or self.origin == "user"
        return self.obj_id in args

def mk_cli_list(cli):
    'Sometimes we get a string and sometimes a list.'
    if type(cli) == type('') or type(cli) == type(u''):
        return parse_cli(cli)
    else:
        return cli

class CibNode(CibObject):
    '''
    Node and node's attributes.
    '''
    default_type = "normal"
    node_attributes_keyw = "attributes"
    def repr_cli(self,node = None,format = True):
        '''
        We assume that uname is unique.
        '''
        if not node:
            node = self.node
        l = []
        l.append(node_head(node))
        for c in node.childNodes:
            if not is_element(c):
                continue
            if c.tagName == "instance_attributes":
                l.append("attributes %s" % cli_pairs(nvpairs2list(c)))
        return cli_format(l,format)
    def cli2node(self,cli,oldnode = None):
        cli_list = mk_cli_list(cli)
        if not cli_list:
            return None
        if not oldnode:
            oldnode = self.node
        head = copy.copy(cli_list[0])
        head[0] = backtrans[head[0]]
        obj_id = find_value(head[1],"$id")
        if not obj_id:
            obj_id = find_value(head[1],"uname")
        if not obj_id:
            return None
        type = find_value(head[1],"type")
        if not type:
            type = self.default_type
            head[1].append(["type",type])
        headnode = mkxmlsimple(head,cib_factory.topnode[cib_object_map[self.xml_obj_type][2]],'node')
        id_hint = headnode.getAttribute("id")
        for e in cli_list[1:]:
            n = mkxmlnode(e,oldnode,id_hint)
            headnode.appendChild(n)
        remove_id_used_attributes(cib_factory.topnode[cib_object_map[self.xml_obj_type][2]])
        return headnode

class CibPrimitive(CibObject):
    '''
    Primitives.
    '''
    def repr_cli(self,node = None,format = True):
        if not node:
            node = self.node
        l = []
        l.append(primitive_head(node))
        for c in node.childNodes:
            if not is_element(c):
                continue
            if c.tagName == "instance_attributes":
                l.append("params %s" % cli_pairs(nvpairs2list(c)))
            elif c.tagName == "meta_attributes":
                l.append("meta %s" % cli_pairs(nvpairs2list(c)))
            elif c.tagName == "operations":
                l.append(cli_operations(c,format))
        return cli_format(l,format)
    def cli2node(self,cli,oldnode = None):
        '''
        Convert a CLI description to DOM node.
        Try to preserve as many ids as possible in case there's
        an old XML version.
        '''
        cli_list = mk_cli_list(cli)
        if not cli_list:
            return None
        if not oldnode:
            oldnode = self.node
        head = copy.copy(cli_list[0])
        head[0] = backtrans[head[0]]
        headnode = mkxmlsimple(head,oldnode,'rsc')
        id_hint = headnode.getAttribute("id")
        operations = None
        for e in cli_list[1:]:
            n = mkxmlnode(e,oldnode,id_hint)
            if e[0] == "operations":
                operations = n
            if e[0] != "op":
                headnode.appendChild(n)
            else:
                if not operations:
                    operations = mkxmlnode(["operations",{}],oldnode,id_hint)
                    headnode.appendChild(operations)
                operations.appendChild(n)
        remove_id_used_attributes(oldnode)
        return headnode

class CibContainer(CibObject):
    '''
    Groups and clones and ms.
    '''
    def repr_cli(self,node = None,format = True):
        if not node:
            node = self.node
        l = []
        l.append(cont_head(node))
        for c in node.childNodes:
            if not is_element(c):
                continue
            if c.tagName == "instance_attributes":
                l.append("params %s" % cli_pairs(nvpairs2list(c)))
            elif c.tagName == "meta_attributes":
                l.append("meta %s" % cli_pairs(nvpairs2list(c)))
        return cli_format(l,format)
    def cli2node(self,cli,oldnode = None):
        cli_list = mk_cli_list(cli)
        if not cli_list:
            return None
        if not oldnode:
            oldnode = self.node
        head = copy.copy(cli_list[0])
        head[0] = backtrans[head[0]]
        headnode = mkxmlsimple(head,oldnode,'grp')
        id_hint = headnode.getAttribute("id")
        for e in cli_list[1:]:
            n = mkxmlnode(e,oldnode,id_hint)
            headnode.appendChild(n)
        v = find_value(head[1],"$children")
        if v:
            for child_id in v:
                obj = cib_factory.find_object(child_id)
                if obj:
                    n = obj.node.cloneNode(1)
                    headnode.appendChild(n)
                else:
                    no_object_err(child_id)
        remove_id_used_attributes(oldnode)
        return headnode

class CibLocation(CibObject):
    '''
    Location constraint.
    '''
    def repr_cli(self,node = None,format = True):
        if not node:
            node = self.node
        l = []
        l.append(location_head(node))
        for c in node.childNodes:
            if not is_element(c):
                continue
            if c.tagName == "rule":
                l.append("rule %s" % cli_rule(c))
        return cli_format(l,format)
    def cli2node(self,cli,oldnode = None):
        cli_list = mk_cli_list(cli)
        if not cli_list:
            return None
        if not oldnode:
            oldnode = self.node
        head = copy.copy(cli_list[0])
        head[0] = backtrans[head[0]]
        headnode = mkxmlsimple(head,oldnode,'location')
        id_hint = headnode.getAttribute("id")
        oldrule = None
        for e in cli_list[1:]:
            if e[0] == "expression":
                n = mkxmlnode(e,oldrule,id_hint)
            else:
                n = mkxmlnode(e,oldnode,id_hint)
            if e[0] == "rule":
                rule = n
                headnode.appendChild(n)
                oldrule = lookup_node(rule,oldnode,location_only=True)
            else:
                rule.appendChild(n)
        remove_id_used_attributes(oldnode)
        return headnode

class CibSimpleConstraint(CibObject):
    '''
    Colocation and order constraints.
    '''
    def repr_cli(self,node = None,format = True):
        if not node:
            node = self.node
        l = []
        l.append(simple_constraint_head(node))
        return cli_format(l,format)
    def cli2node(self,cli,oldnode = None):
        cli_list = mk_cli_list(cli)
        if not cli_list:
            return None
        if not oldnode:
            oldnode = self.node
        head = copy.copy(cli_list[0])
        head[0] = backtrans[head[0]]
        headnode = mkxmlsimple(head,oldnode,'')
        return headnode

class CibProperty(CibObject):
    '''
    Cluster properties.
    '''
    def repr_cli(self,node = None,format = True):
        if not node:
            node = self.node
        l = []
        l.append('%s $id="%s"' % (self.obj_type, node.getAttribute("id")))
        properties = nvpairs2list(node)
        for n,v in properties:
            l.append('%s="%s"' % (n,v))
        return cli_format(l,format)
    def cli2node(self,cli,oldnode = None):
        cli_list = mk_cli_list(cli)
        if not cli_list:
            return None
        if not oldnode:
            oldnode = cib_factory.topnode[cib_object_map[self.xml_obj_type][2]]
        head = copy.copy(cli_list[0])
        head[0] = backtrans[head[0]]
        obj_id = find_value(head[1],"$id")
        if not obj_id:
            obj_id = cib_object_map[self.xml_obj_type][3]
        headnode = mkxmlnode(head,oldnode,obj_id)
        remove_id_used_attributes(oldnode)
        return headnode
    def matchcli(self,cli_list):
        head = cli_list[0]
        return self.obj_type == head[0] \
            and self.obj_id == find_value(head[1],"$id")

# xml -> cli translations (and classes)
cib_object_map = {
    "node": ( "node", CibNode, "nodes" ),
    "primitive": ( "primitive", CibPrimitive, "resources" ),
    "group": ( "group", CibContainer, "resources" ),
    "clone": ( "clone", CibContainer, "resources" ),
    "master": ( "ms", CibContainer, "resources" ),
    "rsc_location": ( "location", CibLocation, "constraints" ),
    "rsc_colocation": ( "colocation", CibSimpleConstraint, "constraints" ),
    "rsc_order": ( "order", CibSimpleConstraint, "constraints" ),
    "cluster_property_set": ( "property", CibProperty, "crm_config", "cib-bootstrap-options" ),
    "rsc_defaults": ( "rsc_defaults", CibProperty, "rsc_defaults", "rsc-options" ),
    "op_defaults": ( "op_defaults", CibProperty, "op_defaults", "op-options" ),
}
backtrans = {}  # generate a translation cli -> tag
for key in cib_object_map:
    backtrans[cib_object_map[key][0]] = key
cib_topnodes = []  # get a list of parents
for key in cib_object_map:
    if not cib_object_map[key][2] in cib_topnodes:
        cib_topnodes.append(cib_object_map[key][2])

class CibFactory(object):
    '''
    Juggle with CIB objects.
    See check_structure below for details on the internal cib
    representation.
    '''
    def __init__(self):
        self.init_vars()
        self.all_committed = True # has commit produced error
        self.supported_cib_re = "^pacemaker-1[.]0$"
    #
    # check internal structures
    #
    def check_topnode(self,obj):
        if not obj.node.parentNode.isSameNode(self.topnode[obj.parent_type]):
            common_err("object %s is not linked to %s"%(obj.obj_id,obj.parent_type))
    def check_parent(self,obj,parent):
        if not obj in parent.children:
            common_err("object %s does not reference its child %s"%(parent.obj_id,obj.obj_id))
            return False
        if not parent.node.isSameNode(obj.node.parentNode):
            common_err("object %s node is not a child of its parent %s, but %s:%s"%(obj.obj_id,parent.obj_id,obj.node.tagName,obj.node.getAttribute("id")))
            return False
    def check_structure(self):
        #print "Checking structure..."
        rc = True
        for obj in self.cib_objects:
            #print "Checking %s... (%s)" % (obj.obj_id,obj.nocli)
            if obj.parent:
                if self.check_parent(obj,obj.parent) == False:
                    rc = False
            else:
                if self.check_topnode(obj) == False:
                    rc = False
            for child in obj.children:
                if self.check_parent(child,child.parent) == False:
                    rc = False
        return rc
    def createElement(self,tag):
        if self.doc:
            return self.doc.createElement(tag)
    def is_cib_supported(self,cib):
        'Do we support this CIB?'
        req = cib.getAttribute("crm_feature_set")
        validator = cib.getAttribute("validate-with")
        if validator and re.match(self.supported_cib_re,validator):
            return True
        cib_ver_unsupported_err(validator,req)
        return False
    def upgrade_cib_06to10(self,force = False):
        'Upgrade the CIB from 0.6 to 1.0.'
        if not self.doc:
            return False
        req = self.doc.getAttribute("crm_feature_set")
        validator = self.doc.getAttribute("validate-with")
        if force or not validator or re.match("0[.]6",validator):
            return ext_cmd(cib_upgrade)
    def import_cib(self):
        'Parse the current CIB (from cibadmin -Q).'
        curr_cib = read_cib(cib_dump)
        for elem in curr_cib: # all top elements are required
            if not elem:
                self.reset()
                return False
        self.doc = curr_cib[0]
        cib = curr_cib[1]
        if not self.is_cib_supported(cib):
            self.reset()
            return False
        for attr in cib.attributes.keys():
            self.cib_attrs[attr] = cib.getAttribute(attr)
        for t in cib_topnodes:
            self.topnode[t] = get_conf_elem(self.doc, t)
            if not self.topnode[t]:
                self.topnode[t] = mk_topnode(self.doc, t)
                self.missing_topnodes.append(t)
            if not self.topnode[t]:
                common_err("could not create %s node; out of memory?" % t)
                self.reset()
                return False
        return True
    #
    # create a doc from the list of objects
    # (used by CibObjectSetRaw)
    #
    def set_cib_attributes(self,cib):
        for attr in self.cib_attrs:
            cib.setAttribute(attr,self.cib_attrs[attr])
    def objlist2doc(self,obj_list,obj_filter = None):
        '''
        Return document containing objects in obj_list.
        Must remove all children from the object list, because
        printing xml of parents will include them.
        Optional filter to sieve objects.
        '''
        doc,cib,crm_config,rsc_defaults,op_defaults,nodes,resources,constraints = new_cib()
        for obj in [obj for obj in obj_list if not obj.parent]:
            if obj_filter and not obj_filter(obj):
                continue
            i_node = doc.importNode(obj.node,1)
            if obj.parent_type == "nodes":
                nodes.appendChild(i_node)
            elif obj.parent_type == "resources":
                resources.appendChild(i_node)
            elif obj.parent_type == "constraints":
                constraints.appendChild(i_node)
            elif obj.parent_type == "crm_config":
                crm_config.appendChild(i_node)
            elif obj.parent_type == "rsc_defaults":
                rsc_defaults.appendChild(i_node)
            elif obj.parent_type == "op_defaults":
                op_defaults.appendChild(i_node)
        self.set_cib_attributes(cib)
        return doc
    #
    # commit changed objects to the CIB
    #
    def attr_match(self,c,a):
        'Does attribute match?'
        try: cib_attr = self.cib_attrs[a]
        except: cib_attr = None
        return c.getAttribute(a) == cib_attr
    def add_missing_topnodes(self):
        cib_create_topnode = "cibadmin -C -o configuration -X"
        for tag in self.missing_topnodes:
            if not self.topnode[tag].hasChildNodes():
                continue
            if not ext_cmd("%s '<%s/>'" % (cib_create_topnode, tag)):
                common_error("could not create %s in the cib" % tag)
                return False
        return True
    def commit(self,force = False):
        'Commit the configuration to the CIB.'
        # 0. ensure that cib didn't change in the meantime
        if not force and not self.overwrite:
            curr_cib = read_cib(cib_dump)
            doc = curr_cib[0]
            if not doc:
                return False
            cib = curr_cib[1]
            if not cib:
                doc.unlink()
                return False
            if not self.attr_match(cib,'epoch') or \
                    not self.attr_match(cib,'admin_epoch'):
                common_warn("CIB changed in the meantime: won't touch it!")
                common_info("use 'commit force' to force the changes.")
                doc.unlink()
                return False
            doc.unlink()
        if not self.add_missing_topnodes():
            return False
        self.all_committed = True
        cnt = 0
        # 1. remove objects
        cnt += self.delete_objects()
        # 2. create objects
        cnt += self.commit_objects(lambda o: o.origin == 'user','-C')
        # 3. replace objects
        cnt += self.commit_objects(lambda o: o.origin != 'user' and o.updated,'-R')
        if cnt:
            # reload the cib!
            self.reset()
            self.initialize()
        return self.all_committed
    def delete_objects(self):
        cnt = 0
        if not self.remove_queue:
            return 0
        obj_list = processing_sort_cli(self.remove_queue)
        for obj in reversed(obj_list):
            node = self.createElement(obj.xml_obj_type)
            node.setAttribute("id",obj.obj_id)
            #print node.toprettyxml()
            rc = pipe_string("%s -D"%cib_piped,node.toxml())
            if not rc:
                self.remove_queue.remove(obj)
                cnt += 1
            else:
                update_err(obj.obj_id,'-D',node)
                self.all_committed = False
            node.unlink()
        return cnt
    def commit_objects(self,obj_filter,cibadm_opt):
        upd_list = []
        for obj in self.cib_objects:
            if not obj_filter or obj_filter(obj):
                if not obj.parent and not obj in upd_list: # only top children!
                    upd_list.append(obj)
        cnt = 0
        if not upd_list:
            return 0
        for obj in processing_sort_cli(upd_list):
            #print obj.node.toprettyxml()
            rc = pipe_string("%s %s -o %s" % \
                (cib_piped,cibadm_opt,obj.parent_type),obj.node.toxml())
            if not rc:
                cnt += 1
                obj.set_updated()
            else:
                update_err(obj.obj_id,cibadm_opt,obj.node)
                self.all_committed = False
        return cnt
    #
    # initialize cib_objects from CIB
    #
    def save_node(self,node,pnode = None):
        if not pnode:
            pnode = node
        obj = cib_object_map[pnode.tagName][1](pnode.tagName)
        obj.origin = "cib"
        self.cib_objects.append(obj)
        if not obj.save_xml(node):
            obj.nocli = True
    def populate(self):
        "Walk the cib and collect cib objects."
        all_nodes = get_interesting_nodes(self.doc,[])
        if not all_nodes:
            return
        for node in processing_sort(all_nodes):
            if is_defaults(node):
                for c in node.childNodes:
                    if not is_element(c) or c.tagName != "meta_attributes":
                        continue
                    self.save_node(c,node)
            else:
                self.save_node(node)
        for obj in self.cib_objects:
            obj.update_links()
    def initialize(self):
        if self.doc:
            return True
        if not self.import_cib():
            common_err("bad cib")
            return False
        sanitize_cib(self.doc)
        show_unrecognized_elems(self.doc)
        self.populate()
        return self.check_structure()
    def init_vars(self):
        self.doc = None  # the cib
        self.topnode = {}
        for t in cib_topnodes:
            self.topnode[t] = None
        self.missing_topnodes = []
        self.cib_attrs = {} # cib version dictionary
        self.cib_objects = [] # a list of cib objects
        self.remove_queue = [] # a list of cib objects to be removed
        self.overwrite = False # update cib unconditionally
    def reset(self):
        if not self.doc:
            return
        self.doc.unlink()
        self.init_vars()
        id_store.clear()
    def find_object(self,obj_id):
        "Find an object for id."
        for obj in self.cib_objects:
            if obj.obj_id == obj_id:
                return obj
        return None
    #
    # tab completion functions
    #
    def id_list(self):
        "List of ids (for completion)."
        return [x.obj_id for x in self.cib_objects]
    def prim_id_list(self):
        "List of primitives ids (for group completion)."
        return [x.obj_id for x in self.cib_objects if x.obj_type == "primitive"]
    def children_id_list(self):
        "List of child ids (for clone/master completion)."
        return [x.obj_id for x in self.cib_objects if x.obj_type in children_tags]
    def rsc_id_list(self):
        "List of resource ids (for constraint completion)."
        return [x.obj_id for x in self.cib_objects \
            if x.obj_type in resource_tags and not x.parent]
    def f_prim_id_list(self):
        "List of possible primitives ids (for group completion)."
        return [x.obj_id for x in self.cib_objects \
            if x.obj_type == "primitive" and not x.parent]
    def f_children_id_list(self):
        "List of possible child ids (for clone/master completion)."
        return [x.obj_id for x in self.cib_objects \
            if x.obj_type in children_tags and not x.parent]
    #
    # a few helper functions
    #
    def find_object_for_node(self,node):
        "Find an object which matches a dom node."
        for obj in self.cib_objects:
            if node.getAttribute("id") == obj.obj_id:
                return obj
        return None
    def resolve_id_ref(self,attr_list_type,id_ref):
        '''
        User is allowed to specify id_ref either as a an object
        id or as attributes id. Here we try to figure out which
        one, i.e. if the former is the case to find the right
        id to reference.
        '''
        obj= self.find_object(id_ref)
        if obj:
            node_l = obj.node.getElementsByTagName(attr_list_type)
            if node_l:
                if len(node_l) > 1:
                    common_warn("%s contains more than one %s, using first" % \
                        (obj.obj_id,attr_list_type))
                id = node_l[0].getAttribute("id")
                if not id:
                    common_err("%s reference not found" % id_ref)
                    return id_ref # hope that user will fix that
                return id
        # verify if id_ref exists
        node_l = self.doc.getElementsByTagName(attr_list_type)
        for node in node_l:
            if node.getAttribute("id") == id_ref:
                return id_ref
        common_err("%s reference not found" % id_ref)
        return id_ref # hope that user will fix that
    def new_object(self,obj_type,obj_id):
        "Create a new object of type obj_type."
        if id_in_use(obj_id):
            return None
        for xml_obj_type,v in cib_object_map.items():
            if v[0] == obj_type:
                obj = v[1](xml_obj_type,obj_id)
                if obj.obj_id:
                    return obj
                else:
                    return None
        return None
    def mkobj_list(self,mode,*args):
        obj_list = []
        for obj in self.cib_objects:
            f = lambda: obj.filter(*args)
            if not f():
                continue
            if mode == "cli" and obj.nocli:
                obj_cli_err(obj.obj_id)
                continue
            obj_list.append(obj)
        return obj_list
    def has_cib_changed(self):
        return self.mkobj_list("xml","changed") or self.remove_queue
    def verify_constraints(self,cli_list):
        '''
        Check if all resources referenced in a constraint exist
        '''
        rc = True
        head = cli_list[0]
        constraint_id = find_value(head[1],"id")
        for obj_id in referenced_resources_cli(cli_list):
            if not self.find_object(obj_id):
                constraint_norefobj_err(constraint_id,obj_id)
                rc = False
        return rc
    def verify_children(self,cli_list):
        '''
        Check prerequisites:
          a) all children must exist
          b) no child may have other parent than me
          (or should we steal children?)
        '''
        head = cli_list[0]
        obj_type = head[0]
        obj_id = find_value(head[1],"id")
        c_ids = find_value(head[1],"$children")
        if not c_ids:
            return True
        for child_id in c_ids:
            if not self.verify_child(child_id,obj_type,obj_id):
                return False
        return True
    def verify_child(self,child_id,obj_type,obj_id):
        'Check if child exists and obj_id is (or may become) its parent.'
        child = self.find_object(child_id)
        if not child:
            no_object_err(child_id)
            return False
        if child.parent and child.parent.obj_id != obj_id:
            common_err("%s already in use at %s"%(child_id,child.parent.obj_id))
            return False
        if obj_type == "group" and child.obj_type != "primitive":
            common_err("a group may contain only primitives; %s is %s"%(child_id,child.obj_type))
            return False
        if not child.obj_type in children_tags:
            common_err("%s may contain a primitive or a group; %s is %s"%(obj_type,child_id,child.obj_type))
            return False
        return True
    def verify_cli(self,cli_list):
        '''
        Can we create this object given its CLI representation.
        This is not about syntax, we're past that, but about
        semantics.
        Right now we check if the children, if any, are fit for
        the parent. And if this is a constraint, if all
        referenced resources are present.
        '''
        rc = True
        if not self.verify_children(cli_list):
            rc = False
        if not self.verify_constraints(cli_list):
            rc = False
        return rc
    def create_object(self,*args):
        return self.create_from_cli(parse_cli(args))
    def set_property_cli(self,cli_list):
        head_pl = cli_list[0]
        obj_type = head_pl[0]
        pset_id = find_value(head_pl[1],"$id")
        if pset_id:
            head_pl[1].remove(["$id",pset_id])
        else:
            pset_id = cib_object_map[backtrans[obj_type]][3]
        obj = self.find_object(pset_id)
        if not obj:
            if not is_id_valid(pset_id):
                invalid_id_err(pset_id)
                return False
            obj = self.new_object(obj_type,pset_id)
            if not obj:
                return False
            self.topnode[obj.parent_type].appendChild(obj.node)
            obj.origin = "user"
            self.cib_objects.append(obj)
        for n,v in head_pl[1]:
            set_nvpair(obj.node,n,v)
        obj.updated = True
    def add_op(self,cli_list):
        '''Add an op to a primitive.'''
        head = cli_list[0]
        # does the referenced primitive exist
        rsc_id = find_value(head[1],"rsc")
        rsc_obj = cib_factory.find_object(rsc_id)
        if not rsc_obj:
            no_object_err(rsc_id)
            return False
        if rsc_obj.obj_type != "primitive":
            common_err("%s is not a primitive" % rsc_id)
            return False
        # check if there is already an op with the same interval
        name = find_value(head[1], "name")
        interval = find_value(head[1], "interval")
        if find_operation(rsc_obj.node,name,interval):
            common_err("%s already has a %s op with interval %s" % \
                (rsc_id, name, interval))
            return False
        # drop the rsc attribute
        head[1].remove(["rsc",rsc_id])
        # create an xml node
        mon_node = mkxmlsimple(head, None, rsc_id)
        # get the place to append it to
        try:
            op_node = rsc_obj.node.getElementsByTagName("operations")[0]
        except:
            op_node = self.createElement("operations")
            rsc_obj.node.appendChild(op_node)
        op_node.appendChild(mon_node)
        # the resource is updated
        rsc_obj.updated = True
        rsc_obj.propagate_updated()
    def create_from_cli(self,cli):
        'Create a new cib object from the cli representation.'
        cli_list = mk_cli_list(cli)
        if not cli_list:
            return False
        if not self.verify_cli(cli_list):
            return False
        head = cli_list[0]
        obj_type = head[0]
        if obj_type == "property" or obj_type in defaults_tags:
            return self.set_property_cli(cli_list)
        if obj_type == "op":
            return self.add_op(cli_list)
        obj_id = find_value(head[1],"id")
        if not is_id_valid(obj_id):
            invalid_id_err(obj_id)
            return False
        obj = self.new_object(obj_type,obj_id)
        if not obj:
            return False
        obj.node = obj.cli2node(cli_list)
        self.topnode[obj.parent_type].appendChild(obj.node)
        self.adjust_children(obj,cli_list)
        obj.origin = "user"
        for child in obj.children:
            # redirect constraints to the new parent
            for c_obj in self.related_constraints(child):
                rename_rscref(c_obj.node,child.obj_id,obj.obj_id)
                c_obj.updated = True
            # children (if any) have to be removed
            # in case they originated from the CIB!
            self.add_to_remove_queue(child)
        # drop useless constraints which may have been created above
        for c_obj in self.related_constraints(obj):
            if silly_constraint(c_obj.node,obj.obj_id):
                self._remove_obj(c_obj)
        self.cib_objects.append(obj)
    def adjust_children(self,obj,cli_list):
        '''
        All stuff children related: manage the nodes of children,
        update the list of children for the parent, update
        parents in the children.
        '''
        head = cli_list[0]
        children_ids = find_value(head[1],"$children")
        if not children_ids:
            return
        new_children = []
        for child_id in children_ids:
            new_children.append(self.find_object(child_id))
        self._relink_orphans(obj,new_children)
        obj.children = new_children
        self._update_children(obj)
    def _relink_child(self,obj):
        'Relink a child to the top node.'
        obj.node.parentNode.removeChild(obj.node)
        self.topnode[obj.parent_type].appendChild(obj.node)
        obj.parent = None
        obj.origin = "user" # it has to be created!
    def _update_children(self,obj):
        '''For composite objects: update all children nodes.
        '''
        # unlink all and find them in the new node
        for child in obj.children:
            oldnode = child.node
            child.node = obj.find_child_in_node(child)
            if child.children: # and children of children
                self._update_children(child)
            oldnode.parentNode.removeChild(oldnode)
            oldnode.unlink()
            child.parent = obj
    def _relink_orphans(self,obj,new_children):
        "New orphans move to the top level for the object type."
        for child in obj.children:
            if child not in new_children:
                self._relink_child(child)
    def create_from_node(self,node):
        'Create a new cib object from a document node.'
        if not node:
            return True
        obj = self.new_object(node.tagName,node.getAttribute("id"))
        if not obj:
            return False
        node = self.doc.importNode(node,1)
        self.topnode[obj.parent_type].appendChild(node)
        if not obj.save_xml(node):
            obj.nocli = True
        obj.update_links()
        obj.origin = "user"
        self.cib_objects.append(obj)
    def cib_objects_string(self, obj_list = None):
        l = []
        if not obj_list:
            obj_list = self.cib_objects
        for obj in obj_list:
            l.append(obj.obj_string())
        return ' '.join(l)
    def _remove_obj(self,obj):
        "Remove a cib object and its children."
        # remove children first
        # can't remove them here from obj.children!
        for child in obj.children:
            #self._remove_obj(child)
            # just relink, don't remove children
            self._relink_child(child)
        if obj.parent: # remove obj from its parent, if any
            obj.parent.children.remove(obj)
        id_store.remove_xml(obj.node)
        obj.node.parentNode.removeChild(obj.node)
        obj.node.unlink()
        self.add_to_remove_queue(obj)
        self.cib_objects.remove(obj)
        for constraint in self.related_constraints(obj):
            self._remove_obj(constraint)
    def related_constraints(self,obj):
        if not is_resource(obj.node):
            return []
        c_list = []
        for obj2 in self.cib_objects:
            if not is_constraint(obj2.node):
                continue
            if rsc_constraint(obj.obj_id,obj2.node):
                c_list.append(obj2)
        return c_list
    def add_to_remove_queue(self,obj):
        if obj.origin == "cib":
            self.remove_queue.append(obj)
        #print self.cib_objects_string(self.remove_queue)
    def delete_1(self,obj):
        '''
        Remove an object and its parent in case the object is the
        only child.
        '''
        if obj.parent and len(obj.parent.children) == 1:
            self.delete_1(obj.parent)
        if obj in self.cib_objects: # don't remove parents twice
            self._remove_obj(obj)
    def delete(self,*args):
        'Delete a cib object.'
        rc = True
        l = []
        for obj_id in args:
            obj = self.find_object(obj_id)
            if not obj:
                no_object_err(obj_id)
                rc = False
                continue
            if is_rsc_running(obj_id):
                common_warn("resource %s is running, can't delete it" % obj_id)
            else:
                l.append(obj)
        if l:
            l = processing_sort_cli(l)
            for obj in reversed(l):
                self.delete_1(obj)
        return rc
    def remove_on_rename(self,obj):
        '''
        If the renamed object is coming from the cib, then it
        must be removed and a new one created.
        '''
        if obj.origin == "cib":
            self.remove_queue.append(obj.mkcopy())
            obj.origin = "user"
    def rename(self,old_id,new_id):
        '''
        Rename a cib object.
        - check if the resource (if it's a resource) is stopped
        - check if the new id is not taken
        - find the object with old id
        - rename old id to new id in all related objects
          (constraints)
        - if the object came from the CIB, then it must be
          deleted and the one with the new name created
        - rename old id to new id in the object
        '''
        if id_in_use(new_id):
            return False
        obj = self.find_object(old_id)
        if not obj:
            no_object_err(old_id)
            return False
        if not obj.can_be_renamed():
            return False
        for c_obj in self.related_constraints(obj):
            rename_rscref(c_obj.node,old_id,new_id)
            c_obj.updated = True
        self.remove_on_rename(obj)
        rename_id(obj.node,old_id,new_id)
        obj.obj_id = new_id
        id_store.rename(old_id,new_id)
        obj.updated = True
        obj.propagate_updated()
    def erase(self):
        "Remove all cib objects."
        # remove only bottom objects and no constraints
        # the rest will automatically follow
        erase_ok = True
        l = []
        for obj in [obj for obj in self.cib_objects \
                if not obj.children and not is_constraint(obj.node)]:
            if is_rsc_running(obj.obj_id):
                common_warn("resource %s is running, can't delete it" % obj.obj_id)
                erase_ok = False
            else:
                l.append(obj)
        if not erase_ok:
            common_err("CIB erase aborted (nothing was deleted)")
            return False
        for obj in l:
            self.delete(obj.obj_id)
        if self.cib_objects:
            common_err("strange, but these objects remained:")
            for obj in self.cib_objects:
                print obj.obj_string()
            self.cib_objects = []
        return True
    def refresh(self):
        "Refresh from the CIB."
        self.reset()
        self.initialize()

class TopLevel(object):
    '''
    The top level.
    '''
    help_table = odict()
    help_table["."] = ("","""This is the CRM command line interface program.""")
    help_table["cib"] = ("manage shadow CIBs", """
A shadow CIB is a regular cluster configuration which is kept in
a file. The CRM and the CRM tools may manage a shadow CIB in the
same way as the live CIB (i.e. the current cluster configuration).
A shadow CIB may be applied to the cluster in one step.
""")
    help_table["resource"] = ("resources management", """
Everything related to resources management is available at this
level. Most commands are implemented using the crm_resource(8)
program.
""")
    help_table["node"] = ("nodes management", """
A few node related tasks such as node standby are implemented
here.
""")
    help_table["options"] = ("user preferences", """
Several user preferences are available. Note that it is possible
to save the preferences to a startup file.
""")
    help_table["configure"] = ("CRM cluster configuration", """
The configuration level.

Note that you can change the working CIB at the cib level. It is
advisable to configure shadow CIBs and then commit them to the
cluster.
""")
    help_table["quit"] = ("exit the program", "")
    help_table["help"] = ("show help", "")
    help_table["end"] = ("go back one level", "")
    cmd_aliases = global_aliases
    def __init__(self):
        self.cmd_table = {
            'cib': CibShadow,
            'resource': RscMgmt,
            'configure': CibConfig,
            'node': NodeMgmt,
            'options': CliOptions,
            'status': (self.status,(0,0),0),
            'ra': RA,
            'quit': (cmd_exit,(0,0),0),
            'help': (self.help,(0,1),0),
            'end': (cmd_end,(0,1),0),
        }
        setup_aliases(self)
    def help(self,cmd,topic = ''):
        cmd_help(self.help_table,topic)
    def status(self,cmd):
        return ext_cmd("crm_mon -1")

class CompletionHelp(object):
    '''
    Print some help on whatever last word in the line.
    '''
    timeout = 60  # don't print again and again
    def __init__(self):
        self.laststamp = 0
        self.lastitem = ''
    def help(self,f,*args):
        words = readline.get_line_buffer().split()
        if not words:
            return
        key = words[-1]
        if key.endswith('='):
            key = key[0:-1]
        if self.lastitem == key and \
                time.time() - self.laststamp < self.timeout:
            return
        help_s = f(key,*args)
        if help_s:
            print "\n%s" % help_s
            print "%s%s" % (prompt,readline.get_line_buffer()),
            self.laststamp = time.time()
            self.lastitem = key

def attr_cmds(idx,delimiter = False):
    if delimiter:
        return ' '
    return ["delete","set","show"]
def listnodes():
    if wcache.is_cached("listnodes"):
        return wcache.retrieve("listnodes")
    nodes = []
    doc = xml2doc("%s -o nodes"%cib_dump)
    if not doc:
        return []
    nodes_node = get_conf_elem(doc, "nodes")
    if not nodes_node:
        return []
    for c in nodes_node.childNodes:
        if not is_element(c):
            continue
        if c.tagName != "node":
            continue
        if c.getAttribute("type") == 'normal':
            nodes.append(c.getAttribute("uname"))
    return wcache.store("property_list",nodes)
def nodes_list(idx,delimiter = False):
    if delimiter:
        return ' '
    return listnodes()
def shadows_list(idx,delimiter = False):
    if delimiter:
        return ' '
    return listshadows()
def shadows_live_list(idx,delimiter = False):
    if delimiter:
        return ' '
    return listshadows() + ['live']
def rsc_list(idx,delimiter = False):
    if delimiter:
        return ' '
    doc = resources_xml()
    if not doc:
        return []
    nodes = get_interesting_nodes(doc,[])
    return [x.getAttribute("id") for x in nodes if is_resource(x)]
def null_list(idx,delimiter = False):
    if delimiter:
        return ' '
    return []
def loop(idx,delimiter = False):
    "just a marker in a list"
    pass
def id_xml_list(idx,delimiter = False):
    if delimiter:
        return ' '
    return cib_factory.id_list() + ['xml','changed']
def id_list(idx,delimiter = False):
    if delimiter:
        return ' '
    return cib_factory.id_list()
def f_prim_id_list(idx,delimiter = False):
    if delimiter:
        return ' '
    return cib_factory.f_prim_id_list()
def f_children_id_list(idx,delimiter = False):
    if delimiter:
        return ' '
    return cib_factory.f_children_id_list()
def rsc_id_list(idx,delimiter = False):
    if delimiter:
        return ' '
    return cib_factory.rsc_id_list()
def skills_list(idx,delimiter = False):
    if delimiter:
        return ' '
    return CliOptions.skill_levels.keys()
def ra_classes_list(idx,delimiter = False):
    if delimiter:
        return ':'
    return ra_classes()
def get_primitive_type(words):
    try:
        idx = words.index("primitive") + 2
        type_word = words[idx]
    except: type_word = ''
    return type_word
def ra_type_list(toks,idx,delimiter):
    if idx == 2:
        if toks[0] == "ocf":
            dchar = ':'
            l = ra_providers_all()
        else:
            dchar = ' '
            l = ra_types(toks[0])
    elif idx == 3:
        dchar = ' '
        if toks[0] == "ocf":
            l = ra_types(toks[0],toks[1])
        else:
            l = ra_types(toks[0])
    if delimiter:
        return dchar
    return l
def prim_meta_attr_list():
    return [\
        "globally-unique", \
        "is-managed", \
        "migration-threshold", \
        "priority", \
        "multiple-active", \
        "failure-timeout", \
        "resource-stickiness", \
        "target-role", \
        ]
def op_attr_list():
    return [\
        "interval", \
        "requires", \
        "timeout", \
        "enabled", \
        "record-pending", \
        "role", \
        "on-fail", \
        ]
def operations_list():
    return ["start","stop","monitor"]
def prim_complete_meta(ra,delimiter):
    if delimiter:
        return '='
    return prim_meta_attr_list()
def prim_complete_op(ra,delimiter):
    words = split_buffer()
    if (readline.get_line_buffer()[-1] == ' ' and words[-1] == "op") \
            or (readline.get_line_buffer()[-1] != ' ' and words[-2] == "op"):
        dchar = ' '
        l = operations_list()
    else:
        if readline.get_line_buffer()[-1] == '=':
            dchar = ' '
            l = []
        else:
            dchar = '='
            l = op_attr_list()
    if delimiter:
        return dchar
    return l
def prim_complete_params(ra,delimiter):
    if readline.get_line_buffer()[-1] == '=':
        dchar = ' '
        l = []
    else:
        dchar = '='
        l = ra.params().keys()
    if delimiter:
        return dchar
    return l
def prim_params_info(key,ra):
    return ra.meta_parameter(key)
def meta_attr_info(key,ra):
    pass
def op_attr_info(key,ra):
    pass
def get_lastkeyw(words,keyw):
    revwords = copy.copy(words)
    revwords.reverse()
    for w in revwords:
        if w in keyw:
            return w
def primitive_complete_complex(idx,delimiter = False):
    '''
    This completer depends on the content of the line, i.e. on
    previous tokens, in particular on the type of the RA.
    '''
    completers_set = {
        "params": (prim_complete_params, prim_params_info),
        "meta": (prim_complete_meta, meta_attr_info),
        "op": (prim_complete_op, op_attr_info),
    }
    # manage the resource type
    words = readline.get_line_buffer().split()
    type_word = get_primitive_type(words)
    toks = type_word.split(':')
    if toks[0] != "ocf":
        idx += 1
    if idx in (2,3):
        return ra_type_list(toks,idx,delimiter)
    # create an ra object
    ra = None
    ra_class,provider,rsc_type = disambiguate_ra_type(type_word)
    if ra_type_validate(type_word,ra_class,provider,rsc_type):
        ra = RAInfo(ra_class,rsc_type,provider)
    keywords = completers_set.keys()
    if idx == 4:
        if delimiter:
            return ' '
        return keywords
    lastkeyw = get_lastkeyw(words,keywords)
    if '=' in words[-1] and readline.get_line_buffer()[-1] != ' ':
        if not delimiter and lastkeyw and \
                readline.get_line_buffer()[-1] == '=' and len(words[-1]) > 1:
            compl_help.help(completers_set[lastkeyw][1],ra)
        if delimiter:
            return ' '
        return ['*']
    else:
        if lastkeyw:
            return completers_set[lastkeyw][0](ra,delimiter)
def property_complete(idx,delimiter = False):
    '''
    This completer depends on the content of the line, i.e. on
    previous tokens, in particular on the type of the RA.
    '''
    words = readline.get_line_buffer().split()
    ra = RAInfo("pengine","metadata")
    if '=' in words[-1] and readline.get_line_buffer()[-1] != ' ':
        if not delimiter and \
                readline.get_line_buffer()[-1] == '=' and len(words[-1]) > 1:
            compl_help.help(prim_params_info,ra)
        if delimiter:
            return ' '
        return ['*']
    else:
        return prim_complete_params(ra,delimiter)

def topics_dict(help_tab):
    topics = {}
    for topic in help_tab:
        if topic != '.':
            topics[topic] = None
    return topics

def mk_completion_tab(cmd_class,ctab):
    obj = cmd_class()
    cmd_table = obj.cmd_table
    for key,value in cmd_table.items():
        if key.startswith("_"):
            continue
        if type(value) == type(object):
            ctab[key] = {}
            mk_completion_tab(value,ctab[key])
        elif key == "help":
            ctab[key] = topics_dict(obj.help_table)
        else:
            ctab[key] = None
            try: ctab[key] = value[3]
            except: pass
def lookup_dynamic(fun_list,idx,f_idx,words):
    if not fun_list:
        return []
    if fun_list[f_idx] == loop:
        f_idx -= 1
    f = fun_list[f_idx]
    w = words[0]
    wordlist = f(idx)
    delimiter = f(idx,1)
    if len(wordlist) == 1 and wordlist[0] == '*':
        return lookup_dynamic(fun_list,idx+1,f_idx+1,words[1:])
    elif len(words) == 1:
        return [x+delimiter for x in wordlist if x.startswith(w)]
    return lookup_dynamic(fun_list,idx+1,f_idx+1,words[1:])
def lookup_words(ctab,words):
    if not ctab:
        return []
    if type(ctab) == type(()):
        return lookup_dynamic(ctab,0,0,words)
    if len(words) == 1:
        return [x+' ' for x in ctab if x.startswith(words[0])]
    elif words[0] in ctab.keys():
        return lookup_words(ctab[words[0]],words[1:])
    return []
def split_buffer():
    p = readline.get_line_buffer()
    p = p.replace(':',' ').replace('=',' ')
    return p.split()
def completer(txt,state):
    words = split_buffer()
    if readline.get_begidx() == readline.get_endidx():
        words.append('')
    matched = lookup_words(levels.completion_tab,words)
    matched.append(None)
    return matched[state]

wcache = WCache()
err_buf = ErrorBuffer()
user_prefs = UserPrefs()
id_store = IdMgmt()
cib_factory = CibFactory()
tmpfiles = []

def load_rc(rcfile):
    try: f = open(rcfile)
    except: return
    save_stdin = sys.stdin
    sys.stdin = f
    while True:
        inp = multi_input()
        if inp == None:
            break
        try: parse_line(levels,shlex.split(inp))
        except ValueError, msg:
            common_err(msg)
    f.close()
    sys.stdin = save_stdin

def multi_input(prompt = ''):
    """
    Get input from user
    Allow multiple lines using a continuation character
    """
    global lineno
    line = []
    while True:
        try:
            text = raw_input(prompt)
        except EOFError:
            return None
        if lineno >= 0:
            lineno += 1
        stripped = text.strip()
        if stripped.endswith('\\'):
            stripped = stripped.rstrip('\\')
            line.append(stripped)
            if prompt:
                prompt = '> '
        else:
            line.append(stripped)
            break
    return ''.join(line)

class Levels(object):
    '''
    Keep track of levels and prompts.
    '''
    def __init__(self,start_level):
        self._marker = 0
        self._in_transit = False
        self.level_stack = []
        self.comp_stack = []
        self.current_level = start_level()
        self.parse_root = self.current_level.cmd_table
        self.prompts = []
        self.completion_tab = {}
        mk_completion_tab(start_level,self.completion_tab)
    def getprompt(self):
        return ' '.join(self.prompts)
    def mark(self):
        self._marker = len(self.level_stack)
        self._in_transit = False
    def release(self):
        while len(self.level_stack) > self._marker:
            self.droplevel()
    def new_level(self,level_obj,token):
        self.level_stack.append(self.current_level)
        self.comp_stack.append(self.completion_tab)
        self.prompts.append(token)
        self.current_level = level_obj()
        self.parse_root = self.current_level.cmd_table
        self.completion_tab = self.completion_tab[token]
        self._in_transit = True
    def droplevel(self):
        if self.level_stack:
            try: self.current_level.end_game(self._in_transit)
            except: pass
            self.current_level = self.level_stack.pop()
            self.completion_tab = self.comp_stack.pop()
            self.parse_root = self.current_level.cmd_table
            self.prompts.pop()

def check_args(args,argsdim):
    if not argsdim: return True
    if len(argsdim) == 1:
        minargs = argsdim[0]
        return len(args) >= minargs
    else:
        minargs,maxargs = argsdim
        return len(args) >= minargs and len(args) <= maxargs

#
# Note on parsing
#
# Parsing tables are python dictionaries.
#
# Keywords are used as keys and the corresponding values are
# lists (actually tuples, since they should be read-only) or
# classes. In the former case, the keyword is a terminal and
# in the latter, a new object for the class is created. The class
# must have the cmd_table variable.
#
# The list has the following content:
#
# function: a function to handle this command
# numargs_list: number of minimum/maximum arguments; for example,
#   (0,1) means one optional argument, (1,1) one required; if the
#   list is empty then the function will parse arguments itself
# required minimum skill level: operator, administrator, expert
#   (encoded as a small integer from 0 to 2)
# 

def show_usage(cmd):
    p = None
    try: p = cmd.__doc__
    except: pass
    if p:
        print p
    else:
        syntax_err(cmd.__name__)

def parse_line(lvl,s):
    if not s: return True
    if s[0].startswith('#'): return True
    lvl.mark()
    pt = lvl.parse_root
    cmd = None
    i = 0
    for i in range(len(s)):
        token = s[i]
        if token in pt:
            if type(pt[token]) == type(object):
                lvl.new_level(pt[token],token)
                pt = lvl.parse_root # move to the next level
            else:
                cmd = pt[token] # terminal symbol
                break  # and stop parsing
        else:
            syntax_err(s[i:])
            lvl.release()
            return False
    if cmd: # found a terminal symbol
        if not user_prefs.check_skill_level(cmd[2]):
            lvl.release()
            skill_err(s[i])
            return False
        args = s[i+1:]
        if not check_args(args,cmd[1]):
            lvl.release()
            show_usage(cmd[0])
            return False
        args = s[i:]
        d = lambda: cmd[0](*args)
        rv = d() # execute the command
        lvl.release()
        return rv != False

# three modes: interactive (no args supplied), batch (input from
# a file), half-interactive (args supplied, but not batch)
interactive = True
batch = False
inp_file = ''
prompt = ''
cib_in_use = os.getenv(CibShadow().envvar)
def cib_prompt():
    return cib_in_use or "live"

def usage():
    print """
usage:
    crm
    crm args
    crm [-f file]

    Use crm without arguments for an interactive session.
    Supply one or more arguments for a "single-shot" use.
    Specify with -f a file which contains a script. Use '-' for
    standard input or use pipe/redirection.

Examples:

    # crm -f stopapp2.cli
    # crm < stopapp2.cli
    # crm resource stop global_www
    # crm status 

    """
    sys.exit(1)

def prereqs():
    proglist = "cibadmin crm_resource crm_attribute crm_mon crm_standby crm_failcount"
    for prog in proglist.split():
        if not is_program(prog):
            no_prog_err(prog)
            sys.exit(1)

prereqs()
hist_file = os.environ.get('HOME')+"/.crm_history"
rc_file = os.environ.get('HOME')+"/.crm.rc"
readline.set_history_length(100)
readline.parse_and_bind("tab: complete")
readline.set_completer(completer)
readline.set_completer_delims(\
    readline.get_completer_delims().replace('-','').replace('/','').replace('=',''))
try: readline.read_history_file(hist_file)
except: pass
build_completions = True
levels = Levels(TopLevel)
compl_help = CompletionHelp()
build_completions = False
this_node = os.uname()[1]
lineno = -1

load_rc(rc_file)

argc = len(sys.argv)
if argc == 2 and sys.argv[1].startswith("conf"):
    parse_line(levels,["configure"])
elif argc > 1:
    interactive = False
    lineno = 0
    if sys.argv[1] == "-f":
        batch = True
        if argc != 3:
            usage()
        inp_file = sys.argv[2]
    elif sys.argv[1] == "-h" or sys.argv[1] == "--help":
        usage()
    else:
        args = sys.argv[1:]
        if parse_line(levels,args):
            sys.exit(0)
        else:
            sys.exit(1)

if not sys.stdin.isatty():
    lineno = 0
    interactive = False
    batch = True

if inp_file == "-":
    pass
elif inp_file:
    try:
        f = open(inp_file)
    except IOError, msg:
        common_err(msg)
        usage()
    sys.stdin = f

while True:
    if interactive:
        prompt = "crm(%s)%s# " % (cib_prompt(),levels.getprompt())
    inp = multi_input(prompt)
    if inp == None:
        cmd_exit("eof")
    try: parse_line(levels,shlex.split(inp))
    except ValueError, msg:
        common_err(msg)

# vim:ts=4:sw=4:et:
