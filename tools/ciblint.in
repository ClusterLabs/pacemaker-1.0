#!@PYTHON@
__copyright__='''
Author: Alan Robertson	<alanr@unix.sh>
Copyright (C) 2007 International Business Machines
Licensed under the GNU GPL version 2 or later
'''

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

#
#	ciblint: Program to audit Linux-HA CIB for potential problems.
#	analogous to 'lint' for 'C' programs
#
#
#	Not everything that 'ciblint' comments on is necessarily a problem
#	but its comments are probably worth spending some effort to understand.
#
#	This program is a work-in-progress, but for many CIBs it's probably
#	useful now.
#
#	A few of the things we try and catch are listed in the usage text below...
#
#	Things to do:
#	- validate the CIB against the DTD
#	- process the 'status' section and flag potential problems
#	- figure out why resource "x" isn't running
#
#	To Do for the OCF standards crew:
#	- Add support for enumerations to metadata
#	- add content type alternatives, first recognized is best (?)
#		Some thoughts:
#			score/string
#			positiveinteger/integer
#			negativeinteger/integer
#			ipv4addr/string
#			pathname/string

from UserDict import UserDict
import os, sys, string, types, re
from xml.dom.ext.reader.Sax2 import FromXmlStream, FromXml

usage_message=\
"usage: " + sys.argv[0] + " [-C] -f cib-file\n" + \
"       " + sys.argv[0] + " [-C] -L\n" +\
"       " + sys.argv[0] + " [-w] (-A|--list-meta_attributes-config-options\n" +\
"       " + sys.argv[0] + " [-w] (-l|--list-crm-config-options)\n" +\
"       " + sys.argv[0] + " [-w] -h --help\n" +'''
  -f cib-filename		analyze CIB from this XML file
  -L --live-cib			analyze live CIB gotten via cibadmin -Q
  -C --ignore-non-defaults	don't print messages for non-default crm_config values
  -w --wiki-format		print usage or crm-config-options in wiki format
  -l --list-crm_config-options	print all valid names for use in <nvpair> sections
                                inside the <crm_config> section
  -A --list-meta_attributes-config-options
                                print all valid names for use in <nvpair> sections
                                inside <meta_attributes> sections
                                 
CIB file can either have a status section or not.  Either is acceptable.
This program is a work-in-progress, but for many CIBs it's probably useful now.

It currently looks for a number of classes of possible errors, including these:
  - Non-unique 'id' strings for the given <tag>
  - 'id' strings which are not globally unique
  - Incorrect <nvpair> 'name's or 'value's
  - Duplicate <nvpair> 'name's in a list
  - Incorrect XML attribute names or values
  - references to non-existent resources
  - references to non-existent nodes
  - invalid values for the data type (integer, boolean, etc.) involved
  - resources you're not monitoring
  - non-negative values for default-resource-failure-stickiness
  - STONITH not enabled
  - No STONITH resources configured
  - Use of for-testing-only ssh or external/ssh STONITH resource agents
  - validation of <nvpair> names and values in <meta_attributes> sections
  - validation of class and type for <primitive> resources
  - validation of <attributes> names and values in <nvpair>s for <primitive> resources
  - check if clone form resource names are used for non-clone resources
  - ensure that clone form resource names have integral clone numbers
  - check for ids with ":" characters in them in <primitive>, <group>, <clone>, or <master_slave> tags

More documentation can be found online at http://linux-ha.org/ciblint
'''

global CIBADMIN, HA_LIBHBDIR, URLBASE, LRMADMIN
HA_LIBHBDIR = "@HA_LIBHBDIR@"
CIBADMIN="@sbindir@/cibadmin"
URLBASE="@HA_URLBASE@" + "ciblint/"
LRMADMIN="sudo @HA_LIBHBDIR@" + "/lrmadmin"

global note_non_default_values, note_metadata_errors, wikiformat, outlinelen
note_non_default_values = 1
note_metadata_errors = 1
wikiformat=0
outlinelen=70
global LRMclasses, LRMresources
LRMclasses = {}
LRMresources = {}


def lintURL(suffix):
  return URLBASE + suffix

def URLinfo(suffix):
  print "INFO: See %s for more information on this topic." % lintURL(suffix)

def crm_config_url(option):
  URLinfo("crm_config#"+option)

def typeToString(node):
  if node.nodeType == node.ELEMENT_NODE:
    return "ELEMENT"
  if node.nodeType == node.TEXT_NODE:
    return "TEXT"
  if node.nodeType == node.CDATA_SECTION_NODE:
    return "CDATA"
  if node.nodeType == node.ENTITY_REFERENCE_NODE:
    return "ENTITYREF"
  if node.nodeType == node.ENTITY_NODE:
    return "ENTITY"
  if node.nodeType == node.PROCESSING_INSTRUCTION_NODE:
    return "INSTRUCTION"
  if node.nodeType == node.COMMENT_NODE:
    return "COMMENT"
  if node.nodeType == node.DOCUMENT_NODE:
    return "DOCUMENT"
  if node.nodeType == node.DOCUMENT_TYPE_NODE:
    return "DOCTYPE"
  if node.nodeType == node.NOTATION_NODE:
    return "NOTATION"
  return "HUH?"


def node2str(node):
  if hasattr(node, "tagName"):
    return "<%s type=%s>" % (node.tagName, typeToString(node))
  return "<NODE TYPE=%s>" % (typeToString(node))

def prchildren(node):
  for child in node.childNodes:
    print "CHILD: " + node2str(child)

def print_wrap(text, linelen, prefix, firstprefix):
    words=text.split()
    line=""
    thisprefix=firstprefix
#    print "prefix=[%s] firstprefix=[%s] thisprefix=[%s]" % (prefix, firstprefix, thisprefix)
    for word in words:
      realprefix=thisprefix.expandtabs()
      llen = linelen - len(realprefix)
      if len(line)+len(word) > llen-1:
        if line != "":
          print thisprefix + line
          thisprefix=prefix
          line=""
      if line == "":
        line=word
      else:
        line=line+ " " + word
    if line != "":
        print thisprefix + line

#
#	A class for a data type as defined by our metadata - with a few extensions...
#	This should probably be a class with a bunch of related classes for the
#	various data types
#
class MetadataValueType:

  # List of supported types
  ValidTypes = {"integer":1, "boolean":1, "time":1, "string":1, "enum":1, "score":1}

  # List of supported time units - probably not correct ;-)
  TimeUnits = {"s":1, "sec":1, "seconds":1,
  	"ms":1, "milliseconds":1, "usec":1, "us":1, "microseconds":1,
  	"min":1, "m":1, "h":1, "hours":1};

  # List of legal boolean strings
  BooleanStrings = {"true":1, "enabled":1, "1":1, "on":1,
  	"false":0, "disabled":0, "0":0, "off":0}

  def __init__(self, typename, validtypevals=None):
    self.typename = string.lower(typename)
    if validtypevals != None and len(validtypevals) > 0:
      self.validtypevals = validtypevals
    else:
      self.validtypevals = None
    if not MetadataValueType.ValidTypes.has_key(typename):
      print "ERROR: Illegal type [%s]" % typename

  def validate(self, value):
    value = string.lower(value)

    if self.validtypevals != None:
      return self.validtypevals.has_key(value)

    if self.typename == "boolean":
      value=string.lower(value)
      return MetadataValueType.BooleanStrings.has_key(value)

    if self.typename == "score":
      if value == "infinity" or value == "-infinity" or value == "+infinity":
        return 1
      i = MetadataValueType("integer")
      return i.validate(value)
      

    if self.typename == "integer":
      if len(value) == 0:
        return None
      trans=string.maketrans("","")
      if value[0] == "+" or value[0] == "-":
        if len(value) < 2:
          return None
        value=value[1:]
      j=0
      max=len(value)
      while j < max:
        # We don't allow negative times...
        if string.find(string.digits, value[j]) < 0:
          return None
        j=j+1
      return 1

    # "time" objects are elapsed times, not time of day, etc
    if self.typename == "time":
       # Split into integer and units
       lastnum=-1
       j=0
       max=len(value)
       while j < max:
         # We don't allow negative times...
         if string.find(string.digits, value[j]) < 0:
           break
         lastnum=j
         j=j+1
       if j <= 0:
         return None
       units=value[j+1:len(value)-1]
       if len(units) == 0:
         return 1
       return MetadataValueType.TimeUnits.has_key(units)

    if self.typename == "string" or self.typename == "enum":
      return 1
    print "ERROR: invalid data type [%s]" % self.typename
    return None

global StringMetadataType, BooleanMetadataType, IntegerMetadataType
StringMetadataType = MetadataValueType("string")
BooleanMetadataType = MetadataValueType("boolean")
IntegerMetadataType = MetadataValueType("integer")
TimeMetadataType = MetadataValueType("time")
EnumMetadataType = MetadataValueType("enum")
ScoreMetadataType = MetadataValueType("score")
UuidMetadataType = MetadataValueType("string")

#
#	A score class - a lot like longs, except it reserves +infinity and -infinity
#
class Score:
  infinity=long(10000000)
  neginfinity=long(-infinity)

  def __init__(self, weight=0):

    stringweight=string.lower(str(weight))
    if stringweight == "infinity" or weight == "+infinity":
      self.value=Score.infinity
    elif stringweight == "-infinity":
      self.value=Score.neginfinity
    else:
      self.value=string.atol(weight)

    if self.value > Score.infinity:
      raise ValueError, "value > infinity"
    elif self.value < Score.neginfinity:
      raise ValueError, "value < -infinity"

  def __str__(self):
    if self.value == Score.infinity:
      return "infinity"
    if self.value == Score.neginfinity:
      return "-infinity"
    return str(self.value)

  def __int__(self):
    return int(self.value)

  def __long__(self):
    return long(self.value)

  def __add__(self,rhs):
     if (self.value ==    Score.infinity and rhs.value == Score.neginfinity) \
     or (self.value == Score.neginfinity and rhs.value == Score.infinity):
       raise ValueError, "+-infinity added"
     if self.value == Score.infinity or rhs.value == Score.infinity:
       return Score(Score.infinity)
     if self.value == Score.neginfinity or rhs.value == Score.neginfinity:
       return Score(Score.neginfinity)
     return Score(self.weight + rhs.weight)

  def __sub__(self,rhs):
    if hasattr(rhs, "value"):
      return __add__(self, Score(-rhs.value))
    return __add__(self, Score(-rhs))

  def __cmp__(self, rhs):
    if hasattr(rhs, "value"):
      diff=self.value-rhs.value
    else:
      diff=self.value-rhs
    if diff < 0:
      return -1
    if diff > 0:
      return 1
    return 0

#
#	A class for a multi-language string - based on the OCF resource agent metadata descriptions
#

class OCFLangString(UserDict):
  def __init__(self, xmlnode, tagname, elemname):
    UserDict.__init__(self)
    self.context = xmlnode.tagName
    self.name = tagname
    for child in xmlnode.childNodes:
      if child.nodeType != child.ELEMENT_NODE:
        continue
      CheckAttributes(tagname)
      if child.tagName != tagname:
        continue
      lang = child.getAttribute("lang")
      if lang == "":
        if note_metadata_errors:
          print "Metadata ERROR: <%s> tag without lang attribute. Context: inside <%s> tag"\
          %	(tagname, self.context)
          print "         (this is not a problem in your CIB)"
        continue
      if self.has_key(lang):
        if note_metadata_errors:
          print "Metadata ERROR: duplicate <%s lang=\"%s\"> tag. Context: inside <%s> tag"\
          %	(tagname, lang, self.context)
          print "         (this is not a problem in your CIB)"
        continue
      if len(child.childNodes) >= 1:
        self[lang]=child.childNodes[0].data
        #print "Snagged %s: %s" % (tagname, child.childNodes[0].data)
      else:
        if note_metadata_errors:
          print "Metadata ERROR: <%s lang=\"%s\"> has no data.  Context:  Inside <%s> tag" \
          %  (tagname, lang, self.context)
          print "         (this is not a problem in your CIB)"
        self[lang]=elemname
      
    if len(self) < 1:
      if note_metadata_errors:
        print "Metadata ERROR: <%s> inside <%s> has no data in any language"\
        %		(tagname, self.context)
      self["en"]=elemname

  def text(self, lang="en"):
    if not self.has_key(lang) and lang != "en":
      if self.has_key("en"):
        return self["en"]
      else:
        for lang in self.keys():
          return self[lang]
        return None
    else:
      return self[lang]

#
#	A class for tracking possible enumeration values based on the OCF RA metadata
#	model.  This is an extension from the curent OCF model, but it should
#	be completely upwards-compatible in the xml.  Here's how it looks:
#
#	<content type="enum" default="xxx">
#	  <enumvals>
#	    <enumval value="red">
#	      <shortdesc lang="en">long description</shortdesc>
#	      <longdesc lang="en">long description</longdesc>
#	    </enumval>
#	  </enumvals>
#	</content>
#	  
class OCFParameterEnumValNodeExtension(UserDict):
  def __init__(self, xmlnode):
    UserDict.__init__(self)
    # xmlnode should point to the <content> tag...
    for child in xmlnode.childNodes:
      if child.nodeType != child.ELEMENT_NODE:
        continue
      CheckAttributes(child)
      if child.tagName == "enumvals":
        for gchild in child.childNodes:
          if gchild.nodeType != gchild.ELEMENT_NODE:
            continue
          CheckAttributes(gchild)
          value = gchild.getAttribute("value")
          if gchild.tagName == "enumval":
            value = gchild.getAttribute("value")
	    self[value] = (OCFLangString(gchild, "shortdesc", value), OCFLangString(gchild, "longdesc", value))
          else:
            print "Metadata ERROR: Don't know how to deal with funky child of <%s>" % child.tagName
            print "Funky child: " + node2str(gchild)
#      elif child.tagName == "enumval":
#        value = child.getAttribute("value")
#	self[value] = (OCFLangString(child, "shortdesc", value), OCFLangString(child, "longdesc", value))
      else:
        print "Metadata ERROR: Don't know how to deal with funky child of <%s>" % xmlnode.tagName
        print "Funky child: " + node2str(child)
    if len(self) < 1:
      self=None


#
# A class for dealing with OCF Parameter metadata
#
class OCFParameterMetadata:
  def __init__(self, xmlnode):
    self.unique = 0
    self.type = StringMetadataType
    self.default = None
    self.name = xmlnode.getAttribute("name")
    self.unique = xmlnode.getAttribute("unique")
    self.typename = "string"
    self.longdescs=OCFLangString(xmlnode,"longdesc", self.name)
    self.shortdescs=OCFLangString(xmlnode,"shortdesc", self.name)
    self.type=MetadataValueType(self.typename)
    if self.unique == "":
      self.unique=0
    else:
      self.unique=string.atoi(self.unique)
    self.required = xmlnode.getAttribute("required")
    if self.required == "":
      self.required=0
    else:
      self.required=string.atoi(self.required)
    children=xmlnode.childNodes
    for child in children:
      if child.nodeType != child.ELEMENT_NODE:
        continue
      if child.tagName == "shortdesc" or child.tagName == "longdesc":
        continue
      if child.tagName == "content":
        type = child.getAttribute("type")
        # Sneak in and tweak some of our metadata...
        if re.match('^default-resource-.*stickiness$', self.name) and type == "integer":
          # These are really scores, but integer is all the CRM currently knows about
          type="score"
        if type != "":
          self.typename = type
          if type == "enum":
            enuminfo = OCFParameterEnumValNodeExtension(child)
          else:
            enuminfo = None
          self.type=MetadataValueType(type, enuminfo)
        default = child.getAttribute("default")
        if default != "":
          self.default=default
      else:
        print "ERROR: Don't know how to deal with funky child of <%s>" % xmlnode.tagName
        print "Funky child: " + node2str(child)

  def shortdesc(self, lang="en"):
    return self.shortdescs.text(lang)

  def longdesc(self, lang="en"):
    return self.longdescs.text(lang)

  def validate(self, value):
    return self.type.validate(value)

  def explainnondefault(self, value, lang="en"):
    if not self.validate(value):
      print "ERROR: Value [%s] is not a valid value of type [%s] in <%s>"  \
	% (value, self.type.typename, self.name)
    if self.default != None and self.default != "" and value != self.default \
    and note_non_default_values:
      print "INFO: CIB has non-default value for %s [%s].  Default value is [%s]" \
	%	(self.name, value, self.default)
      print_wrap("Explanation of %s option: %s" % (self.name, self.shortdesc(lang)),\
		outlinelen, "      ", "INFO: ")
      if self.longdesc(lang) != self.shortdesc(lang):
        print_wrap(self.longdesc(lang), outlinelen, "INFO: ", "INFO: ")

#
#	OCF metadata class - descriptions, parameters, types, operations, etc.
#
class OCFMetadata:
  RequiredOps = {"start":1, "stop":1, "monitor":1, "meta-data":1, "validate-all":1}
  def __init__(self, xmlnode):
    self.langfilter = "en"
    self.Operations={}
    self.Parameters={}
    self.name = "none"
    self.longdescs = {}
    self.shortdescs = {}
    children=xmlnode.childNodes
    for topchild in children:
      #print "DEBUG: Metadata top child: " + node2str(topchild)
      if topchild.nodeType != topchild.ELEMENT_NODE:
        continue
      if topchild.tagName != "resource-agent":
         continue
      self.name = topchild.getAttribute("name")
      self.longdescs=OCFLangString(topchild,"longdesc", self.name)
      self.shortdescs=OCFLangString(topchild,"shortdesc", self.name)

      for child in topchild.childNodes:
        if child.nodeType != child.ELEMENT_NODE:
          continue

	# Short Description
        elif child.tagName == "shortdesc" or child.tagName == "longdesc" \
        or child.tagName == "version":
          continue

	# Parameters
        elif child.tagName == "parameters":
          for gchild in child.childNodes:
            if gchild.nodeType != gchild.ELEMENT_NODE:
              continue
	    # Parameter (singular)
            if gchild.tagName == "parameter":
              p = OCFParameterMetadata(gchild)
              self.Parameters[p.name] = p

	# Actions
        elif child.tagName == "actions":
          for gchild in child.childNodes:
            if gchild.nodeType != gchild.ELEMENT_NODE:
              continue
	    # Action (singular)
            if gchild.tagName == "action":
              # Good enough to get us started...
              self.Operations[gchild.getAttribute("name")] = 1
            else:
              print "ERROR: Don't know how to deal with funky child of <%s>" % child.tagName
              print "Funky child: " + node2str(gchild)
        else:
          print "ERROR: Don't know how to deal with funky child of <%s>" % topchild.tagName
          print "Funky child: " + node2str(child)
        self=None
        return

  def shortdesc(self, lang="en"):
    return self.shortdescs.text(lang)

  def longdesc(self, lang="en"):
    return self.longdescs.text(lang)

  def has_parameter(self, p):
    return self.Parameters.has_key(p)

  def validate(self, p, value):
    if not self.Parameters.has_key(p):
      print "ERROR: [%s] is not a legal name to [%s]" \
	% (p, self.name)
      return None
    return self.Parameters[p].validate(v)

  def validate_nvpairs(self, nvpairs):
    ret=1
    for p in nvpairs.keys():
      if not self.Parameters.has_key(p):
        print "ERROR: <nvpair name=\"%s\" ...> \"%s\" is not a legal nvpair name inside <%s> tag" \
	%	(p, p, self.name)
        ret=0
        continue
      if not self.Parameters[p].validate(nvpairs[p]):
        print "ERROR: <nvpair name=\"%s\" value=\"%s\">: \"%s\" is not a legal value for name %s inside <%s> tag" \
	%	(p, nvpairs[p], nvpairs[p], p, self.name)
        ret=0
    return ret
 
  def explainnondefault(self, p, value, lang="en"):
    if not self.Parameters.has_key(p):
      print "ERROR: [%s] is not a legal parameter to [%s]" \
	% (p, self.name)
      return
    self.Parameters[p].explainnondefault(value, lang)

  def explainall(self, lang="en"):
    for key in self.Parameters.keys():
      item = self.Parameters[key]
      if item.default == None:
        deflt=""
      else:
        deflt=": default=%s" % item.default
      
      print_wrap("%s [%s%s]: %s" % (key,item.typename,deflt,	\
	item.shortdesc(lang)), outlinelen, "    ", "")
      print_wrap(item.longdesc(lang), outlinelen, "    ", "    ")
      if item.type.validtypevals != None:
        for enumval in item.type.validtypevals.keys():
          descs= item.type.validtypevals[enumval]
          shortd=descs[0].text(lang)
          longd=descs[1].text(lang)
          print_wrap("%s: %s" % (enumval, shortd), outlinelen, "\t    ", "\t")
          if (longd != None and long != "" and longd!= shortd):
            print_wrap(longd, outlinelen, "\t    ", "\t    ")

  def explainall_wiki(self, lang="en"):
    for key in self.Parameters.keys():
      item = self.Parameters[key]
      print "== %s ==" % key
      print "[[Anchor(%s)]]" % key
      if item.default == None:
        deflt=""
      else:
        deflt=": default=%s" % item.default
      print "'''%s''' [%s%s]: ''%s''[[BR]]" % (key, item.typename, deflt,\
      	self.Parameters[key].shortdesc(lang))
      print "%s" % (self.Parameters[key].longdesc(lang))
      if item.type.validtypevals != None:
        for enumval in item.type.validtypevals.keys():
          descs=item.type.validtypevals[enumval]
          print " * '''%s:''' %s[[BR]]%s" % (enumval, descs[0].text(lang), descs[1].text(lang))

  def supports_action(self, op):
    if OCFMetadata.RequiredOps.has_key(op):
      return 1
    return self.Operations.has_key(p)

#
# A class for collecting OCF-style metadata from the CRM and the pengine
# and a little extra hand-created metadata...
#
class CRMMetadata:
  def __init__(self, hblibdir=HA_LIBHBDIR):
    ExtraMetadata =\
'''<resource-agent name="crm_config">
  <version>1.0</version>
  <longdesc lang="en">Extra Options that can be configured for crm_config section.</longdesc>
  <shortdesc lang="en">crm_config extra metadata</shortdesc>
  <parameters>
    <parameter name="last-lrm-refresh" unique="0">
      <shortdesc lang="en">last LRM refresh</shortdesc>
      <longdesc lang="en">you can't set this yourself</longdesc>
      <content type="integer"/>
    </parameter>
  </parameters>
</resource-agent>
'''
    self.metadatalist = []
    for file in ["crmd", "pengine"]:
      command="%s/%s metadata" % (hblibdir, file)
      f = os.popen(command)
      f.readline()  # work around bad first line in metadata
      xml = FromXmlStream(f)
      self.metadatalist.append(OCFMetadata(xml))
      f.close()
      xml = None
    self.metadatalist.append(OCFMetadata(FromXml(ExtraMetadata)))

  def validate(self, nvpairs):
    for key in nvpairs.keys():
      found=None
      for mdlist in self.metadatalist:
         if mdlist.has_parameter(key):
           found=1
           if not mdlist.validate(key, nvpairs[key]):
             print "ERROR: in <nvpair name=\"%s\" value=\"%s\"...>: [%s]  not a legal 'value'" \
	     %	(key, nvpairs[key], nvpairs[key])
           break
      if not found:
        print "ERROR: <nvpair name=\"%s\"...>: [%s] is not a legal name for" \
        +	" the <crm_config> section" % (key, key)

  def explainnondefault(self, nvpairs):
    for key in nvpairs.keys():
      found=None
      for mdlist in self.metadatalist:
         if mdlist.has_parameter(key):
           found=1
           mdlist.explainnondefault(key, nvpairs[key])
      if not found:
        print ("ERROR: <nvpair name=\"%s\"...>: [%s] is not a legal name in" \
        +	" the <crm_config> section") % (key, key)

  def explainall(self):
    if wikiformat:
      print "= crm_config options ="
    for mdlist in self.metadatalist:
      if wikiformat:
        mdlist.explainall_wiki()
      else:
        mdlist.explainall()
    if wikiformat:
      print "----"
      print "''This page the output from ciblint -w -l''"

  def __getitem__(self, key):
    for mdlist in self.metadatalist:
      if mdlist.Parameters.has_key(key):
        return mdlist.Parameters[key]
    raise KeyError, "Key %s not found" % key

#
#	Get <crm_config> metadata from pengine and crmd
#
class MetaAttrMetadata:
  def __init__(self, hblibdir=HA_LIBHBDIR):
    self.metadatalist = []
    for file in ["crmd", "pengine"]:
      command="%s/%s metadata" % (hblibdir, file)
      f = os.popen(command)
      f.readline()  # work around bad first line in metadata
      xml = FromXmlStream(f)
      self.metadatalist.append(OCFMetadata(xml))
      f.close()
      xml = None

#
#	Obtain and cache metadata from resource agents
#	This involves talking to the LRM, which requires that we run
#	as root.
#
class MetadataCache(UserDict):
 def __is_lrm_working__(self):
   cmd=LRMADMIN + " -C 2>/dev/null"
   f = os.popen(cmd)
   global LRMclasses, LRMresources
   localclasses = f.readlines()
   localclasses = localclasses[1:]
   j=0
   while j < len(localclasses):
     LRMclasses[localclasses[j].strip()] = 1
     j=j+1
   f.close()
   for rclass in LRMclasses:
     LRMresources[rclass] = {}
     cmd=LRMADMIN + " -T %s 2>/dev/null" % rclass
     f = os.popen(cmd)
     types = f.readlines()
     types = types[1:]
     f.close()
     for type in types:
       type=type.strip()
       # Not quite right, because it ignores provider...
       LRMresources[rclass][type]=1
   return len(LRMclasses) >= 1

 def __init__(self):
    UserDict.__init__(self)
    # Test if LRM connections work...
    self.uselrm=MetadataCache.__is_lrm_working__(self)

 def __resource_key__(self, rclass, type, provider):
   if rclass == "ocf":
     return "Resource/"+rclass+"/"+provider+"/"+type
   return "Resource/"+rclass+"/"+type

 def __stash_lrm__(self, key, command):
   #print "COMMAND=%s" % command
   f = os.popen(command)
   #print "READ1:", f.readline()  # ignore line
   #print "READ2:", f.readline()  # ignore line
   #print "READ3:", f.readline()  # ignore line
   #print "READ4:", f.readline()  # ignore line
   try:
     self[key]=OCFMetadata(FromXmlStream(f))
   except:
     if note_metadata_errors:
       print "Metadata ERROR: Could not get resource metadata for %s" % key
       print "INFO: Resource parameters for this resource type will not be checked"
     self[key] = None
   else:
     #print "HOORAY!  PARSING WORKED for %s!" % key
     #print self[key]
     None
   return f.close()

 def __add_resource__(self, rclass, type, provider=None):
   if not self.uselrm:
      return 0
   if not LRMclasses.has_key(rclass):
     print "ERROR: %s is not a valid resource class" % rclass
     return 0
   if not LRMresources[rclass].has_key(type):
     print "ERROR: [%s] is not a valid type for resource class [%s]" % (type, rclass)
     return 0
   key=self.__resource_key__(rclass, type, provider)
   if (provider == None or provider == ""):
     provider="NULL"
   lrmcommand="%s --metadata %s %s %s 2>/dev/null | grep -v '^<!DOCTYPE'|tee foo.bar" % (LRMADMIN, rclass, type, provider)
   return self.__stash_lrm__(key, lrmcommand)

 def RAmetadata(self, rclass, type, provider=None):
   key=self.__resource_key__(rclass, type, provider)

   if self.has_key(key):
     return self[key]
   else:
     self.__add_resource__(rclass, type, provider)
   if self.has_key(key):
     return self[key]
   return None

global crmMetadata, crm_config_section, metaDataCache
global MetaAttributeMetadata, MetaAttributeMetadata_string
crmMetadata = None
MetaAttributeMetadata = None
metaDataCache = MetadataCache()

#
#	Metadata describing the <meta_attribute> <nvpair> names and values
#	This should probably eventually come from the CRM/pengine.
#

#'''<?xml version="1.0"?>
MetaAttributeMetadata_string =\
'''<resource-agent name="meta_attributes">
  <version>1.0</version>
  <longdesc lang="en">Options that can be configured for resource meta_attributes.</longdesc>
  <shortdesc lang="en">Resource meta_attributes Options</shortdesc>
  <parameters>
    <parameter name="restart_type" unique="0">
      <shortdesc lang="en">how to restart dependents</shortdesc>
      <longdesc lang="en">how to restart dependents when this resource restarts</longdesc>
      <content type="enum" default="restart">
        <enumvals>
	  <enumval value="ignore">
            <shortdesc lang="en">Dependent resources ignore restarts of this resource</shortdesc>
            <longdesc lang="en">Dependent resources take no action when this resource is restarted due to monitor failure</longdesc>
	  </enumval>
	  <enumval value="restart">
            <shortdesc lang="en">Restart dependent resources when this one restarts</shortdesc>
            <longdesc lang="en">Dependent resources restart when this resource is restarted due to monitor failure</longdesc>
	  </enumval>
        </enumvals>
      </content>
    </parameter>


    <parameter name="ordered" unique="0">
      <content type="boolean" default="0"/>
      <shortdesc lang="en">Start (or stop) each clone only after the operation on the previous clone completed.</shortdesc>
      <longdesc lang="en">This serializes operations on a set of clones ensuring that operations between individual clones never overlap.</longdesc>
    </parameter>

    <parameter name="interleave" unique="0">
      <content type="boolean" default="0"/>
      <shortdesc lang="en">affects clones with colocation constraints</shortdesc>
      <longdesc lang="en">If a colocation constraint is created between two clone resources and interleaved is true, then clone N from one resource will be assigned the same location as clone N from the other resource.  If the number of runnable clones differs, then the leftovers can be located anywhere.  Using a cloned group is a much better way of achieving the same result.
      </longdesc>
    </parameter>

    <parameter name="clone_max" unique="0">
      <content type="integer" default="0"/>
      <shortdesc lang="en">Max number of clones</shortdesc>
      <longdesc lang="en">Total maximum number of clones of this resource permitted. Value defaults to the number of nodes in the system.</longdesc>
    </parameter>

    <parameter name="clone_node_max" unique="0">
      <content type="integer" default="1"/>
      <shortdesc lang="en">Max number of clones/node</shortdesc>
      <longdesc lang="en">Total maximum number of clones allowed to run on one node at a time</longdesc>
    </parameter>

    <parameter name="master_max" unique="0">
      <content type="integer" default="1"/>
      <shortdesc lang="en">Max number of masters</shortdesc>
      <longdesc lang="en">Maximum number of instances of this resource which are allowed to be master at one time. Must be less than or equal to "clone_max"</longdesc>
    </parameter>

    <parameter name="master_node_max" unique="0">
      <content type="integer" default="1"/>
      <shortdesc lang="en">Max number of masters/node</shortdesc>
      <longdesc lang="en">Maximum number of instances of this resource which are allowed to be master on a node at one time. Must be less than or equal to "clone_node_max"</longdesc>
    </parameter>

    <parameter name="clone_state" unique="0">
      <content type="enum" default="0"/>
      <shortdesc lang="en">clone state FIXME</shortdesc>
      <longdesc lang="en">clone state FIXME</longdesc>
    </parameter>

    <parameter name="is_managed" unique="0">
      <content type="boolean"/>
      <shortdesc lang="en">"true" if this resource is managed by Heartbeat</shortdesc>
      <longdesc lang="en">If set to "false", Heartbeat will not monitor it, nor restart it on failure of resource or node.  Commonly set to "true" to allow for maintenance of the resource.  It defaults to the currently active value of "is-managed-default" from the crm_config section.</longdesc>
    </parameter>


    <parameter name="target_role" unique="0">
      <shortdesc lang="en">Desired state of the resource</shortdesc>
      <longdesc lang="en">Heartbeat will attempt keep it in the specfied state.  It defaults to "#default".  If set to some other value, it will ignore the value of is_managed or is_managed_default.</longdesc>
      <content type="enum">
	<enumvals>
	  <enumval value="started">
            <shortdesc lang="en">Keep resource started</shortdesc>
            <longdesc lang="en">Keep resource started</longdesc>
	  </enumval>
	  <enumval value="stopped">
            <shortdesc lang="en">Keep resource stopped</shortdesc>
            <longdesc lang="en">Keep resource stopped.  Resources which depend on this resource will also be stopped</longdesc>
	  </enumval>
	  <enumval value="master">
            <shortdesc lang="en">keep resource in master mode</shortdesc>
            <longdesc lang="en">keep resource in master mode.  This doesn't seem like a sensible value to set this to for a clone resources with multiple instances and fewer slave instances.</longdesc>
	  </enumval>
	  <enumval value="slave">
            <shortdesc lang="en">keep resource in slave mode</shortdesc>
            <longdesc lang="en">keep resource in slave mode. This forces all the instances to stay in slave mode</longdesc>
	  </enumval>
	  <enumval value="#default">
            <shortdesc lang="en">allow cluster to determine its</shortdesc>
            <longdesc lang="en">explicitly inherit target_role from enclosing group or allow Heartbeat to control its state </longdesc>
	  </enumval>
	</enumvals>
      </content>
    </parameter>

    <parameter name="globally_unique" unique="0">
      <shortdesc lang="en">"true" means this clone is unique within the cluster</shortdesc>
      <longdesc lang="en">A globally unique clone can distinguish which clone number it is within the cluster - typically implying a true cluster-aware application.  A non-unique clone is typically a non-cluster-aware application which can only tell if a copy of the application is running on this machine, but not which copy.</longdesc>
      <content type="boolean" default="false"/>
    </parameter>

    <parameter name="notify" unique="0">
      <content type="boolean" default="0"/>
      <shortdesc lang="en">notify clone resource agent of changes in state</shortdesc>
      <longdesc lang="en">Issue pre and post operation notifications to entire clone set for every operation.  This introduces shell-level barriers for the resource agent actions    If true, inform peers before and after any clone is stopped or started.  If an action failed, you will (currently) not recieve a post-notification.  Instead you can next expect to see a pre-notification for a stop.  If a stop fails, and you have fencing you will get a post-notification for the stop after the fencing operation has completed.  In order to use the notification service ALL decendants of the clone MUST support the notify action.  Currently this action is not permitted to fail, though depending on your configuration, can block almost indefinitely.  Behaviour in response to a failed action or notificaiton is likely to be improved in future releases.
      </longdesc>
    </parameter>

    <parameter name="resource_failure_stickiness" unique="0">
      <content type="score" default="0"/>
      <shortdesc lang="en">resource_failure_stickiness FIXME</shortdesc>
      <longdesc lang="en">resource_failure_stickiness FIXME</longdesc>
    </parameter>

    <parameter name="multiple_active" unique="0">
      <shortdesc lang="en">action to take when multiple instances are active</shortdesc>
      <longdesc lang="en">When an instance of this resource is found to be active mutliple times, this parameter specifies what action to take.</longdesc>
      <content type="enum" default="start_stop">
	<enumvals>
	  <enumval value="stop_start">
            <shortdesc lang="en">stop all and restart one</shortdesc>
            <longdesc lang="en">Stop all instances of this resource, and restart one.  This works fine if the resource won't be irreparably damaged by having multiple active instances.</longdesc>
          </enumval>
	  <enumval value="stop_only">
            <shortdesc lang="en">stop all instances</shortdesc>
            <longdesc lang="en">Stop all instances of this resource and wait for the administrator to recover the resources manually.  This is a good choice if this resource (like most filesystems) will be damaged by multiple running copies, and get more damaged the longer they're multiply active.</longdesc>
	  </enumval>
	  <enumval value="block">
            <shortdesc lang="en">do nothing</shortdesc>
            <longdesc lang="en">Don't do anything - wait for the administrator to recover the resources.</longdesc>
	  </enumval>
	</enumvals>
      </content>
    </parameter>

    <parameter name="start_prereq" unique="0">
      <content type="enum" default="0"/>
      <shortdesc lang="en">obsolete?</shortdesc>
      <longdesc lang="en">Is this obsolete - replaced by the prereq attribute of the op tag?</longdesc>
    </parameter>

    <parameter name="priority" unique="0">
      <content type="integer" default="0"/>
      <shortdesc lang="en">is this obsolete?</shortdesc>
      <longdesc lang="en">Should this be a parameter or an attribute of a resource? - or is it the other way around?</longdesc>
    </parameter>

  </parameters>
</resource-agent>
'''

GlobalIDSet = {}
GlobalTagIDSet = {}
crm_config_section=None

#
# Check the 'id' attributes of the current node to make sure it has an id and that it's
# unique for the tag and (preferably) also globally unique.
#

def CheckXMLNodeUniqueness(xmlnode):
    CheckAttributes(xmlnode)
    if hasattr(xmlnode, "tagName"):
      id = xmlnode.getAttribute("id")
      if id == "":
        print "ERROR: Tag <%s/> requires an 'id' attribute" % xmlnode.tagName
        return None
      return CheckIdUniqueness(xmlnode.tagName, id)
    return 1

def CheckIdUniqueness(tag, id):
    global GlobalIdSet
    global GlobalTagIDSet
    ret = 1
    if not GlobalTagIDSet.has_key(tag):
      GlobalTagIDSet[tag] = {}
    if GlobalTagIDSet[tag].has_key(id):
      print "ERROR: <%s> id '%s' not unique among all <%s> tags" \
      % (tag, id, tag)
      ret = None
    else:
      GlobalTagIDSet[tag][id] = id
    if GlobalIDSet.has_key(id):
      print "NOTE: '%s' not globally unique among all 'id's" % id
    else:
      GlobalIDSet[id] = id
    return ret

#
# A few types for us to use internally...
# Some should probably be implemented more directly as noted below.
#

RoleMetadataType = MetadataValueType("enum", {"started":1, "stopped":1,"master":1,"slave":1})
NodeMetadataType = MetadataValueType("enum", {"normal":1})
OrderMetadataType = MetadataValueType("enum", {"before":1, "after":1})
StopStartMetadataType = MetadataValueType("enum", {"stop_start":1, "stop_only":1, "block":1})
RestartMetadataType = MetadataValueType("enum", {"ignore":1, "restart":1})
OpMetadataType = MetadataValueType("enum", {"lt":1, "lte":1,"gt":1,"gte":1,
				"eq":1, "ne":1, "defined":1, "not_defined":1})
DateOpMetadataType = MetadataValueType("enum", {"in_range":1, "date_spec":1,"gt":1,"lt":1})
DateSpecMetadataType = MetadataValueType("enum", {"in_range":1, "date_spec":1,"gt":1,"lt":1})
BoolDefaultMetadatatype = MetadataValueType("enum", {"true":1, "false":0,"1":1,"0":0, "#default":1,"on":1, "off":0})
CrmStatusMetadataType = MetadataValueType("enum", {"online":1, "offline":0})
MemberStatusMetadataType = MetadataValueType("enum", {"member":1, "down":0})
HaStatusMetadataType = MetadataValueType("enum", {"active":1, "init":1, "dead":0})
LrmOpMetadataType = MetadataValueType("enum", {"start":1, "stop":1,"reload":1,"monitor":1, "migrate":1})
LrmClassMetadataType = MetadataValueType("enum", {"stonith":1, "ocf":1,"heartbeat":1,"lsb":1})
BooleanOpMetadataType = MetadataValueType("enum", {"and":1, "or":1})
			
# Could eventually do something fancier for these...
ResourceMetadataType = StringMetadataType
GroupMetadataType = StringMetadataType

idonly = {"id": StringMetadataType}

NVPairValidKeys = {
	"node": {"standby": BooleanMetadataType},
};
#
# Set of valid attribute keys and value types for various tags
#
AttributeKeys = {
	"op": {		"timeout": TimeMetadataType, "start_delay": TimeMetadataType, 
			"interval": TimeMetadataType,
			"disabled": BooleanMetadataType, "role": RoleMetadataType,
			"id": StringMetadataType, "name": StringMetadataType},
	"primitive":{	"class": StringMetadataType, "provider": StringMetadataType,
			"type": StringMetadataType, "id": StringMetadataType,
			"resource_stickiness": IntegerMetadataType,
			"is_managed": BoolDefaultMetadatatype,
			"restart_type": RestartMetadataType,
			"multiple_active": StopStartMetadataType},
	"nvpair": {	"name": StringMetadataType, "id": StringMetadataType, "value": StringMetadataType},
	"cluster_property_set": idonly,
	"cib": {	"admin_epoch":IntegerMetadataType, "have_quorum":BooleanMetadataType,
			"num_peers": IntegerMetadataType, 
			"cib_feature_revision":StringMetadataType,
			"crm_feature_set":StringMetadataType,
			"generated":BooleanMetadataType, "ignore_dtd":BooleanMetadataType,
			"epoch":IntegerMetadataType,
			"ccm_transition":IntegerMetadataType,
			"dc_uuid":UuidMetadataType,
			"num_updates":IntegerMetadataType},
	"node": {	"uname": StringMetadataType, "id": UuidMetadataType, "type": NodeMetadataType},
	"group": {	"id": StringMetadataType, "ordered": BooleanMetadataType,
			"colocated":BooleanMetadataType},
	"instance_attributes": idonly,
	"meta_attributes": idonly,
	"attributes": {},
	"enumvals": {},
	"enumval":{	"value":StringMetadataType},
	"shortdesc":{	"lang":StringMetadataType},
	"longdesc": {	"lang":StringMetadataType},
	"rsc_order": {	"id": StringMetadataType, "type": OrderMetadataType,
			"from": ResourceMetadataType, "to": ResourceMetadataType},
	"rule": {	"id": StringMetadataType, "score": ScoreMetadataType,
			"score_attribute": StringMetadataType,
			"boolean_op":BooleanOpMetadataType},
	"date_spec": {	"id": StringMetadataType,
			"hours": StringMetadataType,
			"yeardays": StringMetadataType,
			"monthdays": StringMetadataType,
			"weekdays": StringMetadataType,
			"weeks": StringMetadataType,
			"weekyears": StringMetadataType,
			"years": StringMetadataType,
			"moon": StringMetadataType},
	"duration": {	"id": StringMetadataType,
			"hours": StringMetadataType,
			"yeardays": StringMetadataType,
			"monthdays": StringMetadataType,
			"weekdays": StringMetadataType,
			"weeks": StringMetadataType,
			"weekyears": StringMetadataType,
			"years": StringMetadataType},
	"expression":	{	"id": StringMetadataType, "value": StringMetadataType,
				"attribute": StringMetadataType,
				"operation": OpMetadataType},
	"operations":	{},
	"crm_config":	{},
	"configuration":	{},
	"nodes":	{},
	"resources":	{},
	"constraints":	{},
	"rsc_location":	{"id": StringMetadataType, "rsc": ResourceMetadataType, \
			"description":StringMetadataType,
			"score":ScoreMetadataType},
	"rsc_colocation":{"id": StringMetadataType,
			"from": ResourceMetadataType, "to": ResourceMetadataType,
			"score": ScoreMetadataType},
      			"symmetrical":BooleanMetadataType,
			"from_role":RoleMetadataType,
			"to_role":RoleMetadataType,
      			"node_attribute":StringMetadataType,

	"status":	{},
	"node_state":	{"shutdown":BooleanMetadataType,
			"in_ccm":BooleanMetadataType,
			"uname":StringMetadataType,
			"crmd":CrmStatusMetadataType,
			"join":MemberStatusMetadataType,
			"expected":MemberStatusMetadataType,
			"ha":HaStatusMetadataType,
			"id": UuidMetadataType,
			"crm-debug-origin": StringMetadataType},
	"transient_attributes":	idonly,
	"lrm":	idonly,
	"lrm_resources":{},
	"lrm_resource":{"class":LrmClassMetadataType, "id": UuidMetadataType,
			"provider": StringMetadataType, "type": StringMetadataType},
	"lrm_rsc_op":{	"rc_code": IntegerMetadataType,
			"transition_magic": StringMetadataType,
			"transition_key": StringMetadataType,
			"crm_feature_set": StringMetadataType,
			"crm-debug-origin": StringMetadataType,
			"operation": LrmOpMetadataType,
			"call_id": IntegerMetadataType,
			"op_digest": StringMetadataType,
			"id": UuidMetadataType,
			"op_status": IntegerMetadataType,
			"interval": TimeMetadataType},
};

#
# Validate the attributes of this tag...
#
def CheckAttributes(xmlnode):
   global AttributeKeys
   result=1
   if not hasattr(xmlnode, "attributes") or xmlnode.attributes == None or xmlnode.nodeType != xmlnode.ELEMENT_NODE:
      return 1
   tagname=xmlnode.tagName
   if not AttributeKeys.has_key(tagname):
     print "ERROR: Unrecognized tag <%s/>" % tagname
     return 0
   table=AttributeKeys[tagname]
   for attribtup in xmlnode.attributes.keys():
      attrib=attribtup[1]
      if not table.has_key(attrib):
         print "ERROR: attribute [%s] not legal with tag <%s/>" % (attrib, tagname)
         continue
      type=table[attrib]
      value=xmlnode.getAttribute(attrib)
      if not type.validate(value):
         print "ERROR: <%s %s=\"%s\"...>: [%s] is not a legal value for attribute %s"\
	 %	(tagname, attrib, value, value, attrib)
   

#
# Validate a set of nvpairs against a given set of names and types
#
def validate_nvpairs(context, type, nvpairs):
  if context != None:
    for key in nvpairs.keys():
      if NVPairValidKeys[context].has_key(key):
        if not NVPairValidKeys[context][key].validate(nvpairs[key]):
          print "ERROR: <nvpair name=\"%s\" value=\"%s\"...>: [%s] is not a legal %s value"\
          % (key, nvpairs[key], nvpairs[key], NVPairValidKeys[context][key])
      else:
        print "ERROR: <nvpair name=\"%s\"...>: [%s] is not a legal name in <%s> tag" \
        %	(key, key, context)
  elif type != None:
    for key in nvpairs.keys():
      if not validate_value(nvpairs[key], type):
        print "ERROR: nvpair name [%s] has value [%s] which is not legal for type %s"\
        %	(key, nvpairs[key], type)
  else:
    print "ERROR: Weird invocation of validate_nvpairs()"

#
#	A class representing a collection of name/value pairs
#
class NVpairs(UserDict):
  def __init__(self):
    UserDict.__init__(self)
    self.name2idmap = {}
    self.id2namemap = {}

  def addnvpair(self, node):
    CheckXMLNodeUniqueness(node)
    name=node.getAttribute("name")
    id = node.getAttribute("id")
    value=node.getAttribute("value")
    if name == "":
      print "ERROR: <nvpair> without 'name'"
    if id == "":
      print "ERROR: <nvpair> without 'id'"
    if self.has_key(name):
      print "ERROR: name '%s' multiply defined in <nvpair> list - values are [%s] and [%s]"\
      %		(name, self[name], value)
    if self.id2namemap.has_key(id):
      print "ERROR: <nvpair> id '"+id+"' multiply defined in <nvpair> list "

    self[name] = value
    self.name2idmap[name] = id
    self.id2namemap[id] = name

  def name2id(self, name):
    return self.name2idmap[name]

  def id2name(self, id):
    return self.id2namemap[id]

#
# A class for collecting information about cluster nodes
#
class ClusterNodes(UserDict):
  def __init__(self):
    UserDict.__init__(self)
    self.uuid2unamemap = {}
    self.instance_attribute_sets = {}

  def addnode(self, xmlnode):
    CheckXMLNodeUniqueness(xmlnode)
    uname=xmlnode.getAttribute("uname")
    id = xmlnode.getAttribute("id")
    type = xmlnode.getAttribute("type")
    if uname == "":
      print "ERROR: <node> without 'uname'"
    if id == "":
      print "ERROR: <node> without 'id'"
    if type != "normal":
      print "ERROR: <node> %s type is [%s]" % (uname, type)
    if self.has_key(uname):
      print "ERROR: name '"+uname+"' multiply defined in current <node> list"
    if self.uuid2unamemap.has_key(id):
      print "ERROR: <node> id '"+id+"' multiply defined in current node list "
    self[uname] = id
    self.uuid2unamemap[id] = uname
    for child in xmlnode.childNodes:
      if child.nodeType != child.ELEMENT_NODE:
        continue
      if child.tagName == "instance_attributes":
         inst_attrs=InstanceAttributesTag(child)
         self.instance_attribute_sets[uname] = inst_attrs.attributes.nvpairs
         validate_nvpairs("node", None, inst_attrs.attributes.nvpairs)
      else:
        print "ERROR: Don't know how to deal with funky child of <%s>" % child.tagName
        print "Funky child: " + node2str(child)
        self=None
        return

  def uuid2uname(self, uuid):
    return self.uuid2unamemap[id]

#
# A class for processing the <attributes> tag
#
class AttributesTag:
  def __init__(self, xmlnode):
    CheckAttributes(xmlnode)
    self.nvpairs = NVpairs()
    for childnode in xmlnode.childNodes:
      if childnode.nodeType == childnode.ELEMENT_NODE and \
      childnode.tagName == "nvpair":
        self.nvpairs.addnvpair(childnode)

#
# A class for processing the <instance_attributes> tag
#
class InstanceAttributesTag:
  def __init__(self, instancenode):
    CheckXMLNodeUniqueness(instancenode)
    children = instancenode.childNodes
    if len(children) == 1:
      child = children[0]
    elif len(children) == 3:
      child = children[1]
    else:
       print "Don't yet know how to deal with %d children of instance attributes" % len(children)
       prchildren(instancenode)
       self=None
       return
    if child.nodeType != child.ELEMENT_NODE \
    or child.tagName != "attributes":
       print "ERROR: Don't know how to deal with funky child of instance attributes"
       print "Funky child: " + node2str(child)
       self=None
       return
    self.attributes = AttributesTag(child)

#
# A class for processing the <meta_attributes> tag
#
class MetaAttributesTag:
  def __init__(self, xmlnode):
    CheckXMLNodeUniqueness(xmlnode)
    self.attributes = None
    for child in xmlnode.childNodes:
      if child.nodeType != child.ELEMENT_NODE:
        continue
      if child.tagName == "attributes":
        self.attributes = AttributesTag(child)
      else:
        print "ERROR: Don't know how to deal with funky child of <%s>" % xmlnode.tagName
        print "Funky child: " + node2str(child)
        self=None
        return
    # Validate <meta_attributes> nvpairs against our metadata for meta_attributes
    MetaAttributeMetadata.validate_nvpairs(self.attributes.nvpairs)

#
# A class for processing the <cluster_property_set> tag
#
class ClusterPropertySetTag:
  def __init__(self, xmlnode):
    self.rules = []
    self.attributes = None
    CheckXMLNodeUniqueness(xmlnode)
    for child in xmlnode.childNodes:
      if child.nodeType != child.ELEMENT_NODE:
        continue
      if child.tagName == "rule":
        self.rules.append(RuleTag(child))
      if child.tagName == "attributes":
        self.attributes = AttributesTag(child)
      else:
        print "ERROR: Don't know how to deal with funky child of <%s>" % xmlnode.tagName
        print "Funky child: " + node2str(child)
        self=None
        return
    global crmMetadata
    crmMetadata.explainnondefault(self.attributes.nvpairs)
    fattr="default-resource-failure-stickiness"
    if self.attributes.nvpairs.has_key(fattr):
      if Score(self.attributes.nvpairs[fattr]) > 0:
        print "ERROR: %s should normally be negative: value is [%s]" \
	%	(fattr, Score(self.attributes.nvpairs[fattr]))
    

#
# A class for processing the <crm_config> tag
#
class CRMConfigTag:
  def __init__(self, xmlnode):
    global crm_config_section
    self.propertysets = []
    CheckAttributes(xmlnode)
    for child in xmlnode.childNodes:
      if child.nodeType != child.ELEMENT_NODE:
        continue
      if child.tagName == "cluster_property_set":
        self.propertysets.append(ClusterPropertySetTag(child))
      else:
        print "ERROR: Don't know how to deal with funky child of <%s>" % xmlnode.tagName
        print "Funky child: " + node2str(child)
        self=None
        return
    crm_config_section=self

#
# A class for processing the <nodes> tag
#
class NodesTag:
  global clusterNodes
  clusterNodes = ClusterNodes()

  def __init__(self, xmlnode):
    global clusterNodes
    CheckAttributes(xmlnode)
    children = xmlnode.childNodes
    for child in children:
      if child.nodeType != child.ELEMENT_NODE:
        continue
      if child.tagName != "node":
        print "ERROR: Don't know how to deal with funky child of <nodes>"
        print "Funky child: " + node2str(child)
        self=None
        return
      uname=child.getAttribute("uname")
      CheckAttributes(child)
      clusterNodes.addnode(child)
     
    self = clusterNodes

#
# A class for processing the <operations> tag
#
class OperationsTag(UserDict):
  def __init__(self, xmlnode):
    UserDict.__init__(self)
    self.operations = None
    self.instance_attributes = None
    CheckAttributes(xmlnode)
    children = xmlnode.childNodes
    for child in children:
      if child.nodeType != child.ELEMENT_NODE:
        continue
      if child.tagName == "op":
        CheckAttributes(child)
        CheckXMLNodeUniqueness(child)
        name = child.getAttribute("name")
        if name == "":
          print "ERROR: <op/> tag is missing name attribute"
        self[name] = child.getAttribute("id")
        if child.getAttribute("interval") != "" and name != "monitor":
          print "ERROR: repeat interval [%s] specified for operation [%s]" \
          %	(child.getAttribute("interval"), name)
        if child.getAttribute("interval") == "" and name == "monitor":
          print "WARNING: monitor operation specified without interval=\"...\""
      else:
        print "ERROR: Don't know how to deal with funky child of <%s>" % xmlnode.tagName
        print "Funky child: " + node2str(child)
        self=None
        return

global AllPrimitives, AllGroups, AllMasterSlave, AllClones
global AllResourceLocations, AllResourceCoLocations
global stonith_resource_count
AllPrimitives = {}
AllGroups = {}
AllMasterSlave = {}
AllClones = {}
AllResources = {}
AllResourceLocations = []
AllResourceCoLocations = []
stonith_resource_count = 0

#
# Base class for all of our Resource Types (PrimitiveTag, GroupTag, etc.)
#

class ResourceType:
  rtypelist={"group":AllGroups, "master_slave":AllMasterSlave, "clone":AllClones, "primitive":AllPrimitives}
  def __init__(self, xmlnode, inclone=0, ingroup=0, parent=None):
    global AllPrimitives, AllGroups, AllMasterSlave, AllClones
    self.name = xmlnode.getAttribute("id")
    self.rsctype=xmlnode.tagName
    self.inclone = inclone
    self.ingroup = ingroup
    self.parent = parent
    self.childrscs = None
    self.xmlattributes = xmlnode.attributes
    CheckXMLNodeUniqueness(xmlnode)
    if self.name.find(":") >= 0:
      print "ERROR: Cannot name a resource %s: <%s id=\"%s\">" \
      %		(self.name, xmlnode.tagName, self.name)


    id=xmlnode.getAttribute("id")

    for rtype in ResourceType.rtypelist.keys():
      if ResourceType.rtypelist[rtype].has_key(id):
        print "ERROR: A <%s> exists with the same id as this <%s id=\"%s\">"\
        %	(rtype, id, xmlnode.tagName)
    ResourceType.rtypelist[xmlnode.tagName][id] = self
    AllResources[id] = self

#
# Validate a reference to a resource
#

def ValidateResource(rscname):
    result=1
    rsplit=rscname.split(":",1)
    rname=rsplit[0]
    if not AllResources.has_key(rname):
      return 0
    if len(rsplit) > 1:
      if not AllResources[rname].inclone:
        print "ERROR: Resource [%s] referenced as [%s] is not a clone resource" \
        %		(rname, rscname)
        return 0
      elif not IntegerMetadataType.validate(rsplit[1]):
        print "ERROR: Clone number [%s] in resource name [%s] is not an integer." \
        %		(rsplit[1], rscname)
        return 0
      else:
         # FIXME - validate clone number against clone_max for clone resource
         None
    return 1
    
  
#
# A class for processing the <primitive> tag
#
class PrimitiveTag(ResourceType):
  def __init__(self, xmlnode, inclone=0, ingroup=0, parent=None):
    ResourceType.__init__(self,xmlnode, inclone=inclone, ingroup=ingroup,parent=parent)
    self.operations = None
    self.instance_attributes = []
    self.meta_attributes = []
    self.operations = []
    self.rscclass = xmlnode.getAttribute("class")
    self.provider = xmlnode.getAttribute("provider")
    self.type = xmlnode.getAttribute("type")
    if self.rscclass == "stonith":
      stonithresourcecount=stonithresourcecount+1
      if self.type=="ssh" or self.type == "external/ssh":
        print "WARNING: %s STONITH resource NOT approved for production" % (self.type)
    children = xmlnode.childNodes
    for child in children:
      if child.nodeType != child.ELEMENT_NODE:
        continue
      if child.tagName == "instance_attributes":
        iattr = InstanceAttributesTag(child)
        self.instance_attributes.append(iattr)
        metadata = metaDataCache.RAmetadata(self.rscclass, self.type, self.provider)
        if metadata != None:
          #print "Validating nvpairs for resource %s" % (self.name)
          metadata.validate_nvpairs(iattr.attributes.nvpairs)
      elif child.tagName == "meta_attributes":
        self.meta_attributes.append(MetaAttributesTag(child))
      elif child.tagName == "operations":
        self.operations.append(OperationsTag(child))
        if not self.operations[len(self.operations)-1].has_key("monitor"):
          print "INFO: monitoring not requested for resource <primitive id=\"%s\"...>" \
          %	self.name
      else:
        print "ERROR: Don't know how to deal with funky child of <%s>" % xmlnode.tagName
        print "Funky child: " + node2str(child)
        self=None
        return
    AllPrimitives[self.name]= self
    AllResources[self.name]= self
    if AllGroups.has_key(self.name):
      print "WARNING: A <group> exists with the same id as this primitive [%s]" % self.name
    if AllMasterSlave.has_key(self.name):
      print "WARNING: A <master_slave> exists with the same id as this primitive [%s]" % self.name
    if AllClones.has_key(self.name):
      print "WARNING: A <clone> exists with the same id as this primitive [%s]" % self.name


#
# A class for processing the <group> tag
#
class GroupTag(ResourceType):
  def __init__(self, xmlnode, inclone=0,ingroup=0, parent=None):
    ResourceType.__init__(self,xmlnode, inclone=inclone, ingroup=ingroup, parent=parent)
    self.childrscs = []
    children = xmlnode.childNodes
    for child in children:
      if child.nodeType != child.ELEMENT_NODE:
        continue
      if child.tagName == "primitive":
        self.childrscs.append(PrimitiveTag(child, inclone=inclone, parent=self, ingroup=1))
      else:
        print "ERROR: Don't know how to deal with funky child of <%s>" % xmlnode.tagName
        print "Funky child: " + node2str(child)
        self=None
        return

#
# A class for processing the <clone> tag
#
class CloneTag(ResourceType):
  def __init__(self, xmlnode):
    ResourceType.__init__(self,xmlnode, inclone=inclone, ingroup=ingroup, parent=parent)
    self.childrscs = []
    CheckXMLNodeUniqueness(xmlnode)
    self.name = xmlnode.getAttribute("id")
    children = xmlnode.childNodes
    for child in children:
      if child.nodeType != child.ELEMENT_NODE:
        continue
      if child.tagName == "primitive":
        self.childrscs.append(PrimitiveTag(child, inclone=1, ingroup=ingroup, parent=self))
      elif child.tagName == "group":
        self.childrscs.append(GroupTag(child, inclone=1, ingroup=ingroup, parent=self))
      else:
        print "ERROR: Don't know how to deal with funky child of <%s>" % xmlnode.tagName
        print "Funky child: " + node2str(child)
        self=None
        return

#
# A class for processing the <master_slave> tag
#
class MasterSlaveTag(ResourceType):
  def __init__(self, xmlnode):
    ResourceType.__init__(self,xmlnode, inclone=inclone, ingroup=ingroup, parent=parent)
    self.childrscs = []
    children = xmlnode.childNodes
    for child in children:
      if child.nodeType != child.ELEMENT_NODE:
        continue
      if child.tagName == "primitive":
        self.childrscs.append(PrimitiveTag(child), inclone=1, ingroup=ingroup, parent=self)
      elif child.tagName == "group":
        self.childrscs.append(GroupTag(child), inclone=1, ingroup=ingroup, parent=self)
      else:
        print "ERROR: Don't know how to deal with funky child of <%s>" % xmlnode.tagName
        print "Funky child: " + node2str(child)
        self=None
        return


#
# A class for processing the <expression> tag
#
class ExpressionTag:
  def __init__(self, xmlnode):
    global clusterNodes
    CheckXMLNodeUniqueness(xmlnode)
    if xmlnode.getAttribute("attribute") == "#uname":
      uname=xmlnode.getAttribute("value")
      if not clusterNodes.has_key(uname):
        print "ERROR: <expression attribute=\"#uname\" value=\"%s\"...> references unknown cluster node [%s]" \
	%	(uname,uname)
    if xmlnode.getAttribute("attribute") == "#id":
      id=xmlnode.getAttribute("value")
      if not clusterNodes.uuid2unamemap.has_key(id):
        print "ERROR: <expression attribute=\"#id\" value=\"%s\"...>: unknown uuid [%s]" \
	%	(id,id)
    for child in xmlnode.childNodes:
      if child.nodeType == child.ELEMENT_NODE:
        print "ERROR: Don't know how to deal with funky child of <%s>" % xmlnode.tagName
        print "Funky child: " + node2str(child)
        self=None
        return

#
# A class for processing the <rsc_colocation> tag
#
class ResourceCoLocationTag:
  def __init__(self, xmlnode):
    CheckXMLNodeUniqueness(xmlnode)
    self.name = xmlnode.getAttribute("id")
    self.fromid = xmlnode.getAttribute("from")
    self.toid = xmlnode.getAttribute("to")
    self.score = xmlnode.getAttribute("score")
    if self.fromid == "":
      print "ERROR: <rsc_colocation> tag requires 'from' attribute"
      self=None
      return
    if self.toid == "":
      print "ERROR: <rsc_colocation> tag requires 'to' attribute"
      self=None
      return
    if self.score == "":
      print "ERROR: <rsc_colocation> tag requires 'score' attribute"
      self=None
      return
    # Deal with clone references...

    if not ValidateResource(self.fromid):
      print "ERROR: <rsc_colocation from=\"%s\"...>: no such resource [%s]" \
      %		(self.fromid, fromid)
    if not ValidateResource(self.toid):
      print "ERROR: <rsc_colocation to=\"%s\"...>: no such resource [%s]" \
      %		(self.toid, toid)

    for child in xmlnode.childNodes:
      if child.nodeType == child.ELEMENT_NODE:
        print "ERROR: Don't know how to deal with funky child of <%s>" % xmlnode.tagName
        print "Funky child: " + node2str(child)
        self=None
        return
    AllResourceCoLocations.append(self)


#
# A class for processing the <rsc_location> tag
#
class ResourceLocationTag:
  def __init__(self, xmlnode):
    CheckXMLNodeUniqueness(xmlnode)
    self.rules = []
    self.name = xmlnode.getAttribute("id")
    self.rsc = xmlnode.getAttribute("rsc")
    if not AllResources.has_key(self.rsc):
      print "ERROR: <rsc_location id=\"%s\"...>: no such resource [%s]" \
      %		(self.rsc, self.rsc)

    for child in xmlnode.childNodes:
      if child.nodeType != child.ELEMENT_NODE:
        continue
      if child.tagName == "rule":
        self.rules.append(RuleTag(child))
      else:
        print "ERROR: Don't know how to deal with funky child of <%s>" % xmlnode.tagName
        print "Funky child: " + node2str(child)
        self=None
        return
    AllResourceLocations.append(self)

#
# A class for processing the <rule> tag
#
class RuleTag:
  def __init__(self, xmlnode):
    self.expressions= []
    CheckXMLNodeUniqueness(xmlnode)
    self.score = xmlnode.getAttribute("score")
    self.score_attribute = xmlnode.getAttribute("score_attribute")
    self.boolean_op = xmlnode.getAttribute("boolean_op")
    if self.score == "" and self.score_attribute == "":
      print "ERROR: <rsc_location> tag requires either 'score' or 'score_attribute'"
      self=None
      return
    if self.score != "" and self.score_attribute != "":
      print "ERROR: <rsc_location> tag allows only one of 'score' or 'score_attribute'"
   
    for child in xmlnode.childNodes:
      if child.nodeType != child.ELEMENT_NODE:
        continue
      if child.tagName == "expression":
        self.expressions.append(ExpressionTag(child))
      else:
        print "ERROR: Don't know how to deal with funky child of <%s>" % xmlnode.tagName
        print "Funky child: " + node2str(child)
        self=None
        return


def descend(xmlnode):
  if xmlnode.nodeType == xmlnode.ELEMENT_NODE:
    CheckAttributes(xmlnode)
    if xmlnode.tagName == "crm_config":
      return CRMConfigTag(xmlnode)
    if xmlnode.tagName == "cluster_property_set":
      return ClusterPropertySetTag(xmlnode)
    if xmlnode.tagName == "meta_attributes":
      return MetaAttributesTag(xmlnode)
    if xmlnode.tagName == "instance_attributes":
      return InstanceAttributesTag(xmlnode)
    if xmlnode.tagName == "attributes":
      return AttributesTag(xmlnode)
    if xmlnode.tagName == "nodes":
      return NodesTag(xmlnode)
    if xmlnode.tagName == "expression":
      return ExpressionTag(xmlnode)
    if xmlnode.tagName == "primitive":
      return PrimitiveTag(xmlnode)
    if xmlnode.tagName == "group":
      return GroupTag(xmlnode)
    if xmlnode.tagName == "master_slave":
      return MasterSlaveTag(xmlnode)
    if xmlnode.tagName == "clone":
      return CloneTag(xmlnode)
    if xmlnode.tagName == "rsc_location":
      return ResourceLocationTag(xmlnode)
    if xmlnode.tagName == "rsc_colocation":
      return ResourceCoLocationTag(xmlnode)
    #print "Element: " + xmlnode.tagName
    #mymap = xmlnode.attributes
    #if mymap != None:
    #  for key in mymap.keys():
    #    print "  xmlAttribute:", key[1]+ "="+ xmlnode.getAttribute(key)
  for child in xmlnode.childNodes:
    descend(child)

   

def analyze_CIB(doc):
  global crmMetadata
  global MetaAttributeMetadata
  global MetaAttributeMetadata_string
  crmMetadata = CRMMetadata()
  
  MetaAttributeMetadata = OCFMetadata(FromXml(MetaAttributeMetadata_string))

  global crm_config_section, stonithresourcecount
  descend(doc)
  stonithwarn=0

  stonithtag="stonith-enabled"
  enableval = crmMetadata[stonithtag].default
  stonith_enabled = MetadataValueType.BooleanStrings[enableval]

  for pset in crm_config_section.propertysets:
    if pset.attributes.nvpairs.has_key(stonithtag):
      enableval=pset.attributes.nvpairs[stonithtag]
      stonith_enabled = MetadataValueType.BooleanStrings[enableval]
  if stonith_enabled:
    if stonith_resource_count == 0:
      stonithwarn=1
      print "ERROR:  STONITH enabled, but No STONITH resources configured.  STONITH is NOT available."
  else:
    stonithwarn=1
    print "WARNING:  STONITH disabled (%s=%s).  STONITH is STRONGLY recommended."\
    %	(stonithtag, enableval)
    if stonith_resource_count == 0:
      print "WARNING:  No STONITH resources configured.  STONITH is not available."
  if stonithwarn:
    URLinfo("stonith")
    crm_config_url(stonithtag)
#
# "lint" out a CIB found in a file (pathname)
#
def examine_cib_path(cibfile):
  file = open(cibfile, "r")
  doc = FromXmlStream(file, validate=0)
  analyze_CIB(doc)
  doc=None

#
# "lint" out the live CIB
#
def examine_cib_live():
  file = os.popen(CIBADMIN + " -Q")
  doc = FromXmlStream(file, validate=0)
  file.close()
  analyze_CIB(doc)
  doc=None

#
# Explain all the CIB options in the <crm_config> section
#
def explain_crm_config():
  global crmMetadata
  crmMetadata = CRMMetadata()
  crmMetadata.explainall()

def explain_meta_attributes_config():
  global MetaAttributeMetadata, MetaAttributeMetadata_string
  MetaAttributeMetadata = OCFMetadata(FromXml(MetaAttributeMetadata_string))
  if wikiformat:
    MetaAttributeMetadata.explainall_wiki()
  else:
    MetaAttributeMetadata.explainall()

wiki_usage_message = "{{{" + usage_message + "}}}\n"


def usage():
  if wikiformat:
  	sys.stderr.write(wiki_usage_message)
  else:
  	sys.stderr.write(usage_message)


#
#	Main program starts here -- process arguments, etc.
#

if len(sys.argv) < 2:
  usage()
  sys.exit(1)

livecib=0
cibfile=0
listcrmoptions=0
listmetaattrsoptions=0
skipnext=0
usageerror=0
askforusage=0
count=0
for arg in sys.argv[1:]:
  count=count+1
  if skipnext:
    skipnext=0
    continue
  if arg == "-h" or arg == "--help" or arg == "-?":
    askforusage = 1
  elif arg == "-w" or arg == "--wiki-format":
    wikiformat = 1
  elif arg == "-C" or arg == "--ignore-non-defaults":
    note_non_default_values = 0
  elif arg == "-L" or arg == "--live-cib":
    livecib = 1
  elif arg == '-l' or arg == "--list-crm-config-options":
    listcrmoptions = 1
  elif arg == '-A' or arg == "--list-meta_attributes-config-options":
    listmetaattrsoptions=1
  elif arg == "-f":
    if count >= (len(sys.argv)-1):
      usageerror=1
    else:
      cibfile=1
      cibfilename=sys.argv[count+1]
      skipnext=1
  else:
    sys.stderr.write("invalid option: " + arg + "\n")
    usageerror=1

total=livecib+cibfile+listcrmoptions+askforusage+listmetaattrsoptions

if total > 1:
  print "ERROR: Contradictory options specified."
if usageerror or total != 1:
  usage()
  sys.exit(1)

if listcrmoptions:
  explain_crm_config()
if listmetaattrsoptions:
  explain_meta_attributes_config()
if askforusage:
  usage()
if livecib:
  examine_cib_live()
if cibfile:
  examine_cib_path(cibfilename)
sys.exit(0)
