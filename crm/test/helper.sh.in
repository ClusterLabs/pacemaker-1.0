#!/bin/bash
#
# Copyright (C) 2004 Andrew Beekhof <andrew@beekhof.net>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#

[[ $0 != *helper.sh ]] || {
	echo >&2 "helper.sh expects to be sourced!"
	exit 1
}

# no more exit below here, use return instead; gives more flexibility ...

HALIB_DIR=@libdir@/heartbeat
HAVAR_DIR=@HA_VARLIBDIR@/heartbeat
HAINIT_DIR=@INITDIR@

INIT_USER=root
CRMD_USER=root
ADMIN_USER=root

test_node_1=fish
test_node_2=chips
test_node_3=mayo

CRM_ERR_SHUTDOWN=0

OUTPUT_STDERR=0
OUTPUT_STDOUT=0
OUTPUT_CMDS=0
OUTPUT_ECHO=1

done=0

ip_rsc_1=192.168.9.161
ip_rsc_2=192.168.9.162

logfile=/var/log/messages

while test "$done" = "0"; do
    case "$1" in
	--debug   | -x)	set -x; shift;;
	--silent  | -s)	OUTPUT_ECHO=0; shift;;
	--stdout  | -o)	OUTPUT_STDOUT=1; shift;;
	--stderr  | -e)	OUTPUT_STDERR=1; shift;;
	--verbose | -v)	OUTPUT_CMDS=1; shift;;

	--logfile | -l)	logfile=${2?no logfile??}     shift 2;;

	--init    | -i)	INIT_USER=${2?no init user??} || return 1; shift 2;;
	--admin   | -a)	ADMIN_USER=${2?no admin??}    || return 1; shift 2;;
	--crmd    | -c)	CRMD_USER=${2?no crmd user??} || return 1; shift 2;;

	--node1   | -1)	test_node_1=${2?no node1??}   || return 1; shift 2;;
	--node2   | -2)	test_node_2=${2?no node2??}   || return 1; shift 2;;

	--ip1)	ip_rsc_1=${2?no ip1??}                || return 1; shift 2;;
	--ip2)	ip_rsc_2=${2?no ip2??}                || return 1; shift 2;;
 	
	""|--) done=1;;
	*) echo "unknown option: $1"; return 1;;
    esac
done

function remote_cmd() {
    user=$1
    host=$2

    shift 
    shift
    
    `which ssh` ${user}@${host} "$*"

    return $?;
}

function is_state() {
    ret=1
    host=$1
    state=$2

    output=`remote_cmd $ADMIN_USER $host $HALIB_DIR/crmadmin -S $host | grep $state`

    if [ ! -z "$output" ]; then
	echo "$host is in $state"
	return 0
    fi
    echo "$host is NOT in $state"
    return $ret
}

function is_running() {
    rsc=$1
    askhost=$2
    host=$3

    if [ -z $host ]; then
	output=`remote_cmd $ADMIN_USER $askhost $HALIB_DIR/crmadmin -W $rsc | grep -v $HALIB_DIR/crmadmin`
	output=`echo $output | grep -v NOT`
    else
	output=`remote_cmd $ADMIN_USER $askhost $HALIB_DIR/crmadmin -W $rsc | grep -v $HALIB_DIR/crmadmin`
	output=`echo $output | grep $host`
    fi

    if [ -z "$output" ]; then
	if [ -z $host ]; then
	    echo "$rsc is NOT running"
	else
	    echo "$rsc is NOT running on host $host"
	fi
	return 1
    fi

    if [ -z $host ]; then
	echo "$rsc is running"
    else
	echo "$rsc is running on host $host"
    fi

    return 0
}

function is_dc() {
    host=$1
    output=`remote_cmd $ADMIN_USER $host $HALIB_DIR/crmadmin -S $host | grep -v S_PENDING | grep -v S_NOT_DC | grep -v S_ELECTION | grep -v S_RECOVERY`

    if [ ! -z "$output" ]; then 
	echo "$host is DC"
	return 0
    fi

    echo "$host is NOT DC"

    return 1
}	

function wait_for_state() {
    state=$1
    max=$2
    host=$3
    target=$4

    sleep 1

    if [ "$host" = "DC" ]; then
	host=`remote_cmd $ADMIN_USER $target $HALIB_DIR/crmadmin -D`
	host=${host#*: }
    fi

    count=1
    until is_state $host $state; do
	if [ $count -gt $max ]; then
	    echo "Attempt to reach $state on $host failed"
	    return 1
	fi
	count=`expr $count + 1`
	sleep 1
    done
    echo "$state reached on $host"
    return 0
}


function make_node()
{
    host=$1
    uname=$2
    type=$3
    uuid=`uuidgen`
    
    if [ -z $type ]; then
	type="member"
    fi
    
    node_xml="'<node id=\"${uuid}\" uname=\"${uname}\" description=\"test node: ${uname}\" type=\"${type}\"/>'";
    
    remote_cmd $ADMIN_USER $host "$HALIB_DIR/cibadmin -C -o node -X $node_xml"

}

function make_resource()
{
    host=$1
    id=$2
    class=$3
    type=$4
    priority=$5
    version=$6

    shift 6
    
    args=$*

    uuid=`uuidgen`
    
    node_xml="'<resource id=\"${id}\" class=\"${class}\" type=\"${type}\""

    if [ ! -z $version -a "x$version" != "x-" ]; then
	node_xml="$node_xml version=${version}\""
    fi
    if [ ! -z $priority -a "x$priority" != "x-" ]; then
	node_xml="$node_xml priority=${priority}\""
    fi
    node_xml="$node_xml >";
    if [ ! -z "$args" -a "x$args" != "x-" ]; then
	node_xml="$node_xml <instance_attributes><rsc_parameters>${args}</rsc_parameters></instance_attributes>"
    fi
    node_xml="$node_xml </resource>'";
    
    remote_cmd $ADMIN_USER $host "$HALIB_DIR/cibadmin -C -o resource -X $node_xml" 2>&1 > /dev/null
}

function make_constraint_adv()
{
    host=$1
    shift
    node_xml=$*

    node_xml=`echo $node_xml | tr '\n' ' '`

    do_cmd $QUIET remote_cmd $ADMIN_USER $host "$HALIB_DIR/cibadmin -C -o constraint -X $node_xml"  2>&1 > /dev/null
}

function make_constraint()
{
    host=$1
    rsc=$2
    result=$3
    uuid1=`uuidgen`
    uuid2=`uuidgen`
    
    node_xml="'<rsc_location id=\"${uuid1}\" rsc=\"${rsc}\"><rule id=\"${uuid2}\" result=\"${result}\"/></rsc_location>'"

    make_constraint_adv $host $node_xml
}

function cts_assert() {
    do_cts_assert $? 0 "Assert failed - " $*
}

function cts_assert_false() {
    do_cts_assert $? 1 "AssertFalse failed - " $*
}

function do_cts_assert() {
    result=$1
    expected=$2
    shift
    shift

    if [ $result -ne $expected ]; then
	err $*
    fi
}

function err() {
    echo "ERROR: $*"

    if [ ! -z $HOST ]; then
	if [ $CRM_ERR_SHUTDOWN -eq 1 ]; then
	    remote_cmd hacluster $test_node_1 killall -9 crmd
	    remote_cmd hacluster $test_node_2 killall -9 crmd
	fi
    fi

    echo "test: FAILED"

    exit 1
}

function do_cmd() {

    cmdline=$*
    old_OUTPUT_STDOUT=$OUTPUT_STDOUT
    cmd=$1

    if [ $cmd = "${HALIB_DIR}/crmtest/testutils.pl" ]; then
	OUTPUT_STDOUT=1
    fi

    if [ $OUTPUT_STDERR -eq 1 -o $OUTPUT_STDOUT -eq 1 -o $OUTPUT_CMDS -eq 1 ]; then
	
	if [ $cmd = "remote_cmd" ]; then
	    user=$2
	    host=$3
	    shift 3
	    echo `date` ": Running '$*' as ${user}@${host}";

	elif [ $cmd = "wait_for_state" ]; then
	    host=$4
	    if [ -z $host ]; then
		host="the DC"
	    fi
	    echo `date` ": Waiting for state $2 on $host (max $3 attempts)";
	    
	elif [ $cmd = "${HALIB_DIR}/crmtest/testutils.pl" ]; then
	    echo `date` ": Searching '$cmdline'";
	    
	elif [ $cmd = "echo" ]; then
	    echo -n ""
#	    if [ $OUTPUT_CMDS -eq 1 -a $OUTPUT_STDOUT -eq 0 -a $OUTPUT_STDERR -eq 0  ]; then
#		echo -n `date` ": "
#		$cmdline
#	    elif [ $OUTPUT_ECHO -eq 1 -a $OUTPUT_CMDS -eq 0 -a $OUTPUT_STDOUT -eq 0 -a $OUTPUT_STDERR -eq 0  ]; then
#		$cmdline		
#	    fi
	else
	    echo `date` ": Running '$cmdline'";
	fi
    fi

    if [ $cmd = "echo" ]; then
	    if [ $OUTPUT_CMDS -eq 1 -a $OUTPUT_STDOUT -eq 0 -a $OUTPUT_STDERR -eq 0  ]; then
		echo -n `date` ": "
		echo -n -e "\033[01;33m"
		$cmdline		
#		echo -n "\[\033[01;34m\]"
		echo -n -e "\[\033[00m\]"
	    elif [ $OUTPUT_ECHO -eq 1 -a $OUTPUT_CMDS -eq 0 -a $OUTPUT_STDOUT -eq 0 -a $OUTPUT_STDERR -eq 0  ]; then
		echo -n `date` ": "
		echo -n -e "\033[01;33m"
		$cmdline		
#		echo -n "\[\033[01;34m\]"
		echo -n -e "\033[00m"
	    fi

    elif [ $OUTPUT_STDERR -eq 1 -a $OUTPUT_STDOUT -eq 1 ]; then
	$cmdline
	rc=$?
    elif [ $OUTPUT_STDERR -eq 0 -a $OUTPUT_STDOUT -eq 0 ]; then
	$cmdline 2>&1 >/dev/null
	rc=$?
    elif [ $OUTPUT_STDOUT -eq 0 ]; then
	$cmdline >/dev/null
	rc=$?
    elif [ $OUTPUT_STDERR -eq 0 ]; then
	$cmdline 2>/dev/null
	rc=$?
    else
	$cmdline
	rc=$?
    fi

    OUTPUT_STDOUT=$old_OUTPUT_STDOUT
#    echo Result: $rc
    return $rc
}

function crm-cleanup() {
    
    do_cmd echo Cleaning up on $test_node_1, $test_node_2 and  $test_node_3

# stop all running HAs
    do_cmd remote_cmd $INIT_USER $test_node_1 $HALIB_DIR/heartbeat "-k" "2>&1 >/dev/null"
    do_cmd remote_cmd $INIT_USER $test_node_2 $HALIB_DIR/heartbeat "-k" "2>&1 >/dev/null"
    do_cmd remote_cmd $INIT_USER $test_node_3 $HALIB_DIR/heartbeat "-k" "2>&1 >/dev/null"
    
# be *very* sure everything has stopped
    do_cmd remote_cmd $INIT_USER $test_node_1 "killall -q9 heartbeat ccm lrmd crmd"
    do_cmd remote_cmd $INIT_USER $test_node_2 "killall -q9 heartbeat ccm lrmd crmd"
    do_cmd remote_cmd $INIT_USER $test_node_3 "killall -q9 heartbeat ccm lrmd crmd"

# resources too
    do_cmd remote_cmd $INIT_USER $test_node_1 "/etc/ha.d/resource.d/IPaddr $ip_rsc_1 stop" 2>&1 > /dev/null
    do_cmd remote_cmd $INIT_USER $test_node_1 "/etc/ha.d/resource.d/IPaddr $ip_rsc_2 stop" 2>&1 > /dev/null
    do_cmd remote_cmd $INIT_USER $test_node_2 "/etc/ha.d/resource.d/IPaddr $ip_rsc_1 stop" 2>&1 > /dev/null
    do_cmd remote_cmd $INIT_USER $test_node_2 "/etc/ha.d/resource.d/IPaddr $ip_rsc_2 stop" 2>&1 > /dev/null
    do_cmd remote_cmd $INIT_USER $test_node_3 "/etc/ha.d/resource.d/IPaddr $ip_rsc_1 stop" 2>&1 > /dev/null
    do_cmd remote_cmd $INIT_USER $test_node_3 "/etc/ha.d/resource.d/IPaddr $ip_rsc_2 stop" 2>&1 > /dev/null
    
    if [ -z $1 ]; then
# make *sure* theres nothing left over from last time
	do_cmd remote_cmd $INIT_USER $test_node_1 "rm -f $HAVAR_DIR/crm/cib*.xml /tmp/crm/*"
	do_cmd remote_cmd $INIT_USER $test_node_2 "rm -f $HAVAR_DIR/crm/cib*.xml /tmp/crm/*"
	do_cmd remote_cmd $INIT_USER $test_node_3 "rm -f $HAVAR_DIR/crm/cib*.xml /tmp/crm/*"
    fi
}

function mark_log() 
{
    export crm_log_pos=$(stat -L -c %s $logfile)
}

# successfully sourced
true
