#! /usr/bin/perl
#
# Copyright (C) 2004 Lars Marowsky-Brée
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#

=head1 Policy Engine

This does wonders, and stuff.

Because it's wonderful, error handling ain't done yet.

=cut

use strict;
use warnings;
use heartbeat::clplumbing::ipc;
use heartbeat::clplumbing::log;
use Getopt::Std;
use Data::Dumper;
use XML::Simple qw(:strict);
use POSIX qw(setsid);
use vars qw(	$ch
		$CRM_SOCKET
		$DEBUG
		%opts
		%XMLOpts
		$VERSION
	);

{
	no warnings qw(qw);
	($VERSION) = (qw$Id: pengine,v 1.8 2004/03/18 14:25:07 lars Exp $)[2];
}

$CRM_SOCKET = "/var/lib/heartbeat/crm/crmd";
$DEBUG = 1;

%XMLOpts = (
	ContentKey => '-content',
	KeepRoot => 1,
	KeyAttr => { 'hello' => '+client_uuid' },
);

#######################################################################
cl_log_set_entity("pengine");

getopts("dhvskrS", \%opts);

if (defined($opts{'v'})) {
	print "Policy Engine $VERSION\n";
	exit 0;
}

if (defined($opts{'d'}) || defined($opts{'S'})) {
	cl_log_enable_stderr(1);
	$DEBUG++;
} else {
	cl_log_enable_stderr(0);
}

# Stand-alone debugging mode.
if (defined($opts{'S'})) {
	&handle_msgs_from_stdin();
	exit 0;
}

cl_log_set_facility("local0");
cl_log_set_logfile("/tmp/pengine.log");

cl_log('notice', "Policy Engine $VERSION starting...");

# First, connect to daddy. Yes, this sets global vars in a sub function,
# but it's documented, and there can only be one connection to the CRM
# at any given time!

&signin();

my %regs = ( hello => 0, );
while ($ch->isrconn() && $ch->iswconn()) {
	$ch->waitin();
	
	if ($ch->is_message_pending()) {
		if ($ch->status() == $IPC_CONNECT
		    || $ch->status() == $IPC_DISC_PENDING) {
			my $msg = &crm_recv_msg();
			
			if (defined($msg)) {
				my $reply = &handle_msg($msg);
				if (defined($reply)) {
					&send_crm_msg($reply);
				}
			}
		} else {
			cl_log("info", "Received disconnect event.");
			last;
		}
	} 
}

&shutdown(0, "Mainloop exited.");

#######################################################################

sub shutdown {
	my ($rc, $msg) = @_;
	
	my $log = $rc > 0 ? "err" : "info";
	cl_log($log, "Shutting down: $msg");
	if (defined($ch)) {
		cl_log($log, "Final connection status: R".$ch->isrconn().
				" W".$ch->iswconn());
	}
	exit $rc;
}

sub handle_msg {
	my ($m) = @_;
	my $reply;
	# Do magic

	if (defined($$m{'hello'})) {
		cl_log("info", "hello message received from crmd. No reply sent.");
	} elsif (defined($$m{'crm_message'})) {
		cl_log("info", "crm_message received");
		$m = $$m{'crm_message'}[0];
		my $op;
		
		if (defined($op = $$m{'options'}[0]{'operation'})) {
			if ($op eq 'ping') {
				cl_log("info", "ping_message (mostly implemented");
				$reply = &crm_ping_reply($m);
			} elsif ($op eq 'quit') {
				&shutdown(0, "Quit request received.");
			} else {
				cl_log("warn", 
					"Unknown operation requested: $op");
			}
		} else {
			cl_log('warn', "crm_message without operation request. Slacking along.");
		}
		
	} else {
		cl_log("warn", "unknown message type ignored");
	}
	
	return $reply;
}

sub crm_ping_reply {
	my ($m) = @_;
	my $reply;

	$reply = {
		crm_message => {
			version => '1',
			message_type => 'response',
			sys_from => 'pengine',
			sys_to => 'crmd',
			timestamp => time,
			options => {
				result => 'ok',
			},
			ping_item => {
				crm_subsystem => 'pengine',
				ping_status => 'running',
			},
		},
	};

	return $reply;
}

sub handle_msgs_from_stdin {
	my ($xml, $ref, $reply, $xmlout);
	while ($xml = <STDIN>) {
		$ref = &decapsulate_msg($xml);
		$reply = &handle_msg($ref);
		$xmlout = &encapsulate_msg($reply);
		print $xmlout."\n";
	}
	&shutdown(0, "EOF");
}

sub signin {
	my $rc = 0;
	
	cl_log('notice', "Connecting to crmd...");

	$ch = heartbeat::clplumbing::ipc::channel->new($CRM_SOCKET);

	if ($rc = $ch->initiate_connection() != $IPC_OK) {
		&shutdown(1, "Connection to crmd failed with $rc");
	}

	cl_log('notice', "Connection to crmd established, signing in");
	
	&send_crm_msg( { 'hello' =>
			{ 'client_uuid' => '01234567890abcdef0123456789abcdef',
			  'client_name' => 'pengine',
			  'major_version' => '1',
			  'minor_version' => '0',
			}
		      } );
}

sub encapsulate_msg {
	my ($ref) = @_;
	my $xml = XMLout($ref, 
			%XMLOpts,
			NoIndent => 1);
	# Kill all remaining annoying whitespace to make libxml2 more
	# happy. (None should be left, but paranoia rules.)
	$xml =~ s/>\s+/>/og;
	$xml =~ s/\s+</</og;
	
	return $xml;
}

sub decapsulate_msg {
	my ($xml) = @_;
	
	my $ref = XMLin($xml, 
			%XMLOpts,
			ForceArray => 1,
			ForceContent => 1,
			NormaliseSpace => 1, );
	
	print STDERR "Decapsulated message struct: "
		.Data::Dumper->Dump([$ref], [qw(m)]) if $DEBUG > 1;
	return $ref;
}

sub send_crm_msg {
	my ($ref) = @_;
	
	my $xml = &encapsulate_msg($ref);
	
	cl_log('info', "XML message we are about to sent: ".$xml) if $DEBUG; 
	
	my $msg = heartbeat::clplumbing::ipc::message->new($ch, $xml);
	
	cl_log('info', "Message constructed.");
	my $rc = $ch->send($msg);
	cl_log('info', "Message sent: $rc");
}

sub crm_recv_msg {
	cl_log('info', "Trying to receive message from crmd") if $DEBUG;
	
	my ($rc, $msg) = $ch->recv();
	
	if ($rc != $IPC_OK) {
		&shutdown(1, "Error receiving message from crmd: $rc");
	}
	
	cl_log('info', "XML message received: ".$msg->body());
	
	my $ref = &decapsulate_msg($msg->body());
	
	return $ref;
}

=head1 AUTHOR

Lars Marowsky-Bree, E<lt>lmb@suse.deE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2004 by Lars Marowsky-Bree

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

=cut


