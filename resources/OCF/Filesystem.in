#!/bin/sh
#
# $Id: Filesystem.in,v 1.11 2005/12/20 08:34:47 zhenh Exp $
#
# Support:      linux-ha@lists.linux-ha.org
# License:      GNU General Public License (GPL)
# 
# Filesystem
#      Description: Manages a Filesystem on a shared storage medium.
#  Original Author: Eric Z. Ayers (eric.ayers@compgen.com)
# Original Release: 25 Oct 2000
#
# usage: ./Filesystem {start|stop|status|monitor|validate-all|meta-data}
#
#	  OCF parameters are as below:
#		OCF_RESKEY_device
#		OCF_RESKEY_directory
#		OCF_RESKEY_fstype
#		OCF_RESKEY_options
#
#OCF_RESKEY_device    : name of block device for the filesystem. e.g. /dev/sda1, /dev/md0
#			Or a -U or -L option for mount, or an NFS mount specification
#OCF_RESKEY_directory : the mount point for the filesystem
#OCF_RESKEY_fstype    : optional name of the filesystem type. e.g. ext2
#OCF_RESKEY_options   : options to be given to the mount command via -o
#
#
# An example usage in /etc/ha.d/haresources: 
#       node1  10.0.0.170 Filesystem::/dev/sda1::/data1::ext2
#  or
#       node1  10.0.0.170 Filesystem::-Ldata1::/data1::ext2
#  or
#       node1  10.0.0.170 Filesystem::server:/data1::/data1::nfs::ro
#
# This assumes you want to manage a filesystem on a shared (scsi) bus.
# Do not put this filesystem in /etc/fstab.  This script manages all of
# that for you.
#
# If you are interested in High Availability, you will probably also want
# some sort of external hardware RAID controller in front of the actual 
# disks.  I don't mean a RAID controller embedded in the host controller -
# it has to be an external controller.
#
# It can also be an internal RAID controller if the controller supports
# failover.  IBM's ServeRAID controller does this, and it automatically
# prohibits concurrent access too, so it's pretty cool in this application.
#
# There is a script for software RAID-1 included in this directory.  Right 
# now, I wouldn't recommend using software RAID (see notes in the Raid1 script)
#
# NOTE: There is no locking (such as a SCSI reservation) being done here.
#       I would if the SCSI driver could properly maintain the reservation,
#       which it cannot, even with the 'scsi reservation' patch submitted
#       earlier this year by James Bottomley.  The patch minimizes the
#       bus resets caused by a RESERVATION_CONFLICT return, and helps the 
#       reservation stay when 2 nodes contend for a reservation, 
#       but it does not attempt to recover the reservation in the 
#       case of a bus reset.  
#
#       What all this means is that if 2 nodes mount the same file system
#       read-write, the filesystem is going to become corrupted.
#
#	As a result, you should use this together with the stonith option
#	and redundant, independent communications paths.
#
#	If you don't do this, don't blame us when you scramble your disk.
# 
#	Note:  the ServeRAID controller does prohibit concurrent acess
#	In this case, you don't actually need STONITH, but redundant comm is
#	still an excellent idea.
#

#######################################################################
# Initialization:

. @hb_libdir@/ocf-shellfuncs

#######################################################################

# Utilities used by this script
MODPROBE=@MODPROBE@
FSCK=@FSCK@
FUSER=@FUSER@
MOUNT=@MOUNT@
UMOUNT=@UMOUNT@
BLOCKDEV=@BLOCKDEV@

check_util () {
    if [ ! -x "$1" ] ; then
	ocf_log err "Setup problem: Couldn't find utility $1"
	exit $OCF_ERR_GENERIC
    fi
}

usage() {

cat <<-EOT;
	usage: $0 {start|stop|status|monitor|validate-all|meta-data}
	$Id: Filesystem.in,v 1.11 2005/12/20 08:34:47 zhenh Exp $
	EOT
}

meta_data() {
	cat <<END
<?xml version="1.0"?>
<!DOCTYPE resource-agent SYSTEM "ra-api-1.dtd">
<resource-agent name="Filesystem">
<version>1.0</version>

<longdesc lang="en">
Resource script for Filesystem. It manages a Filesystem on a shared storage medium. 
</longdesc>
<shortdesc lang="en">Filesystem resource agent</shortdesc>

<parameters>
<parameter name="device" unique="0" required="1">
<longdesc lang="en">
The name of block device for the filesystem, or -U, -L options for mount, or NFS mount specification.
</longdesc>
<shortdesc lang="en">block device</shortdesc>
<content type="string" default="" />
</parameter>

<parameter name="directory" unique="0" required="1">
<longdesc lang="en">
The mount point for the filesystem.
</longdesc>
<shortdesc lang="en">mount point</shortdesc>
<content type="string" default="" />
</parameter>

<parameter name="fstype" unique="0" required="1">
<longdesc lang="en">
The optional type of filesystem to be mounted.
</longdesc>
<shortdesc lang="en">filesystem type</shortdesc>
<content type="string" default="" />
</parameter>

<parameter name="options" unique="0">
<longdesc lang="en">
Any extra options to be given as -o options to mount.
</longdesc>
<shortdesc lang="en">options</shortdesc>
<content type="string" default="" />
</parameter>
</parameters>

<actions>
<action name="start" timeout="60" />
<action name="stop" timeout="60" />
<action name="status" depth="0" timeout="10" interval="10" start-delay="10" />
<action name="monitor" depth="0" timeout="10" interval="10" start-delay="10" />
<action name="validate-all" timeout="5" />
<action name="meta-data" timeout="5" />
</actions>
</resource-agent>
END
}

#
#	Make sure the kernel does the right thing with the FS buffers
#	This function should be called after unmounting and before mounting
#	It may not be necessary in 2.4 and later kernels, but it shouldn't hurt
#	anything either...
#
#	It's really a bug that you have to do this at all...
#
flushbufs() {
  if
    [ "$BLOCKDEV" != "" -a -x "$BLOCKDEV" ]
  then
    case $1 in
      -*|[^/]*:/*|//[^/]*/*)	# -U, -L options to mount, or NFS mount point,
				# or samba mount point	
			;;
      *)		$BLOCKDEV --flushbufs $1
			return $?
			;;
    esac
  fi
  
  return 0
}

#
# START: Start up the filesystem
#
Filesystem_start()
{
	# See if the device is already mounted.
#$MOUNT | cut -d' ' -f3 | grep -e "^$MOUNTPOINT$" >/dev/null
	Filesystem_status >/dev/null 2>&1
	if [ $? -eq $OCF_SUCCESS ] ; then
	    ocf_log info "Filesystem $MOUNTPOINT is already mounted."
	    return $OCF_SUCCESS
	fi

	# Insert SCSI module
	$MODPROBE scsi_hostadapter >/dev/null 2>&1

	if [ -z $FSTYPE ]; then
	    : No $FSTYPE specified, rely on the system has the right file-system support already 
	else
	    # Insert Filesystem module
	    $MODPROBE $FSTYPE >/dev/null 2>&1
	    grep -e "$FSTYPE"'$' /proc/filesystems >/dev/null
	    if [ $? != 0  ] ; then
		ocf_log err "Couldn't find filesystem $FSTYPE in /proc/filesystems"
		return $OCF_ERR_ARGS
	    fi
	fi

	# Check the filesystem & auto repair.  
	# NOTE: Some filesystem types don't need this step...  Please modify
	#       accordingly

    if [ $blockdevice = "yes" ]; then
	if [ ! -b "$DEVICE" ] ; then
		ocf_log err "Couldn't find device [$DEVICE]. Expected /dev/??? to exist"
		exit $OCF_ERR_ARGS
	fi

	if
	  case $FSTYPE in
	    ext3|reiserfs|xfs|jfs|vfat|fat|nfs|cifs|smbfs)	false;;
	    *)				true;;
	  esac
        then
	  ocf_log info  "Starting filesystem check on $DEVICE"
	  if [ -z $FSTYPE ]; then
		$FSCK -a $DEVICE
	  else
		$FSCK -t $FSTYPE -a $DEVICE
	  fi
	
	  # NOTE: if any errors at all are detected, it returns non-zero
	  # if the error is >= 4 then there is a big problem
	  if
	    [ $? -ge 4 ]
	  then
	    ocf_log err "Couldn't sucessfully fsck filesystem for $DEVICE"
	    return $OCF_ERR_GENERIC	
	  fi	
	fi
    fi

	if [ ! -d "$MOUNTPOINT" ] ; then
		ocf_log err "Couldn't find directory  [$MOUNTPOINT] to use as a mount point"
		exit $OCF_ERR_ARGS
	fi

	flushbufs $DEVICE
	# Mount the filesystem.
	if [ -z $FSTYPE ]; then
	  $MOUNT $options $DEVICE $MOUNTPOINT
	else
	  $MOUNT -t $FSTYPE $options $DEVICE $MOUNTPOINT
        fi

        if [ $? -ne 0 ]; then
	  ocf_log err "Couldn't mount filesystem $DEVICE on $MOUNTPOINT"
	  return $OCF_ERR_GENERIC
	fi

	return $?
}
# end of Filesystem_start

#
# STOP: Unmount the filesystem
#
Filesystem_stop()
{
	# See if the device is currently mounted
	if
		Filesystem_status >/dev/null 2>&1
	then
# By sending both signals twice, we eliminate the need for `sleep` after them
	    for sig in SIGTERM SIGTERM SIGKILL SIGKILL; do
		if [ $blockdevice = "yes" ]; then
		    $FUSER -$sig -mk $DEVICE
		else
		    $FUSER -$sig -mk $MOUNTPOINT
		fi

# fuser returns a non-zero return code if none of the specified files is
# accessed or in case of a fatal error, in either case we stop sending signal.
# If at least one access has been found, fuser returns zero, then we should
# try it again.

		if [ $? -ne 0 ]; then
		    break
		fi
	    done

	    if [ $blockdevice = "yes" ]; then
		$UMOUNT $DEVICE
		DEV=$DEVICE
	    else
		# Get the current real device name...
		# (specified devname could be -L or -U...)

		DEV=`$MOUNT | grep "on $MOUNTPOINT " | cut -d' ' -f1`
		# Unmount the filesystem
		$UMOUNT $MOUNTPOINT
	    fi
		if [ $? -ne 0 ] ; then
			ocf_log err "Couldn't unmount $MOUNTPOINT"
			return $OCF_ERR_GENERIC
		fi
		flushbufs $DEV
	else
		: $MOUNTPOINT Not mounted.  No problema!
	fi

	return $?
}
# end of Filesystem_stop

#
# STATUS: is the filesystem mounted or not?
#
Filesystem_status()
{
	if [ $blockdevice = "yes" ]; then
	    grep -q -e "^$DEVICE $MOUNTPOINT " /proc/mounts
	    rc=$?
	else	
	    grep -q -e " $MOUNTPOINT " /proc/mounts
	    rc=$?
	fi

	if [ $rc = 0 ] ; then
		ocf_log info "$MOUNTPOINT is mounted (running)"
		return $OCF_SUCCESS
	else
		ocf_log info "$MOUNTPOINT is unmounted (stopped)"
		return $OCF_NOT_RUNNING
	fi
}
# end of Filesystem_status

#
# VALIDATE_ALL: Are the instance parameters valid?
#
Filesystem_validate_all()
{
	if [ -n $MOUNTPOINT -a ! -d $MOUNTPOINT ]; then
	    ocf_log warn "Mountpoint $MOUNTPOINT does not exist"
	fi

# See if the mountpoint is already occupied.
	$MOUNT | cut -d' ' -f3 | grep -e "^$MOUNTPOINT$" >/dev/null
	if [ $? -eq 0 ] ; then
	    ocf_log info "Mountpoint $MOUNTPOINT is already used."
	fi

# Check if the $FSTYPE is workable
# NOTE: Without inserting the $FSTYPE module, this step may be imprecise
	if [ ! -z $FSTYPE ]; then
	    cut -f2 /proc/filesystems |grep -q ^$FSTYPE$
	    if [ $? -ne 0 ]; then
		modpath=/lib/modules/`uname -r` 
		moddep=$modpath/modules.dep
		# Do we have $FSTYPE in modules.dep?
		cut -d' ' -f1 $moddep |grep -q "^$modpath.*$FSTYPE\.k\?o:$"
		if [ $? -ne 0 ]; then
		    ocf_log info "It seems we do not have $FSTYPE support"
		fi
	    fi
	fi

#TODO: How to check the $options ?

	return $OCF_SUCCESS
}

# Check the arguments passed to this script
if
  [ $# -ne 1 ]
then
  usage
  exit $OCF_ERR_ARGS
fi

# Check the OCF_RESKEY_ environment variables...
DEVICE=$OCF_RESKEY_device
FSTYPE=$OCF_RESKEY_fstype
if [ ! -z "$OCF_RESKEY_options" ]; then
	options="-o $OCF_RESKEY_options"
fi

OP=$1

# These operations do not require instance parameters
case $OP in
  meta-data)		meta_data
			exit $OCF_SUCCESS
			;;
  usage)		usage
			exit $OCF_SUCCESS
			;;
esac

blockdevice=no
case $DEVICE in
  "")	ocf_log err "Please set OCF_RESKEY_device to the device to be managed"
	exit $OCF_ERR_ARGS
	;;
  -*) # Oh... An option to mount instead...  Typically -U or -L
	;;
  [^/]*:/*)	# An NFS filesystem specification...
	;;
  //[^/]*/*)	# An SMB filesystem specification...
	;;
  *)	if [ ! -b "$DEVICE"  -a "X$OP" != Xstart ] ; then
	  ocf_log warn "Couldn't find device [$DEVICE]. Expected /dev/??? to exist"
	fi
	blockdevice=yes
	;;
esac

# It is possible that OCF_RESKEY_directory has one or even multiple trailing "/".
# But the output of `mount` and /proc/mounts do not.
if [ -z $OCF_RESKEY_directory ]; then
    if [ X$OP = "Xstart" -o $blockdevice = "no" ]; then
	ocf_log err "Please specify the directory"
	exit $OCF_ERR_ARGS 
    fi
else
    MOUNTPOINT=$(echo $OCF_RESKEY_directory | sed 's/\/*$//')
    : ${MOUNTPOINT:=/}
    # At this stage, $MOUNTPOINT does not contain trailing "/" unless it is "/"
fi
	
# Check to make sure the utilites are found
check_util $MODPROBE
check_util $FSCK
check_util $FUSER
check_util $MOUNT
check_util $UMOUNT

case $OP in
  start)		Filesystem_start
			;;
  stop)			Filesystem_stop
			;;
  status|monitor)	Filesystem_status
			;;
  validate-all)		Filesystem_validate_all
			;;
  *)			usage
			exit $OCF_ERR_UNIMPLEMENTED
			;;
esac
exit $?
