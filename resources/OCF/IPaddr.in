#!/bin/sh
#
# License:      GNU General Public License (GPL) 
# Support:      linux-ha@lists.linux-ha.org
#
#	This script manages IP alias IP addresses
#
#	It can add an IP alias, or remove one.
#
#	usage: $0 {start|stop|status|monitor|validate-all|meta-data}
#
#	The "start" arg adds an IP alias.
#
#	Surprisingly, the "stop" arg removes one.	:-)
#
#       OCF parameters are as below
#       OCF_RESKEY_ip
#       OCF_RESKEY_broadcast
#       OCF_RESKEY_nic
#       OCF_RESKEY_cidr_netmask
#       OCF_RESKEY_lvs_support  ( e.g. true, on, 1 )
#       OCF_RESKEY_ARP_INTERVAL_MS
#       OCF_RESKEY_ARP_REPEAT
#       OCF_RESKEY_ARP_BACKGROUND (e.g. yes )
#       OCF_RESKEY_ARP_NETMASK
#       OCF_RESKEY_local_start_script
#       OCF_RESKEY_local_stop_script
#
#######################################################################
# Initialization:

. @hb_libdir@/ocf-shellfuncs

AWK=@AWK@
HA_VARRUNDIR=@localstatedir@/run/@HB_PKG@
IFCONFIG=@IFCONFIG@
IFCONFIG_A_OPT=@IFCONFIG_A_OPT@
SENDARP=$HA_BIN/send_arp
FINDIF=$HA_BIN/findif
VLDIR=$HA_VARRUNDIR/rsctmp/IPaddr
SENDARPPIDDIR=$HA_VARRUNDIR/rsctmp/send_arp
ROUTE=@ROUTE@
USAGE="usage: $0 {start|stop|status|monitor|validate-all|meta-data}";

#######################################################################
LC_ALL=C
export LC_ALL

HA_D=@sysconfdir@/ha.d
. ${HA_D}/shellfuncs

SYSTYPE="`uname -s`"
case "$SYSTYPE" in
    SunOS)
        # `uname -r` = 5.9 -> SYSVERSION = 9
        SYSVERSION="`uname -r | cut -d. -f 2`"
	;;
    Darwin)
	# Treat Darwin the same as the other BSD variants (matched as *BSD)
	SYSTYPE="${SYSTYPE}BSD"
	;;
    *)
        ;;
esac



meta_data() {
        cat <<END
<?xml version="1.0"?>
<!DOCTYPE resource-agent SYSTEM "ra-api-1.dtd">
<resource-agent name="IPaddr">
<version>1.0</version>
<longdesc lang="en">
This script manages IP alias IP addresses
It can add an IP alias, or remove one.
</longdesc>
<shortdesc lang="en">Manages virtual IPv4 addresses</shortdesc>

<parameters>
<parameter name="ip" unique="1" required="1">
<longdesc lang="en">
The IPv4 address to be configured in dotted quad notation, for example
"192.168.1.1".
</longdesc>
<shortdesc lang="en">IPv4 address</shortdesc>
<content type="string" default="" />
</parameter>
<parameter name="nic" unique="0">
<longdesc lang="en">
The base network interface on which the IP address will be brought
online.

If left empty, the script will try and determine this from the
routing table.

Do NOT specify an alias interface in the form eth0:1 or anything here;
rather, specify the base interface only.

</longdesc>
<shortdesc lang="en">Network interface</shortdesc>
<content type="string" default="eth0"/>
</parameter>

<parameter name="cidr_netmask">
<longdesc lang="en">
The netmask for the interface in CIDR format.
(e.g., 24 and not 255.255.255.0)

If unspecified, the script will also try to determine this from the
routing table.
</longdesc>
<shortdesc lang="en">CIDR netmask</shortdesc>
<content type="string" default=""/>
</parameter>

<parameter name="broadcast">
<longdesc lang="en">
Broadcast address associated with the IP. If left empty, the script will
determine this from the netmask.
</longdesc>
<shortdesc lang="en">Broadcast address</shortdesc>
<content type="string" default=""/>
</parameter>

<parameter name="iflabel">
<longdesc lang="en">
You can specify an additional label for your IP address here.
</longdesc>
<shortdesc lang="en">Interface label</shortdesc>
<content type="string" default=""/>
</parameter>

<parameter name="lvs_support">
<longdesc lang="en">
Enable support for LVS Direct Routing configurations. In case a IP
address is stopped, only move it to the loopback device to allow the
local node to continue to service requests, but no longer advertise it
on the network.
</longdesc>
<shortdesc lang="en">Enable support for LVS DR</shortdesc>
<content type="boolean" default="false"/>
</parameter>

<parameter name="local_stop_script">
<longdesc lang="en">
Script called when the IP is released
</longdesc>
<shortdesc lang="en">Script called when the IP is released</shortdesc>
<content type="string" default=""/>
</parameter>

<parameter name="local_start_script">
<longdesc lang="en">
Script called when the IP is added
</longdesc>
<shortdesc lang="en">Script called when the IP is added</shortdesc>
<content type="string" default=""/>
</parameter>

<parameter name="ARP_INTERVAL_MS">
<longdesc lang="en">
milliseconds between ARPs
</longdesc>
<shortdesc lang="en">milliseconds between gratuitous ARPs</shortdesc>
<content type="integer" default="500"/>
</parameter>

<parameter name="ARP_REPEAT">
<longdesc lang="en">
How many gratuitous ARPs to send out when bringing up a new address
</longdesc>
<shortdesc lang="en">repeat count</shortdesc>
<content type="integer" default="10"/>
</parameter>

<parameter name="ARP_BACKGROUND">
<longdesc lang="en">
run in background (no longer any reason to do this)
</longdesc>
<shortdesc lang="en">run in background</shortdesc>
<content type="boolean" default="yes"/>
</parameter>

<parameter name="ARP_NETMASK">
<longdesc lang="en">
netmask for ARP - in nonstandard hexadecimal format.
</longdesc>
<shortdesc lang="en">netmask for ARP</shortdesc>
<content type="string" default="ffffffffffff"/>
</parameter>

</parameters>

<actions>
<action name="start"   timeout="90" />
<action name="stop"    timeout="100" />
<action name="monitor" depth="10"  timeout="20s" interval="5s" start-delay="1s" />
<action name="validate-all"  timeout="30s" />
<action name="meta-data"  timeout="5s" />
</actions>
</resource-agent>
END
        exit $OCF_SUCCESS
}

ip_init() {
	if
          case $__OCF_ACTION in
            start|stop)		ocf_is_root;;
            *)			true;;
          esac
        then
          : YAY!
        else
		ocf_log err "You must be root for $__OCF_ACTION operation."
		exit $OCF_ERR_PERM
	fi

        #
        # $FINDIF can NOT deal with the condition of empty intermediate parameters.
        #
	if
          [ ! -z "$OCF_RESKEY_netmask" -a -z "$OCF_RESKEY_cidr_netmask" ]
        then
          OCF_RESKEY_cidr_netmask=$OCF_RESKEY_netmask
        fi
	IFCMD="$FINDIF -C $OCF_RESKEY_ip"
	if [ -n "$OCF_RESKEY_cidr_netmask" ]; then
	    IFCMD="$IFCMD/$OCF_RESKEY_cidr_netmask"
	    if [ -n "$OCF_RESKEY_nic" ]; then
		IFCMD="$IFCMD/$OCF_RESKEY_nic"
		if [ -n "$OCF_RESKEY_broadcast" ]; then
		    IFCMD="$IFCMD/$OCF_RESKEY_broadcast"
		fi
	    fi
	fi

        NICINFO=`$IFCMD`

	if [ $? -eq 0 ]; then
            OCF_RESKEY_nic=`echo "$NICINFO" | cut -f1`
	    OCF_RESKEY_cidr_netmask=`echo "$NICINFO" | cut -f2 | cut -d ' ' -f2`
	    OCF_RESKEY_broadcast=`echo "$NICINFO" | cut -f3 | cut -d ' ' -f2`
	else
	    ocf_log err "Failed: $IFCMD . Parameter error."
  	    exit $OCF_ERR_GENERIC
	fi

	LVS_SUPPORT=0
	if [ $SYSTYPE = "Linux" -o $SYSTYPE = "SunOS" ]; then
	    if [ x"${OCF_RESKEY_lvs_support}" = x"true" \
		-o x"${OCF_RESKEY_lvs_support}" = x"on" \
		-o x"${OCF_RESKEY_lvs_support}" = x"1" ]; then
		LVS_SUPPORT=1
	    fi
	fi
	
	# Set default values (can be overridden as parameters)
	: ${OCF_RESKEY_ARP_INTERVAL_MS=500}
	: ${OCF_RESKEY_ARP_REPEAT=10}
	: ${OCF_RESKEY_ARP_BACKGROUND=yes}
	: ${OCF_RESKEY_ARP_NETMASK=ffffffffffff}

        SENDARPPIDFILE="$SENDARPPIDDIR/send_arp-$OCF_RESKEY_ip"

        case $OCF_RESKEY_nic in
            *:*)
                OCF_RESKEY_nic=`echo $OCF_RESKEY_nic | sed 's/:.*//'`
                ;;
        esac

	if
	  [ -d "$VLDIR/" ] || mkdir -p "$VLDIR/"
	then
	    : Directory $VLDIR now exists
	else
	    ocf_log err "Could not create \"$VLDIR/\"."
  	    exit $OCF_ERR_GENERIC
	fi
}


#
#      Find out which alias serves the given IP address
#      The argument is an IP address, and its output
#      is an aliased interface name (e.g., "eth0:0").
#
find_interface_solaris() {
    ipaddr="$1"

    $IFCONFIG $IFCONFIG_A_OPT | $AWK '{if ($0 ~ /.*: / && NR > 1) {print "\n"$0} else {print}}' |
    while read ifname linkstuff
    do
	: ifname = $ifname
	read inet addr junk
	: inet = $inet addr = $addr
	while
	read line && [ "X$line" != "X" ]
	do
	    : Nothing
	done
	
	case $ifname in
	    *:*)	;;
	    *)	continue;;
	esac
	
    #  This doesn't look right for a box with multiple NICs.
    #  It looks like it always selects the first interface on
    #  a machine.  Yet, we appear to use the results for this case too...
	ifname=`echo "$ifname" | sed s'%:$%%'`
	
	case $addr in
	    addr:$ipaddr) echo $ifname; return $OCF_SUCCESS;;
            $ipaddr)	  echo $ifname; return $OCF_SUCCESS;;
	esac
     done
  return $OCF_ERR_GENERIC
}

#
#	Find out which alias serves the given IP address
#	The argument is an IP address, and its output
#	is an aliased interface name (e.g., "eth0:0").
#
find_interface_generic() {
    ipaddr="$1"
  $IFCONFIG $IFCONFIG_A_OPT  |
  while read ifname linkstuff
  do
    : Read gave us ifname = $ifname

    read inet addr junk
    : Read gave us inet = $inet addr = $addr

    while
      read line && [ "X$line" != "X" ]
    do
      : Nothing
    done

    case $ifname in
      *:*)	;;
      *)	continue;;
    esac


    case $SYSTYPE in
      *BSD)
		$IFCONFIG | grep "$ipaddr" -B20 | grep "UP," | tail -n 1 | cut -d ":" -f 1
		return 0;;
      *)
    		: "comparing $ipaddr to $addr (from ifconfig)"
		case $addr in
		  addr:$ipaddr)	echo $ifname; return $OCF_SUCCESS;;
		  $ipaddr)	echo $ifname; return $OCF_SUCCESS;;
    		esac
		continue;;
    esac


  done
  return $OCF_ERR_GENERIC 
}

#
#       Find out which alias serves the given IP address
#       The argument is an IP address, and its output
#       is an aliased interface name (e.g., "eth0:0").
#
find_interface() {
    ipaddr="$1"
    case $SYSTYPE in
	SunOS)
	 	NIC=`find_interface_solaris $ipaddr`
        ;;
      *)
	 	NIC=`find_interface_generic $ipaddr`
       ;;
       esac

  echo $NIC
  return $OCF_SUCCESS;
}

#
#	Find an unused interface/alias name for us to use for new IP alias
#	The argument is an IP address, and the output
#	is an aliased interface name (e.g., "eth0:0", "dc0", "le0:0").
#
find_free_interface() {
    NIC="$1"

    if [ "X$NIC" = "X" ]; then
	ocf_log err "No interface found for $OCF_RESKEY_ip"
	return $OCF_ERR_GENERIC;
    fi

  case $SYSTYPE in
	*BSD)
		echo $NIC;
		return $OCF_SUCCESS;;

	SunOS)
		IFLIST=`$IFCONFIG $IFCONFIG_A_OPT | \
			grep "^$NIC:[0-9]" | sed 's%: .*%%'`
		;;
	*)
		IFLIST=`$IFCONFIG $IFCONFIG_A_OPT | \
			grep "^$NIC:[0-9]" | sed 's% .*%%'`
		;;
  esac

  IFLIST=" `echo $IFLIST` "
  NICBASE="$VLDIR/$NIC"
  touch "$NICBASE"

  case $SYSTYPE in
       SunOS)
		j=1
		;;
	*)
		j=0
                TRYADRCNT=`ls "${NICBASE}:"* 2>/dev/null | wc -w | tr -d ' '`
		if 
		  [ -f "${NICBASE}:${TRYADRCNT}" ]
		then
		  : OK
		else
		  j="${TRYADRCNT}"
		fi
		;;
  esac

  while
     [ $j -lt 512 ]
  do
      case $IFLIST in
	  *" "$NIC:$j" "*)	;;
	  *)			
	  NICLINK="$NICBASE:$j"
	  if
	      ln "$NICBASE" "$NICLINK" 2>/dev/null
	  then
	      echo "$NIC:$j"
	      return $OCF_SUCCESS
	  fi;;
       esac
       j=`expr $j + 1`
  done
  return $OCF_ERR_GENERIC
}

#
# This routine should handle any type of interface, but has only been
# tested on ethernet-type NICs.
#
ifconfig2sendarp() {
	echo "$1" | sed "s%:%%g"
}

delete_route () {
  ipaddr="$1"

  case $SYSTYPE in
	SunOS)
		CMD=""
		;;
	*BSD)
		CMD="$ROUTE -n delete -host $ipaddr"
		;;

	*)	
		CMD="$ROUTE -n del -host $ipaddr"
		;;
  esac

  ocf_log info "$CMD"
  $CMD

  return $?
}

delete_interface () {
  ifname="$1"
  ipaddr="$2"

  case $SYSTYPE in
	SunOS)
		if [ "$SYSVERSION" -ge 8 ] ; then
		    CMD="$IFCONFIG $ifname unplumb"
		else
		    CMD="$IFCONFIG $ifname 0 down"
		fi
		;;
	*BSD)
		CMD="$IFCONFIG $ifname inet $ipaddr -alias"
		;;

	*)
		CMD="$IFCONFIG $ifname down"
		;;
  esac

  ocf_log info "$CMD"
  $CMD

  return $?
}


add_interface () {
  ipaddr="$1"
  iface_base="$2"
  iface="$3"
  netmask_bits="$4"
  netmask_text=""
  broadcast="$5"

  IFCMD="$FINDIF $ipaddr/$netmask_bits/$iface_base/$broadcast"
  NICINFO=`$IFCMD`
  
  rc=$?
  if [ $? -eq 0 ]; then
      netmask_text=`echo "$NICINFO" | cut -f2`
      broadcast=`echo "$NICINFO" | cut -f3`
  else
      echo "ERROR: $IFCMD failed (rc=$rc)"
  fi

  case $SYSTYPE in
    SunOS)
	  if [ "$SYSVERSION" -ge 8 ] ; then
	      $IFCONFIG $iface plumb
	      rc=$?
	      if [ $rc -ne 0 ] ; then
		  echo "ERROR: '$IFCONFIG $iface plumb' failed."
		  return $rc
	      fi
	  fi
	  CMD="$IFCONFIG $iface inet $ipaddr $netmask_text up"
	  ;;
      
    *BSD)
	  # netmask is always set to 255.255.255.255 for an alias 
	  CMD="$IFCONFIG $iface inet $ipaddr netmask 255.255.255.255 alias"
	  ;;
    *)		
    	  CMD="$IFCONFIG $iface $ipaddr $netmask_text $broadcast"
	  ;;
  esac

  ocf_log info "$CMD"
  $CMD
  rc=$?
  if [ $rc != 0 ]; then
      echo "ERROR: $CMD failed (rc=$rc)"
  fi

  return $rc
}

#      On Linux systems the (hidden) loopback interface may
#      conflict with the requested IP address. If so, this
#      unoriginal code will remove the offending loopback address
#      and save it in VLDIR so it can be added back in later
#      when the IPaddr is released.
#
remove_conflicting_loopback() {
	ipaddr="$1"
	ifname="$2"

	ocf_log info "Removing conflicting loopback $ifname."
	if 
	  echo $ifname > "$VLDIR/$ipaddr"
	then
	  : Saved loopback information in $VLDIR/$ipaddr
	else
	  ocf_log err "Could not save conflicting loopback $ifname." \
	  "it will not be restored."
	fi
	delete_interface "$ifname $ipaddr"
	# Forcibly remove the route (if it exists) to the loopback.
	delete_route "$ipaddr"
}

#      On Linux systems the (hidden) loopback interface may
#      need to be restored if it has been taken down previously
#      by remove_conflicting_loopback()
#
restore_loopback() {
	ipaddr="$1"

	if [ -s "$VLDIR/$ipaddr" ]; then
		ifname=`cat "$VLDIR/$ipaddr"`
		ocf_log info "Restoring loopback IP Address " \
			"$ipaddr on $ifname."
		add_interface "$ipaddr" "$ifname" "$ifname" "32"
		rm -f "$VLDIR/$ipaddr"
	fi
}

#
#	Remove the IP alias for the requested IP address...
#
ip_stop() {

  SENDARPPIDFILE="$SENDARPPIDDIR/send_arp-$OCF_RESKEY_ip"
  NIC=`find_interface $OCF_RESKEY_ip`

  if test -f "$SENDARPPIDFILE"
  then
  	cat "$SENDARPPIDFILE" | xargs kill
	rm -f "$SENDARPPIDFILE"
  fi

  case $SYSTYPE in
	*BSD)
		if $IFCONFIG $IFCONFIG_A_OPT | \
			grep "inet.*[: ]$OCF_RESKEY_ip " >/dev/null 2>&1; then
			continue;
		else
			exit $OCF_SUCCESS 
		fi;;

	Linux|SunOS)
		if [ -z "$NIC" ]; then
    			: Requested interface not in use
    			exit $OCF_SUCCESS

		elif [ ${LVS_SUPPORT} = 1 ]; then 
		    case $NIC in
			lo*)
			    : Requested interface is on loopback
			    exit $OCF_SUCCESS
			    ;;
		    esac
  		fi;;
	*)
		if [ -z "$NIC" ]; then
    			: Requested interface not in use
    			exit $OCF_SUCCESS
  		fi;;
  esac

  if [ ! -z "${OCF_RESKEY_local_stop_script}" ]; then
      if [ -x "${OCF_RESKEY_local_stop_script}" ]; then
	  ${OCF_RESKEY_local_stop_script} $*
      fi
  fi

  delete_route "$OCF_RESKEY_ip"
  delete_interface "$NIC $OCF_RESKEY_ip"
  rc=$?

  case $SYSTYPE in
	*BSD)	;;
	Linux|SunOS)
		restore_loopback "$OCF_RESKEY_ip"
		# remove lock file...
		rm -f "$VLDIR/$NIC";;
	
	*)	# remove lock file...
		rm -f "$VLDIR/$NIC";;
  esac

  case $rc in
    	0) 
		ocf_log info "IP Address $OCF_RESKEY_ip released"
		;;
    	*) 	
		ocf_log warn "IP Address $OCF_RESKEY_ip NOT released"
		;;
  esac
  return $rc
}


#
#	Add an IP alias for the requested IP address...
#
#	It could be that we already have taken it, in which case it should
#	do nothing.
#

ip_start() {
  #
  #	Do we already service this IP address?
  #
    ip_status_internal
    rc=$?

    if [ $rc = $OCF_SUCCESS ]; then
	exit $OCF_SUCCESS;
    fi
    NIC_current=`find_interface $OCF_RESKEY_ip`
    NIC_unique=`find_free_interface $OCF_RESKEY_nic`
    SENDARPPIDFILE="$SENDARPPIDDIR/send_arp-$OCF_RESKEY_ip"

    if [ -n "$NIC_unique" ]; then
  	: OK got interface [$NIC_unique] for $OCF_RESKEY_ip 
    else
  	exit $OCF_ERR_GENERIC
    fi
    
    # This logic is mostly to support LVS (If I understand it correctly)
    if [ ${LVS_SUPPORT} = 1 ]; then
       	case $NIC_unique in
	    lo*) 
		if [ x"$NIC_unique" = x"$NIC_current" ]; then
		    # Its already "running" and not moving, nothing to do.
		    ocf_log err "Could not find a non-loopback device to move $OCF_RESKEY_ip to"
		    exit $OCF_ERR_GENERIC
		fi;;
	    *)   remove_conflicting_loopback "$OCF_RESKEY_ip" "$NIC_current";;
    	esac
    fi
    if [ ! -z "${OCF_RESKEY_local_start_script}" ]; then
	if [ -x "${OCF_RESKEY_local_start_script}" ]; then
	    ${OCF_RESKEY_local_start_script} $*
	fi
    fi
    
    add_interface "$OCF_RESKEY_ip" "$OCF_RESKEY_nic" "$NIC_unique" \
		 "$OCF_RESKEY_cidr_netmask" "$OCF_RESKEY_broadcast"
    rc=$?
    if [ $rc != 0 ]; then
	return $rc
    fi
    
    TARGET_INTERFACE=`echo $NIC_unique | sed 's%:.*%%'`

    if [ $SYSTYPE = "DarwinBSD" -a "$NIC_unique" = "lo0" ]; then
	# Darwin can't send ARPs on loopback devices
	SENDARP="echo $SENDARP"
    fi

    ocf_log info "Sending Gratuitous Arp for $OCF_RESKEY_ip on $NIC_unique [$TARGET_INTERFACE]"
    
    ARGS="-i $OCF_RESKEY_ARP_INTERVAL_MS -r $OCF_RESKEY_ARP_REPEAT"
    ARGS="$ARGS -p $SENDARPPIDFILE $TARGET_INTERFACE $OCF_RESKEY_ip"
    ARGS="$ARGS auto $OCF_RESKEY_ip $OCF_RESKEY_ARP_NETMASK"
    ocf_log info "$SENDARP $ARGS"
    case $OCF_RESKEY_ARP_BACKGROUND in
	yes) ($SENDARP $ARGS || ocf_log err "Could not send gratuitous arps. rc=$?" & ) >&2 ;;
	*)   $SENDARP $ARGS || ocf_log err "Could not send gratuitous arps. rc=$?";;
    esac
    
    for i in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
    do
	ip_monitor
	if [ $? = $OCF_SUCCESS -o $? = $OCF_RUNNING_MASTER ]; then
	    return $OCF_SUCCESS
	fi
	sleep 1
    done
    return $OCF_ERR_GENERIC
}


ip_status_internal() {

    NIC=`find_interface "$OCF_RESKEY_ip"`
    if [ -z "$NIC" ]; then
	return $OCF_NOT_RUNNING
    elif [ ${LVS_SUPPORT} = 1 ]; then 
	case $NIC in
	    lo*) return $OCF_NOT_RUNNING;;
	    *)	 return $OCF_SUCCESS;;
	esac
    else
	return $OCF_SUCCESS
    fi
}

ip_status() {
    ip_status_internal
    rc=$?
    if [ $rc = $OCF_SUCCESS ]; then
	echo "running"
    elif [ $rc = $OCF_NOT_RUNNING ]; then
	echo "stopped"
    else
	echo "unknown"
    fi
    return $rc;
}

#
#	Determine if this IP address is really being served, or not.
#	Note that we must distinguish if *we're* serving it locally...
#
ip_monitor() {
  TIMEOUT=1 # seconds

  ip_status_internal
  if [ $? = $OCF_NOT_RUNNING ]; then
	return $OCF_NOT_RUNNING
  fi

  case $SYSTYPE in
        Linux)
            # -c count -t timetolive -q(uiet) -n(umeric) -W timeout
            PINGARGS="-c 1 -q -n $OCF_RESKEY_ip"
            ;;
        SunOS)
            PINGARGS="$OCF_RESKEY_ip $TIMEOUT"
            ;;
        *)
            PINGARGS="-c 1 -q $OCF_RESKEY_ip"
            ;;
  esac

  for j in 1 2 3; do
    if @PING@ $PINGARGS >/dev/null 2>&1 ; then
	return $OCF_SUCCESS
    fi
  done

  return $OCF_ERR_GENERIC
}

is_positive_integer() {
	ocf_is_decimal $1 && [ $1 -ge 1 ]
}

ip_validate_all() {
# $BASEIP, $NETMASK, $NIC and $BRDCAST have been checked within ip_init,
# do not bother here.

# No need to Check lvs_support.

  if is_positive_integer $OCF_RESKEY_ARP_INTERVAL_MS; then
	:
  else
	ocf_log err "Invalid OCF_RESKEY_ARP_INTERVAL_MS [$OCF_RESKEY_ARP_INTERVAL_MS]"
	exit $OCF_ERR_ARGS
  fi

  if is_positive_integer $OCF_RESKEY_ARP_REPEAT; then
	:
  else
	ocf_log err "Invalid OCF_RESKEY_ARP_REPEAT [$OCF_RESKEY_ARP_REPEAT]"
	exit $OCF_ERR_ARGS
  fi

# No need to check OCF_RESKEY_ARP_BACKGROUND
# No need to check OCF_RESKEY_ARP_NETMASK, since it is currently unused
# No need to check OCF_RESKEY_local_start_script and OCF_RESKEY_local_stop_script
  return $OCF_SUCCESS
}
  

usage() {
  echo $USAGE >&2
}

#
#	Add or remove IP alias for the given IP address...
#

if
  [ $# -ne 1 ]
then
  usage
  exit $OCF_ERR_ARGS
fi

  case $1 in
    info)	cat <<-!INFO
	Abstract=IP address takeover
	Argument=IP address OR IP address/broadcast address OR \\
	IP address/broadcast address/netmaskbits
	Description:
	An IPaddr resource is an IP address which is to be taken over by \\
	the owning node.
	Please rerun with the meta-data command for a list of \\
	valid arguments and their defaults.
	!INFO
	exit $OCF_SUCCESS;;
  esac

case $1 in
  start)	ip_init; ip_start ;;
  stop)	ip_init; ip_stop ;;
  status)	ip_init; ip_status ;;
  monitor)	ip_init; ip_monitor ;;
  validate-all)	ip_init; ip_validate_all;;
  meta-data)	meta_data;;
  usage)	usage; exit $OCF_SUCCESS;;
  *)		usage
 		exit $OCF_ERR_ARGS
		;;
esac
