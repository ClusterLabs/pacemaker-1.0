#!/bin/sh
#
#	$Id: IPaddr2.in,v 1.12 2005/10/18 08:20:47 sunjd Exp $
#
#       OCF Resource Agent compliant IPaddr2 script.
#
# 	Based on work by Tuomo Soini, ported to the OCF RA API by Lars
# 	Marowsky-Brée. Implements Cluster Alias IP functionality too.
#
# WARNING: Untested so far!
#
# Copyright (c) 2003 Tuomo Soini
# Copyright (c) 2004 SUSE LINUX AG, Lars Marowsky-Brée
#                    All Rights Reserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of version 2 of the GNU General Public License as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it would be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
# Further, this software is distributed without any warranty that it is
# free of the rightful claim of any third person regarding infringement
# or the like.  Any license provided herein, whether implied or
# otherwise, applies only to this software file.  Patent licenses, if
# any, provided herein do not apply to combinations of this program with
# other software, or any other product whatsoever.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write the Free Software Foundation,
# Inc., 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
#
#


# TODO: 
# - Implement Cluster IP functionality
# - There ought to be an ocf_run_cmd function which does all logging,
#   timeout handling etc for us
# - Make this the standard IP address agent on Linux; the other
#   platforms simply should ignore the additional parameters OR can use
#   the legacy heartbeat resource script...
#
#	OCF parameters are as below
#	OCF_RESKEY_ip
#	OCF_RESKEY_broadcast
#	OCF_RESKEY_nic
#	OCF_RESKEY_netmask
#	OCF_RESKEY_iflabel
#	OCF_RESKEY_mac
#	OCF_RESKEY_incarnations_max_global
#	OCF_RESKEY_incarnation_no
#	OCF_RESKEY_clusterip_hash
#	OCF_RESKEY_clusterip_mark
#	OCF_RESKEY_arp_interval
#	OCF_RESKEY_arp_count
#	OCF_RESKEY_arp_bg
#	OCF_RESKEY_arp_mac


#######################################################################
# Initialization:

. @hb_libdir@/ocf-shellfuncs

HA_VARRUNDIR=@localstatedir@/run/@HB_PKG@
IP2UTIL="@IP2UTIL@"
IPTABLES="@IPTABLES@"
MODPROBE="@MODPROBE@"
SENDARP=$HA_BIN/send_arp
FINDIF=$HA_BIN/findif
VLDIR=$HA_VARRUNDIR/rsctmp/IPaddr
SENDARPPIDDIR=$HA_VARRUNDIR/rsctmp/send_arp

#######################################################################

meta_data() {
	cat <<END
<?xml version="1.0"?>
<!DOCTYPE resource-agent SYSTEM "ra-api-1.dtd">
<resource-agent name="IPaddr2">
<version>1.0</version>
<parameters>
<parameter name="ip" unique="1">
<longdesc lang="en">
The IPv4 address to be configured in dotted quad notation, for example
"192.168.1.1".
</longdesc>
<shortdesc lang="en">IPv4 address</shortdesc>
<content type="string" default="" />
</parameter>
<parameter name="nic" unique="0">
<longdesc lang="en">
The base network interface on which the IP address will be brought
online. 

If left empty, the script will try and determine this from the
routing table.

Do NOT specify an alias interface in the form eth0:1 or anything here;
rather, specify the base interface only.

</longdesc>
<shortdesc lang="en">Network interface</shortdesc>
<content type="string" default="eth0"/>
</parameter>

<parameter name="netmask">
<longdesc lang="en">
The netmask for the interface in CIDR format.

If unspecified, the script will also try to determine this from the
routing table.
</longdesc>
<shortdesc lang="en">CIDR netmask</shortdesc>
<content type="string" default=""/>
</parameter>

<parameter name="broadcast">
<longdesc lang="en">
Broadcast address associated with the IP. If left empty, the script will
determine this from the netmask.
</longdesc>
<shortdesc lang="en">Broadcast address</shortdesc>
<content type="string" default=""/>
</parameter>

<parameter name="iflabel">
<longdesc lang="en">
You can specify an additional label for your IP address here. This label is appended to your interface name. If a label is specified in nic name, this parameter takes no effect.
</longdesc>
<shortdesc lang="en">Interface label</shortdesc>
<content type="string" default=""/>
</parameter>

<parameter name="incarnations_max_global">
<longdesc lang="en">
If you wish the IP address to be active on more than one node, set this
to the number of hash buckets you wish to use.

</longdesc>
<shortdesc lang="en">Global number of hash buckets</shortdesc>
<content type="integer" default="1"/>
</parameter>

<parameter name="incarnation_no">
<longdesc lang="en">
If you wish the IP address to be active on more than one node, set this
to the number of hash buckets you wish to maximally assign to a single
node at any given time.

0 is equivalent to unlimited.

</longdesc>
<shortdesc lang="en">Local maximum number of hash buckets</shortdesc>
<content type="integer" default="0"/>

</parameter>
<parameter name="mac">
<longdesc lang="en">
Set the interface MAC address explicitly. Currently only used in case of
the Cluster IP Alias. Leave empty to chose automatically.

</longdesc>
<shortdesc lang="en">Cluster IP MAC address</shortdesc>
<content type="string" default=""/>
</parameter>

<parameter name="clusterip_hash">
<longdesc lang="en">
Specify the hashing algorithm used for the Cluster IP functionality.

</longdesc>
<shortdesc lang="en">Cluster IP hashing function</shortdesc>
<content type="string" default="sourceip-sourceport-destport"/>
</parameter>

<parameter name="clusterip_mark">
<longdesc lang="en">
Specify the mark value used to mark the connection by CONNMARK target.

</longdesc>
<shortdesc lang="en">Mark value</shortdesc>
<content type="string" default="1"/>
</parameter>

<parameter name="arp_interval">
<longdesc lang="en">
Specify the interval between unsolicited ARP packets in milliseconds.
</longdesc>
<shortdesc lang="en">ARP packet interval in ms</shortdesc>
<content type="integer" default="200"/>
</parameter>

<parameter name="arp_count">
<longdesc lang="en">
Number of unsolicited ARP packets to send.
</longdesc>
<shortdesc lang="en">ARP packet count</shortdesc>
<content type="integer" default="5"/>
</parameter>

<parameter name="arp_bg">
<longdesc lang="en">
Whether or not to send the arp packets in the background.
</longdesc>
<shortdesc lang="en">ARP from background</shortdesc>
<content type="string" default="yes"/>
</parameter>

<parameter name="arp_mac">
<longdesc lang="en">
MAC address to send the ARP packets too.

You really shouldn't be touching this.

</longdesc>
<shortdesc lang="en">ARP MAC</shortdesc>
<content type="string" default="ffffffffffff"/>
</parameter>

</parameters>

<actions>
<action name="start"   timeout="90" />
<action name="stop"    timeout="100" />
<action name="status" depth="10"  timeout="20s" interval="10s" start-delay="5s" />
<action name="monitor" depth="10"  timeout="20s" interval="10s" start-delay="5s" />
<action name="meta-data"  timeout="5s" />
<action name="validate-all"  timeout="20s" />
</actions>
</resource-agent>
END

	exit $OCF_SUCCESS
}

is_decimal() {
# We know $1 is non-empty beforehand
    case $1 in
	*[^0-9]*) false;; #got invalid char
	*) true;;
    esac
}

ip_init() {
	if [ $UID -ne 0 ]; then
		ocf_log err "You must be root."
		exit $OCF_ERR_PERM
	fi
	
	if [ ! -x "$IP2UTIL" ]; then
		ocf_log err "iputils not installed."
		exit $OCF_ERR_INSTALLED
	fi
	
	BASEIP="$OCF_RESKEY_ip"
	BRDCAST="$OCF_RESKEY_broadcast"
	NIC="$OCF_RESKEY_nic"
	NETMASK="$OCF_RESKEY_netmask"
	IFLABEL="$OCF_RESKEY_iflabel"
	IF_MAC="$OCF_RESKEY_mac"

	IP_INC_GLOBAL=${OCF_RESKEY_incarnations_max_global:-1}
	IP_INC_NO=${OCF_RESKEY_incarnation_no:-0}
	IP_CIP_HASH="$OCF_RESKEY_clusterip_hash"
	IP_CIP_MARK=${OCF_RESKEY_clusterip_mark:-1}

	ARP_INTERVAL_MS=${OCF_RESKEY_arp_interval:-200}
	ARP_REPEAT=${OCF_RESKEY_arp_count:-5}
	ARP_BACKGROUND=${OCF_RESKEY_arp_bg:-yes}
	ARP_NETMASK=${OCF_RESKEY_arp_mac:-ffffffffffff}

	if is_decimal "$IP_INC_GLOBAL" && [ $IP_INC_GLOBAL -gt 0 ]; then
		:
	else
		ocf_log err "Invalid OCF_RESKEY_incarnations_max_global [$IP_INC_GLOBAL], should be positive integer"
		exit $OCF_ERR_ARGS
	fi

	  
	# Validation is performed in ip_validate()...

	#
	# $FINDIF can deal with the condition of empty intermediate parameters.
	#
	NICINFO=`$FINDIF -C "$BASEIP/$NETMASK/$NIC/$BRDCAST"`

	if [ $? -eq 0 ]; then
	    NICINFO=`echo $NICINFO | sed -e 's/netmask\ //;s/broadcast\ //'`
	    NIC=`echo "$NICINFO" | cut -d" " -f1`
	    NETMASK=`echo "$NICINFO" | cut -d" " -f2`
	    BRDCAST=`echo "$NICINFO" | cut -d" " -f3`
	else
	    ocf_log err "Failed: $FINDIF $BASEIP/$NETMASK/$NIC/$BRDCAST . Parameter error."
  	    exit $OCF_ERR_GENERIC
	fi
	
	SENDARPPIDFILE="$SENDARPPIDDIR/send_arp-$BASEIP"

	case $NIC in
	    *:*)
		IFLABEL=$NIC
		NIC=`echo $NIC | sed 's/:.*//'`
		;;
	    *)
		if [ -n "$IFLABEL" ]; then
			IFLABEL=${NIC}:${IFLABEL}
		fi
		;;
	esac

	IP_CIP=
	
	if [ "$IP_INC_GLOBAL" -gt 1 ]; then
		if [ ! -x "$IPTABLES" ]; then
			ocf_log err "Cluster Alias IP mode selected, but iptables not configured"
			exit $OCF_ERR_INSTALLED
		fi
		IP_CIP="yes"
		if [ -z "$IF_MAC" ]; then
			# Choose a hash.
			IF_MAC=`echo $BASEIP $NETMASK $BRDCAST | md5sum | cut -c 1-12`
			# Make it properly delimited, anything non-numeric will do, ":" and "-" are preferred.
			IF_MAC=${IF_MAC:0:2}:${IF_MAC:2:2}:${IF_MAC:4:2}:${IF_MAC:6:2}:${IF_MAC:8:2}:${IF_MAC:10:2}
			# For $IF_MAC to be a multicast Ethernet address, the first octet must be an odd number.
			case ${IF_MAC:1:1} in
				0|2|4|6|8|a|A|c|C|e|E)
				IF_MAC=${IF_MAC:0:1}1${IF_MAC:2}
				;;
			esac
		fi
		IP_CIP_FILE="/proc/net/ipt_CLUSTERIP/$BASEIP"
	fi
}

#
#	Find out which interface serves the given IP address
#	The argument is an IP address, and its output
#	is an interface name (e.g., "eth0").
#
find_interface() {
	#
	# List interfaces but exclude FreeS/WAN ipsecN virtual interfaces
	#
	local iface=`$IP2UTIL -o -f inet addr show | grep "\ $BASEIP/" \
		| cut -d ' ' -f2 | grep -v '^ipsec[0-9][0-9]*$'`
	echo $iface
	return 0
}

#
#        Delete an interface
#
delete_interface () {
	ipaddr="$1"
	iface="$2"

	CMD="$IP2UTIL -f inet addr delete $ipaddr dev $iface"

	ocf_log info "$CMD"
	$CMD

	if [ $? -ne 0 ]; then
		return $OCF_ERR_GENERIC
	fi

	CMD="$IP2UTIL -o -f inet addr show $iface"

	ocf_log info "$CMD"
	ADDR=`$CMD`

	if [ $? -ne 0 -o ! -z "$ADDR" ]; then
		return $?
	fi

	CMD="$IP2UTIL link set $iface down"

	ocf_log info "$CMD"
	$CMD
	return $?
}

#
#        Add an interface
#
add_interface () {
	ipaddr="$1"
	netmask="$2"
	broadcast="$3"
	iface="$4"
	label="$5"

	CMD="$IP2UTIL -f inet addr add $ipaddr/$netmask brd $broadcast dev $iface"

	if [ ! -z "$label" ]; then
		CMD="$CMD label $label"
	fi

	ocf_log info "$CMD"
	$CMD

	if [ $? -ne 0 ]; then
		return $OCF_ERR_GENERIC
	fi

	CMD="$IP2UTIL link set $iface up"

	ocf_log info "$CMD"
	$CMD

	return $?
}

#
#        Delete a route
#
delete_route () {
	prefix="$1"
	iface="$2"

	CMD="$IP2UTIL route delete $prefix dev $iface"

	ocf_log info "$CMD"
	$CMD

	return $?
}

#      On Linux systems the (hidden) loopback interface may
#      conflict with the requested IP address. If so, this
#      unoriginal code will remove the offending loopback address
#      and save it in VLDIR so it can be added back in later
#      when the IPaddr is released.
#
#      TODO: This is very ugly and should be controlled by an additional
#      instance parameter. Or even: multi-state, with the IP only being
#      "active" on the master!?
#
remove_conflicting_loopback() {
	ipaddr="$1"
	netmask="$2"
	broadcast="$3"
	ifname="$4"

	ocf_log info "Removing conflicting loopback $ifname."
	if [ -d "$VLDIR/" ] || mkdir -p "$VLDIR/"; then
		: Directory $VLDIR now exists
	else
		ocf_log err "Could not create \"$VLDIR/\" conflicting" \
		       " loopback $ifname cannot be restored."
	fi
	if
		echo "$ipaddr $netmask $broadcast $ifname" > "$VLDIR/$ipaddr"
	then
		: Saved loopback information in $VLDIR/$ipaddr
	else
		ocf_log err "Could not save conflicting loopback $ifname." \
		       "it will not be restored."
	fi
	delete_interface "$ipaddr" "$ifname"
	# Forcibly remove the route (if it exists) to the loopback.
	delete_route "$ipaddr" "$ifname"
}       

#
#	On Linux systems the (hidden) loopback interface may
#	need to be restored if it has been taken down previously
#	by remove_conflicting_loopback()
#
restore_loopback() {
	ipaddr="$1"

	if [ -s "$VLDIR/$ipaddr" ]; then
		ifinfo=`cat "$VLDIR/$ipaddr"`
		ocf_log info "Restoring loopback IP Address " \
		    "$ifinfo."
		add_interface $ifinfo
		rm -f "$VLDIR/$ipaddr"
	fi
}

#
# Run send_arp to note peers about new mac address
#
run_send_arp() {
	ARGS="-i $ARP_INTERVAL_MS -r $ARP_REPEAT -p $SENDARPPIDFILE $NIC $BASEIP auto $BASEIP $ARP_NETMASK"
	ocf_log info "$SENDARP $ARGS"
	case $ARP_BACKGROUND in
	yes) 
		($SENDARP $ARGS || ocf_log err "Could not send gratuitous arps" &) >&2
		;;
	*)
		$SENDARP $ARGS || ocf_log err "Could not send gratuitous arps"
		;;
	esac
}

# Do we already serve this IP address?
#
# returns:
# ok = served (for CIP: + hash bucket)
# partial = served and no hash bucket (CIP only)
# no = nothing
#
ip_served() {
	case `find_interface $BASEIP` in
	lo|"")	echo "no"
		return 0
		;;
	esac

	if [ -z "$IP_CIP" ]; then
		echo "ok"
		return 0
	fi

	if grep -q "\<${IP_INC_NO}\>" $IP_CIP_FILE ; then
		echo "ok"
		return 0
	else
		return "partial"
	fi

	exit $OCF_ERR_GENERIC
}

#######################################################################

ip_usage() {
	cat <<END
usage: $0 {start|stop|status|monitor|validate-all|meta-data}

Expects to have a fully populated OCF RA-compliant environment set.
END
}

ip_start() {
	ip_init

	#
	#	Do we already service this IP address?
	#
	local ip_status=`ip_served`

	if [ "$ip_status" = "ok" ]; then
		exit $OCF_SUCCESS
	fi
	
	if [ -n "$IP_CIP" ] && [ $ip_status = "no" ]; then
		$MODPROBE ip_tables
		$MODPROBE ip_conntrack
		$MODPROBE ipt_CLUSTERIP
		$IPTABLES -A OUTPUT -s $BASEIP -o $NIC \
				-m state --state NEW \
				-j CONNMARK --set-mark $IP_CIP_MARK
		if [ $? -ne 0 ]; then
			ocf_log err "iptables failed"
			exit $OCF_ERR_GENERIC
		fi
		$IPTABLES -I INPUT -d $BASEIP -i $NIC -j CLUSTERIP \
				--new \
				--clustermac $IF_MAC \
				--total-nodes $IP_INC_GLOBAL \
				--local-node $IP_INC_NO \
				--hashmode $IP_CIP_HASH
		if [ $? -ne 0 ]; then
			ocf_log err "iptables failed"
			exit $OCF_ERR_GENERIC
		fi
	fi

	if [ -n "$IP_CIP" ] && [ $ip_status = "partial" ]; then
		echo "+$IP_INC_NO" >$IP_CIP_FILE
	fi
	
	if [ "$ip_status" = "no" ]; then
		# TODO: Needs to be an instance parameter!
		case `find_interface $BASEIP` in
		lo)
			remove_conflicting_loopback $BASEIP 32 255.255.255.255 lo
			;;
		esac
		
		add_interface $BASEIP $NETMASK $BRDCAST $NIC $IFLABEL
		
		if [ $? -ne 0 ]; then
			ocf_log err "$CMD failed."
			exit $OCF_ERR_GENERIC
		fi
	fi

	case $NIC in
	lo*)
		: no need to run send_arp on loopback
		;;
	*)
		run_send_arp
		;;
	esac
	exit $OCF_SUCCESS
}

ip_stop() {
	ip_init
	local ip_del_if="yes"
	
	if [ -f "$SENDARPPIDFILE" ] ; then
		kill `cat "$SENDARPPIDFILE"`
		if [ $? -ne 0 ]; then
			ocf_log warn "Could not kill previously running send_arp for $BASEIP"
		else
			ocf_log info "killed previously running send_arp for $BASEIP"
			rm -f "$SENDARPPIDFILE"
		fi
	fi
	local ip_status=`ip_served`

	if [ $ip_status = "no" ]; then
		: Requested interface not in use
		exit $OCF_SUCCESS
	fi

	if [ -n "$IP_CIP" ]; then
		if [ $ip_status = "partial" ]; then
			exit $OCF_SUCCESS
		fi
		echo "-$IP_INC_NO" >$IP_CIP_FILE
		if [ "x$(cat $IP_CIP_FILE)" = "x" ]; then
			# This was the last incarnation
			$IPTABLES -D OUTPUT -s $CLUSTERIP -o $NIC \
					-m state --state NEW \
					-j CONNMARK --set-mark $IP_CIP_MARK
			$IPTABLES -D INPUT -d $BASEIP -i $NIC -j CLUSTERIP \
					--new \
					--clustermac $IF_MAC \
					--total-nodes $IP_INC_GLOBAL \
					--local-node $IP_INC_NO \
					--hashmode $IP_CIP_HASH
		else
			ip_del_if="no"		
		fi
	fi
	
	if [ "$ip_del_if" = "yes" ]; then
		delete_interface $BASEIP $NIC
		if [ $? -ne 0 ]; then
			exit $OCF_ERR_GENERIC
		fi
		
		restore_loopback "$BASEIP"
	fi

	exit $OCF_SUCCESS
}

ip_monitor() {
	ip_init
	# TODO: Implement more elaborate monitoring like checking for
	# interface health maybe via a daemon like FailSafe etc...
	case `ip_served $BASEIP` in
	ok)
		exit $OCF_SUCCESS
		;;
	partial|no)
		exit $OCF_NOT_RUNNING
		;;
	*)
		# Errors on this interface?
		exit $OCF_ERR_GENERIC
		;;
	esac
}

is_hexidecimal() {
# We know $1 is non-empty beforehand
    case $1 in
	*[^0-9a-fA-F]*) false;; #got invalid char
	*) true;;
    esac
}

is_octal() {
# We know $1 is non-empty beforehand
    case $1 in
	*[^0-7]*) false;; #got invalid char
	*) true;;
    esac
}

ip_validate() {
    ip_init

# $BASEIP, $NETMASK, $NIC , $IP_INC_GLOBAL, and $BRDCAST have been checked within ip_init,
# do not bother here.
	
    if is_decimal "$ARP_INTERVAL_MS" && [ $ARP_INTERVAL_MS -gt 0 ]; then
	:
    else
	ocf_log err "Invalid OCF_RESKEY_arp_interval [$ARP_INTERVAL_MS]"
	exit $OCF_ERR_ARGS
    fi

    if is_decimal "$ARP_REPEAT" && [ $ARP_REPEAT -gt 0 ]; then
	:
    else
	ocf_log err "Invalid OCF_RESKEY_arp_count [$ARP_REPEAT]"
	exit $OCF_ERR_ARGS
    fi

    if [ -n "$IP_CIP" ]; then

	local valid=1

	if is_decimal "$IP_INC_NO"; then
		:
	else
		ocf_log err "Invalid OCF_RESKEY_incarnation_no [$IP_INC_NO]"
		exit $OCF_ERR_ARGS
	fi
		 
	case $IP_CIP_HASH in
	sourceip|sourceip-sourceport|sourceip-sourceport-destport)
		;;
	*)
		ocf_log err "Invalid OCF_RESKEY_clusterip_hash [$IP_CIP_HASH]"
		exit $OCF_ERR_ARGS
		;;
	esac

	mark=$IP_CIP_MARK
	case $mark in
	+*|-*)
		mark=$(echo $mark | cut -c 2-)
		;;
	esac
	case $mark in
	0x*)	# hexidecimal
	  mark=$(echo $mark | cut -c 3-)
	  if [ -n "$mark" ] && is_hexidecimal "$mark"; then
		:
	  else
		valid=0
	  fi
	  ;;
	0*)	# octal
	  mark=$(echo $mark | cut -c 2-)
	  if [ -n "$mark" ] && is_octal "$mark"; then
		:
	  else
		valid=0
	  fi
	  ;;
	*)	# decimal
	  if [ -n "$mark" ] && is_decimal "$mark"; then
		:
	  else
		valid=0
	  fi
	  ;;
	esac

	if [ $valid -eq 0 ]; then
	  ocf_log err "Invalid OCF_RESKEY_clusterip_mark [$IP_CIP_MARK]"
	  exit $OCF_ERR_ARGS
	fi

	case $IF_MAC in
	??[^0-9]??[^0-9]??[^0-9]??[^0-9]??[^0-9]??)
		mac=${IF_MAC:0:2}${IF_MAC:3:2}${IF_MAC:6:2}${IF_MAC:9:2}${IF_MAC:12:2}${IF_MAC:15:2}
		if is_hexidecimal "$mac"; then
			case ${mac:1:1} in
			0|2|4|6|8|a|A|c|C|e|E)
				valid=0
				;;
			esac
		else
			valid=0
		fi
		;;
	*)
		valid=0
		;;
	esac

	if [ $valid -eq 0 ]; then
	  ocf_log err "Invalid IF_MAC [$IF_MAC]"
	  exit $OCF_ERR_ARGS
	fi

    fi

	exit $OCF_SUCCESS
}

case $__OCF_ACTION in
meta-data)	meta_data
		;;
start)		ip_start
		;;
stop)		ip_stop
		;;
status)		ip_init
		ip_status=`ip_served`
		if [ $ip_status = "ok" ]; then
			echo "running"
			exit $OCF_SUCCESS
		else
			echo "stopped"
			exit $OCF_NOT_RUNNING
		fi
		;;
monitor)	ip_monitor
		;;
validate-all)	ip_validate
		;;
usage|help)	ip_usage
		exit $OCF_SUCCESS
		;;
*)		ip_usage
		exit $OCF_ERR_UNIMPLEMENTED
		;;
esac
