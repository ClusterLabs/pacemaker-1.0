<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article
  PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<article lang="en">
   <title>Pacemaker Configuration Explained</title>
   <articleinfo>
     <author>
       <firstname>Andrew</firstname>
       <surname>Beekhof</surname>
       <email>andrew@beekhof.net</email>
       <email>pacemaker@oss.clusterlabs.org</email>
     </author>
     <revhistory>
       <revision>
         <revnumber>1.0.1</revnumber>
         <date>19 Oct 2009</date>
         <revremark>Import from PDF.</revremark>
       </revision>
     </revhistory>
   </articleinfo>
   <section/>
   <section id="about"><title>Read-Me-First</title>
     <section><title>The Scope of this Document </title>
   <para>The purpose of this document is to definitively explain the concepts used to configure Pacemaker.   To achieve this best, it will focus exclusively on the XML syntax used to configure the CIB.  </para>
   <para>For those that are allergic to XML, Pacemaker comes with a cluster shell and a Python based GUI exists, however these tools will not be covered at all in this document<footnote>
         <para> It is hoped however, that having understood the concepts explained here, that the functionality of these tools will also be more readily understood.</para>
      </footnote>, precisely because they hide the XML.   </para>
   <para>Additionally, this document is NOT a step-by-step how-to guide for configuring a specific clustering scenario.  Although such guides exist, the purpose of this document is to provide an understanding of the building blocks that can be used to construct any type of Pacemaker cluster. </para></section>
   <section><title>What Is Pacemaker?</title>
   <para>Pacemaker is a cluster resource manager.  It achieves maximum availability for your cluster services (aka. resources) by detecting and recovering from node and resource-level failures by making use of the messaging and membership capabilities provided by your preferred cluster infrastructure (either OpenAIS or Heartbeat).</para>
   <orderedlist>
      <listitem>
         <para>Pacemaker’s key features include:</para>
      </listitem>
   </orderedlist>
   <orderedlist>
      <listitem>
         <para>Detection and recovery of node and service-level failures</para>
      </listitem>
      <listitem>
         <para>Storage agnostic, no requirement for shared storage</para>
      </listitem>
      <listitem>
         <para>Resource agnostic, anything that can be scripted can be clustered</para>
      </listitem>
      <listitem>
         <para>Support for both large and small clusters</para>
      </listitem>
      <listitem>
         <para>Optionally ensure data integrity with <ulink url="http://en.wikipedia.org/wiki/STONITH">STONITH</ulink>
         </para>
      </listitem>
      <listitem>
         <para>Ability to specify cluster-wide service ordering, colocation and anti-colocation</para>
      </listitem>
      <listitem>
         <para>Support for services which need to be active on multiple nodes</para>
      </listitem>
      <listitem>
         <para>Support for services with multiple modes (eg. master/slave, primary/secondary)</para>
      </listitem>
      <listitem>
         <para>Unified, scriptable, cluster shell</para>
      </listitem>
   </orderedlist>
   <para/></section><section><title>Types of Pacemaker Clusters</title>
   <para>Pacemaker makes no assumptions about your environment, this allows it to support practically any <ulink url="http://en.wikipedia.org/wiki/High-availability_cluster#Node_configurations">redundancy configuration</ulink> including Active/Active, Active/Passive, N+1, N+M, N-to-1 and N-to-N.</para>
   <para>Two-node Active/Passive clusters using Pacemaker and DRBD are a cost-effective solution for many High Availability situations.</para>
   <para>
      <inlinegraphic fileref="embedded:graphics1" width="10cm" depth="7.5cm"/>By supporting many nodes, Pacemaker can dramatically reduce hardware costs by allowing several active/passive clusters to be combined and share a common backup node</para>
   <para>
      <inlinegraphic fileref="embedded:graphics2" width="10cm" depth="7.5cm"/> 
   </para>
   <para>When shared storage is available, every node can potentially be used for failover. Pacemaker can even run multiple copies of services to spread out the workload.</para>
   <para>
      <inlinegraphic fileref="embedded:graphics3" width="10cm" depth="7.5cm"/>
   </para></section><section><title>Pacemaker Architecture</title>
   <para>At the highest level, the cluster is made up of three pieces:</para>
   <orderedlist>
      <listitem>
         <para>Core cluster infrastructure providing messaging and membership functionality (illustrated in red)</para>
      </listitem>
      <listitem>
         <para>Non-cluster aware components (illustrated in blue).  In a Pacemaker cluster, these pieces include not only the scripts that knows how to start, stop and monitor resources, but also a local daemon that masks the differences between the different standards these scripts implement.</para>
      </listitem>
      <listitem>
         <para>A brain (illustrated in green) that processes and reacts to events from the cluster (nodes leaving or joining) and resources (eg. monitor failures) as well as configuration changes from the administrator.  In response to all of these events, Pacemaker will compute the ideal state of the cluster and plot a path to achieve it.  This may include moving resources, stopping nodes and even forcing them offline with remote power switches.</para>
      </listitem>
   </orderedlist>
   <para>
      <inlinegraphic fileref="embedded:graphics4" width="10cm" depth="7.5cm"/>Conceptual overview of the cluster stack</para>
   <para>When combined with OpenAIS, Pacemaker also supports popular open source cluster filesystems<footnote>
         <para> Even though Pacemaker also supports Heartbeat, the filesystems need to use the stack for messaging and membership and OpenAIS seems to be what they’re standardizing on.  Technically it would be possible for them to support Heartbeat as well, however there seems little interest in this.</para>
      </footnote>. Due to recent standardization in the cluster filesystem community, they make use of a common distributed lock manager which makes use of OpenAIS for its messaging capabilities and Pacemaker for its membership (which nodes are up/down) and fencing services.</para>
   <para>
      <inlinegraphic fileref="embedded:graphics5" width="10cm" depth="7.5cm"/>The Pacemaker stack when running on OpenAIS  </para><section><title>Internal Components</title>
   <para>Pacemaker itself is composed of four key components (illustrated below in the same color scheme as the previous diagram):</para>
   <orderedlist>
      <listitem>
         <para>CIB (aka. Cluster Information Base)</para>
      </listitem>
      <listitem>
         <para>CRMd (aka. Cluster Resource Management daemon)</para>
      </listitem>
      <listitem>
         <para>PEngine (aka. PE or Policy Engine)</para>
      </listitem>
      <listitem>
         <para>STONITHd</para>
      </listitem>
   </orderedlist>
   <para/>
   <para>Subsystems of a Pacemaker cluster running on OpenAIS   <inlinegraphic fileref="embedded:graphics6" width="10cm" depth="7.5cm"/>
   </para>
   <para>The CIB uses XML to represent both the cluster’s configuration and current state of all resources in the cluster.  The contents of the CIB are automatically kept in sync across the entire cluster and are used by the PEngine to compute the ideal state of the cluster and how it should be achieved.</para>
   <para>This list of instructions is then fed to the DC (Designated Co-ordinator).  Pacemaker centralizes all cluster decision making by electing one of the CRMd instances to act as a master.  Should the elected CRMd process, or the node it is on, fail... a new one is quickly established.</para>
   <para>The DC carries out the PEngine’s instructions in the required order by passing them to either the LRMd (Local Resource Management daemon) or CRMd peers on other nodes via the cluster messaging infrastructure (which in turn passes them on to their LRMd process).</para>
   <para>The peer nodes all report the results of their operations back to the DC and based on the expected and actual results, will either execute any actions that needed to wait for the previous one to complete, or abort processing and ask the PEngine to recalculate the ideal cluster state based on the unexpected results.</para>
   <para>In some cases, it may be necessary to power off nodes in order to protect shared data or complete resource recovery.  For this Pacemaker comes with STONITHd.  STONITH is an acronym for Shoot-The-Other-Node-In-The-Head and is usually implemented with a remote power switch.  In Pacemaker, STONITH devices are modeled as resources (and configured in the CIB) to enable them to be easily monitored for failure, however STONITHd takes care of understanding the STONITH topology such that its clients simply request a node be fenced and it does the rest</para>
   </section>
   </section>
   </section>
   <section id="basics"><title>Configuration Basics</title>
     <section><title>Configuration Layout</title>
   <para>The cluster is written using XML notation and divided into two main sections; configuration and status.</para>
   <para>The status section contains the history of each resource on each node and based on this data, the cluster can construct the complete current state of the cluster.   The authoritative source for the status section is the local resource manager (lrmd) process on each cluster node and the cluster will occasionally repopulate the entire section.  For this reason it is never written to disk and admin’s are advised against modifying it in any way.</para>
   <para>The configuration section contains the more traditional information like cluster options, lists of resources and indications of where they should be placed.  The configuration section is the primary focus of this document.</para>
   <para>The configuration section itself is divided into four parts:</para>
   <orderedlist>
      <listitem>
         <para>Configuration options (called crm_config)</para>
      </listitem>
      <listitem>
         <para>Nodes</para>
      </listitem>
      <listitem>
         <para>Resources</para>
      </listitem>
      <listitem>
         <para>Resource relationships (called constraints)</para>
      </listitem>
   </orderedlist>
   <para/>
   <para>&lt;cib generated="true" admin_epoch="0" epoch="0" num_updates="0" have-quorum="false"&gt;</para>
   <para>  &lt;configuration&gt;</para>
   <para>    &lt;crm_config/&gt;</para>
   <para>    &lt;nodes/&gt;</para>
   <para>    &lt;resources/&gt;</para>
   <para>    &lt;constraints/&gt;</para>
   <para>  &lt;/configuration&gt;</para>
   <para>  &lt;status/&gt;</para>
   <para>&lt;/cib&gt;</para>
   <para>An empty configuration </para></section><section><title>The Current State of the Cluster</title>
   <para>Before one starts to configure a cluster, it is worth explaining how to view the finished product.  For this purpose we have created the <command>crm_mon</command> utility that will display the current state of an active cluster.  It can show the cluster status by node or by resource and can be used in either single-shot or dynamically-updating mode.  There are also modes for displaying a list of the operations performed (grouped by node and resource) as well as information about failures. </para>
   <para>Using this tool, you can examine the state of the cluster for irregularities and see how it responds when you cause or simulate failures.</para>
   <para>Details on all the available options can be obtained using the <command>crm_mon --help</command> command.</para>
   <example>
     <title>Sample output from crm_mon</title>
     <programlisting>
       <command># crm_mon</command>
============
Last updated: Fri Nov 23 15:26:13 2007
Current DC: sles-3 (2298606a-6a8c-499a-9d25-76242f7006ec)
3 Nodes configured.
5 Resources configured.
============

Node: sles-1 (1186dc9a-324d-425a-966e-d757e693dc86): online
        192.168.100.181        (heartbeat::ocf:IPaddr):        Started sles-1
        192.168.100.182        (heartbeat:IPaddr):                Started sles-1
        192.168.100.183        (heartbeat::ocf:IPaddr):        Started sles-1
        rsc_sles-1        (heartbeat::ocf:IPaddr):        Started sles-1
        child_DoFencing:2        (stonith:external/vmware):        Started sles-1
Node: sles-2 (02fb99a8-e30e-482f-b3ad-0fb3ce27d088): standby
Node: sles-3 (2298606a-6a8c-499a-9d25-76242f7006ec): online
        rsc_sles-2        (heartbeat::ocf:IPaddr):        Started sles-3
        rsc_sles-3        (heartbeat::ocf:IPaddr):        Started sles-3
        child_DoFencing:0        (stonith:external/vmware):        Started sles-3   
     </programlisting>
   </example>
   <example>
     <title>Sample output from crm_mon -n</title>
     <programlisting>
       <command># crm_mon -n</command>
============
Last updated: Fri Nov 23 15:26:13 2007
Current DC: sles-3 (2298606a-6a8c-499a-9d25-76242f7006ec)
3 Nodes configured.
5 Resources configured.
============

Node: sles-1 (1186dc9a-324d-425a-966e-d757e693dc86): online
Node: sles-2 (02fb99a8-e30e-482f-b3ad-0fb3ce27d088): standby
Node: sles-3 (2298606a-6a8c-499a-9d25-76242f7006ec): online

Resource Group: group-1
    192.168.100.181        (heartbeat::ocf:IPaddr):        Started sles-1
    192.168.100.182        (heartbeat:IPaddr):                Started sles-1
    192.168.100.183        (heartbeat::ocf:IPaddr):        Started sles-1
rsc_sles-1        (heartbeat::ocf:IPaddr):        Started sles-1
rsc_sles-2        (heartbeat::ocf:IPaddr):        Started sles-3
rsc_sles-3        (heartbeat::ocf:IPaddr):        Started sles-3
Clone Set: DoFencing
    child_DoFencing:0        (stonith:external/vmware):        Started sles-3
    child_DoFencing:1        (stonith:external/vmware):        Stopped
    child_DoFencing:2        (stonith:external/vmware):        Started sles-1
     </programlisting>
   </example>
   <para>The DC (Designated Controller) node is where all the decisions are made and if the current DC fails a new one is elected from the remaining cluster nodes.  The choice of DC is of no significance to an administrator beyond the fact that its logs will generally be more interesting.</para></section><section><title>How Should the Configuration be Updated?</title>
   <para>There are three basic rules for updating the cluster configuration:</para>
   <orderedlist>
      <listitem>
         <para>Rule 1 - Never edit the cib.xml file manually.  Ever.  I’m not making this up.</para>
      </listitem>
      <listitem>
         <para>Rule 2 - Read Rule 1 again.</para>
      </listitem>
      <listitem>
         <para>Rule 3 - The cluster will notice if you ignored rules 1 &amp; 2 and refuse to use the configuration.</para>
      </listitem>
   </orderedlist>
   <para>Now that it is clear how NOT to update the configuration, we can begin to explain how you should.</para>
   <para>The most powerful tool for modifying the configuration is the cibadmin command which talks to a running cluster.  With cibadmin, the user can query, add, remove, update or replace any part of the configuration and all changes take effect immediately so there is no need to perform a reload-like operation.</para>
   <para>The simplest way of using cibadmin is to us it to save the current configuration to a temporary file, edit that file with your favorite text or XML editor and then upload the revised configuration.</para>
   <para>cibadmin --query &gt; tmp.xml</para>
   <para>vi tmp.xml</para>
   <para>cibadmin --replace --xml-file tmp.xml</para>
   <para>Some of the better XML editors can make use of a Relax NG schema to help make sure any changes you make are valid.  The schema describing the configuration can normally be found in /usr/lib/heartbeat/pacemaker.rng on most systems.</para>
   <para>If you only wanted to modify the resources section, you could instead do </para>
   <para>cibadmin --query --obj_type resources &gt; tmp.xml</para>
   <para>vi tmp.xml</para>
   <para>cibadmin --replace --obj_type resources --xml-file tmp.xml</para>
   <para>to avoid modifying any other part of the configuration.</para></section><section><title>Quickly Deleting Part of the Configuration</title>
   <para>Identify the object you wish to delete.  eg.</para>
   <para>sles-1:~ # cibadmin -Q | grep stonith</para>
   <para>           &lt;nvpair id="cib-bootstrap-options-stonith-action" name="stonith-action" value="reboot"/&gt;</para>
   <para>           &lt;nvpair id="cib-bootstrap-options-stonith-enabled" name="stonith-enabled" value="1"/&gt;</para>
   <para>         &lt;primitive id="child_DoFencing" class="stonith" type="external/vmware"&gt;</para>
   <para>           &lt;lrm_resource id="child_DoFencing:0" type="external/vmware" class="stonith"&gt;</para>
   <para>           &lt;lrm_resource id="child_DoFencing:0" type="external/vmware" class="stonith"&gt;</para>
   <para>           &lt;lrm_resource id="child_DoFencing:1" type="external/vmware" class="stonith"&gt;</para>
   <para>           &lt;lrm_resource id="child_DoFencing:0" type="external/vmware" class="stonith"&gt;</para>
   <para>           &lt;lrm_resource id="child_DoFencing:2" type="external/vmware" class="stonith"&gt;</para>
   <para>           &lt;lrm_resource id="child_DoFencing:0" type="external/vmware" class="stonith"&gt;</para>
   <para>           &lt;lrm_resource id="child_DoFencing:3" type="external/vmware" class="stonith"&gt;</para>
   <para/>
   <para>Next identify the resource’s tag name and id (in this case primitive and child_DoFencing).  Then simply execute: </para>
   <para>cibadmin --delete --crm_xml ‘&lt;primitive id=”child_DoFencing”/&gt;’</para></section><section><title>Updating the Configuration Without Using XML</title>
   <para>Some common tasks can also be performed with one of the higher level tools that avoid the need to read or edit XML.</para>
   <para>To enable stonith for example, one could run:</para>
   <para>crm_attribute --attr-name stonith-enabled --attr-value true</para>
   <para>Or to see if somenode is allowed to run resources, there is:</para>
   <para>crm_standby --get-value --node-uname somenode</para>
   <para>Or to find the current location of my-test-rsc one can use:</para>
   <para>crm_resource --locate --resource my-test-rsc</para></section><section><title>
      <anchor id="MakingConfigurationChangesin"/>Making Configuration Changes in a Sandbox</title>
   <para>Often it is desirable to preview the effects of a series of changes before updating the configuration atomically.  For this purpose we have created crm_shadow which creates a “shadow” copy of the configuration and arranges for all the command line tools to use it.</para>
   <para>To begin, simply invoke crm_shadow and give it the name of a configuration to create<footnote>
         <para> Shadow copies are identified with a name, making it possible to have more than one</para>
      </footnote> and be sure to follow the simple on-screen instructions.  Failure to do so could result in you updating the cluster’s active configuration!</para>
   <para> c001n01:~ # crm_shadow --create test</para>
   <para>Setting up shadow instance</para>
   <para>Type Ctrl-D to exit the crm_shadow shell</para>
   <para>shadow[test]: </para>
   <para>Creating a new sandbox</para>
   <para>shadow[test] # crm_shadow --which</para>
   <para>test</para>
   <para>Checking which shadow copy is active</para>
   <para>From this point on, all cluster commands will automatically use the shadow copy instead of talking to the cluster’s active configuration.</para>
   <para>shadow[test] # crm_failcount -G -r rsc_c001n01</para>
   <para> name=fail-count-rsc_c001n01 value=0</para>
   <para>shadow[test] # crm_standby -v on -n c001n02</para>
   <para>shadow[test] # crm_standby -G -n c001n02</para>
   <para>name=c001n02 scope=nodes value=on</para>
   <para>shadow[test] # cibadmin --erase --force</para>
   <para>shadow[test] # cibadmin --query</para>
   <para> &lt;cib cib_feature_revision="1" validate-with="pacemaker-1.0" admin_epoch="0" crm_feature_set="3.0" have-quorum="1" epoch="112" dc-uuid="c001n01" num_updates="1" cib-last-written="Fri Jun 27 12:17:10 2008"&gt;</para>
   <para>   &lt;configuration&gt;</para>
   <para>     &lt;crm_config/&gt;</para>
   <para>     &lt;nodes/&gt;</para>
   <para>     &lt;resources/&gt;</para>
   <para>     &lt;constraints/&gt;</para>
   <para>   &lt;/configuration&gt;</para>
   <para>   &lt;status/&gt;</para>
   <para> &lt;/cib&gt;</para>
   <para>Making changes to the shadow configuration</para>
   <para>Once you have finished experimenting, you can either commit the changes, or discard them as shown below.  Again, be sure to follow the on-screen instructions carefully.</para>
   <para>shadow[test] # crm_shadow --delete test --force</para>
   <para>Now type Ctrl-D to exit the crm_shadow shell</para>
   <para>shadow[test] # exit</para>
   <para>c001n01:~ # crm_shadow --which</para>
   <para>No shadow instance provided</para>
   <para>c001n01:~ # cibadmin -Q</para>
   <para> &lt;cib cib_feature_revision="1" validate-with="pacemaker-1.0" admin_epoch="0" crm_feature_set="3.0" have-quorum="1" epoch="110" dc-uuid="c001n01" num_updates="551"&gt;</para>
   <para>   &lt;configuration&gt;</para>
   <para>     &lt;crm_config&gt;</para>
   <para>       &lt;cluster_property_set id="cib-bootstrap-options"&gt;</para>
   <para>           &lt;nvpair id="cib-bootstrap-1" name="stonith-enabled" value="1"/&gt;</para>
   <para>           &lt;nvpair id="cib-bootstrap-2" name="pe-input-series-max" value="30000"/&gt;</para>
   <para>Discarding changes and verifying the real configuration is intact</para>
   <para>For a full list of crm_shadow options and command, invoke the command without any arguments.</para></section><section><title>
      <anchor id="TestingYourConfigurationChang"/>Testing Your Configuration Changes</title>
   <para>We saw previously how to make a series of changes to a “shadow” copy of the configuration.  Before loading the changes back into the cluster (eg. crm_shadow --commit mytest --force), it is often advisable to simulate the effect of the changes with ptest.  Eg.</para>
   <para>ptest --live-check -VVVVV --save-graph tmp.graph --save-dotfile tmp.dot</para>
   <para>The tool uses the same library as the live cluster to show what it would have done given the supplied input.  It’s output, in addition to a significant amount of logging, is stored in two files tmp.graph and tmp.dot, both are representations of the same thing -- the cluster’s response to your changes.  In the graph file is stored the complete transition, containing a list of all the actions, their parameters and their pre-requisites.  Because the transition graph is not terribly easy to read, the tool also generates a Graphviz dot-file representing the same information.</para>
   <para>
      <inlinegraphic fileref="embedded:graphics7" width="16cm" depth="6cm"/>An example transition graph as represented by Graphviz</para>
   <para>Interpreting the Graphviz output</para>
   <orderedlist>
      <listitem>
         <para>Arrows indicate ordering dependancies</para>
      </listitem>
      <listitem>
         <para>Dashed-arrows indicate dependancies that are not present in the transition graph</para>
      </listitem>
      <listitem>
         <para>Actions with a dashed border of any color do not form part of the transition graph</para>
      </listitem>
      <listitem>
         <para>Actions with a green border form part of the transition graph</para>
      </listitem>
      <listitem>
         <para>Actions with a red border are ones the cluster would like to execute but are unrunnable</para>
      </listitem>
      <listitem>
         <para>Actions with a blue border are ones the cluster does not feel need to be executed</para>
      </listitem>
      <listitem>
         <para>Actions with orange text are pseudo/pretend actions that the cluster uses to simplify the graph</para>
      </listitem>
      <listitem>
         <para>Actions with black text are sent to the LRM</para>
      </listitem>
      <listitem>
         <para>Resource actions have text of the form {rsc}_{action}_{interval} {node}</para>
      </listitem>
      <listitem>
         <para>Any action depending on an action with a red border will not be able to execute. </para>
      </listitem>
      <listitem>
         <para>Loops are <emphasis>really</emphasis> bad.  Please report them to the development team. </para>
      </listitem>
   </orderedlist>
   <para/>
   <para>In the above example, it appears that a new node, node2, has come online and that the cluster is checking to make sure rsc1, rsc2 and rsc3 are not already running there (Indicated by the *_monitor_0 entries).  Once it did that, and assuming the resources were not active there, it would have liked to stop rsc1 and rsc2 on node1 and move them to node2.  However, there appears to be some problem and the cluster cannot or is not permitted to perform the stop actions which implies it also cannot perform the start actions. For some reason the cluster does not want to start rsc3 anywhere.</para>
   <para>For information on the options supported by ptest, use ptest --help </para>
   <para>
      <inlinegraphic fileref="embedded:graphics8" width="16cm" depth="10.5cm"/>Another, slightly more complex, transition graph that you’re not expected to be able to read </para></section><section><title>Do I Need to Update the Configuration on all Cluster Nodes?</title>
   <para>No.  Any changes are immediately synchronized to the other active members of the cluster.</para>
   <para>To reduce bandwidth, the cluster only broadcasts the incremental updates that result from your changes and uses md5 sums to ensure that each copy is completely consistent.</para>
     </section>
   </section>
   <section id="options"><title>Cluster Options</title>
     <section><title>Special Options</title>
   <para>The reason for these fields to be placed at the top level instead of with the rest of cluster options is simply a matter of parsing.  These options are used by the configuration database which is, by design, mostly ignorant of the content it holds.  So the decision was made to place them in an easy to find location. </para><section><title>Determining Which Configuration to Use</title>
   <para>When a node joins the cluster, the cluster will perform a check to see who has the best configuration based on the fields below.  It then asks the node with the highest (admin_epoch, epoch, num_updates) tuple to replace the configuration on all the nodes - which makes setting them and setting them correctly very important.</para>
   <informaltable frame="all">
      <tgroup cols="2">
         <thead>
            <row>
               <entry>
                  <para>Field</para>
               </entry>
               <entry>
                  <para>Description</para>
               </entry>
            </row>
         </thead><tbody><row>
            <entry>
               <para>admin_epoch</para>
            </entry>
            <entry>
               <para>Never modified by the cluster.  Use this to make the configurations on any inactive nodes obsolete.</para>
               <para>Never set this value to zero, in such cases the cluster cannot tell the difference between your configuration and the “empty” one used when nothing is found on disk. </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>epoch</para>
            </entry>
            <entry>
               <para>Incremented every time the configuration is updated (usually by the admin)</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>num_updates</para>
            </entry>
            <entry>
               <para>Incremented every time the configuration or status is updated (usually by the cluster)</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section><section><title>Other Fields</title>
   <informaltable frame="all">
      <tgroup cols="2">
         <thead>
            <row>
               <entry>
                  <para>Field</para>
               </entry>
               <entry>
                  <para>Description</para>
               </entry>
            </row>
         </thead><tbody><row>
            <entry>
               <para>validate-with</para>
            </entry>
            <entry>
               <para>Determines the type of validation being done on the configuration.  If set to “none”, the cluster will not verify that updates conform the the DTD (nor reject ones that don’t).  This option can be useful when operating a mixed version cluster during an upgrade.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section><section><title>Fields Maintained by the Cluster</title>
   <informaltable frame="all">
      <tgroup cols="2">
         <thead>
            <row>
               <entry>
                  <para>Field</para>
               </entry>
               <entry>
                  <para>Description</para>
               </entry>
            </row>
         </thead><tbody><row>
            <entry>
               <para>crm-debug-origin</para>
            </entry>
            <entry>
               <para>Indicates where the last update came from.  Informational purposes only.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>cib-last-written</para>
            </entry>
            <entry>
               <para>Indicates when the configuration was last written to disk.  Informational purposes only.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>dc-uuid</para>
            </entry>
            <entry>
               <para>Indicates which cluster node is the current leader.  Used by the cluster when placing resources and determining the order of some events.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>have-quorum</para>
            </entry>
            <entry>
               <para>Indicates if the cluster has quorum.  If false, this may mean that the cluster cannot start resources or fence other nodes.  See no-quorum-policy below.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>Note that although these fields can be written to by the admin, in most cases the cluster will overwrite any values specified by the admin with the “correct” ones.  To change the admin_epoch, for example, one would use:</para>
   <para>cibadmin --modify --crm_xml ‘&lt;cib admin_epoch=”42”/&gt;’</para>
   <para/>
   <para>A complete set of fields will look something like this:</para>
   <para>&lt;cib have-quorum="true" validate-with="pacemaker-1.0" admin_epoch="1" epoch="12" num_updates="65"        dc-uuid="ea7d39f4-3b94-4cfa-ba7a-952956daabee" &gt;</para>
   <para>An example of the fields set for a cib object</para></section></section><section><title>Cluster Options</title>
   <para>Cluster options, as you’d expect, control how the cluster behaves when confronted with certain situations.</para>
   <para>They are grouped into sets and, in advanced configurations, there may be more than one.<footnote>
         <para> This will be described later in the section on <link linkend="">rules</link> where we will show how to have the cluster use different sets of options during working hours (when downtime is usually to be avoided at all costs) than it does during the weekends (when resources can be moved to the their preferred hosts without bothering end users)</para>
      </footnote> For now we will describe the simple case where each option is present at most once.</para><section><title>Available Cluster Options</title>
   <informaltable frame="all">
      <tgroup cols="3">
         <thead>
            <row>
               <entry>
                  <para>Option</para>
               </entry>
               <entry>
                  <para>Default</para>
               </entry>
               <entry>
                  <para>Description</para>
               </entry>
            </row>
         </thead><tbody><row>
            <entry>
               <para>batch-limit</para>
            </entry>
            <entry>
               <para>30</para>
            </entry>
            <entry>
               <para>The number of jobs that the TE is allowed to execute in parallell.  The "correct" value will depend on the speed and load of your network and cluster nodes.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>no-quorum-policy</para>
            </entry>
            <entry>
               <para>stop</para>
            </entry>
            <entry>
               <para>What to do when the cluster does not have quorum  Allowed values: stop, freeze, ignore, suicide.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>symmetric-cluster</para>
            </entry>
            <entry>
               <para>TRUE</para>
            </entry>
            <entry>
               <para>Can all resources run on any node by default?</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>stonith-enabled</para>
            </entry>
            <entry>
               <para>TRUE</para>
            </entry>
            <entry>
               <para>Should failed nodes and nodes with resources that can’t be stopped be shot?  If you value your data, set up a STONITH device and enable this.</para>
               <para>If true, or unset, the cluster will refuse to start resources unless one or more STONITH resources have been configured also.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>stonith-action</para>
            </entry>
            <entry>
               <para>reboot</para>
            </entry>
            <entry>
               <para>Action to send to STONITH device.  Allowed values: reboot, poweroff.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>cluster-delay</para>
            </entry>
            <entry>
               <para>60s</para>
            </entry>
            <entry>
               <para>Round trip delay over the network (excluding action execution).  The "correct" value will depend on the speed and load of your network and cluster nodes.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>stop-orphan-resources</para>
            </entry>
            <entry>
               <para>TRUE</para>
            </entry>
            <entry>
               <para>Should deleted resources be stopped</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>stop-orphan-actions</para>
            </entry>
            <entry>
               <para>TRUE</para>
            </entry>
            <entry>
               <para>Should deleted actions be cancelled</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>start-failure-is-fatal</para>
            </entry>
            <entry>
               <para>TRUE</para>
            </entry>
            <entry>
               <para>When set to FALSE, the cluster will instead use the resource's failcount and value for resource-failure-stickiness</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>pe-error-series-max</para>
            </entry>
            <entry>
               <para>-1</para>
            </entry>
            <entry>
               <para>The number of PE inputs resulting in ERRORs to save.  Used when reporting problems.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>pe-warn-series-max</para>
            </entry>
            <entry>
               <para>-1</para>
            </entry>
            <entry>
               <para>The number of PE inputs resulting in WARNINGs to save.  Used when reporting problems.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>pe-input-series-max</para>
            </entry>
            <entry>
               <para>-1</para>
            </entry>
            <entry>
               <para>The number of “normal” PE inputs to save.  Used when reporting problems.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>You can always obtain an up-to-date list of cluster options, including their default values by running the pengine metadata command.</para></section><section><title>Querying and Setting Cluster Options</title>
   <para>Cluster options can be queried and modified using the crm_attribute tool.  To get the current value of cluster-delay, simply use:</para>
   <para>crm_attribute --attr-name cluster-delay --get-value</para>
   <para>which is more simply written as</para>
   <para>crm_attribute --get-value -n cluster-delay</para>
   <para/>
   <para>If a value is found, the you’ll see a result such as this</para>
   <para>sles-1:~ # crm_attribute --get-value -n cluster-delay</para>
   <para>name=cluster-delay value=60s</para>
   <para/>
   <para>However if no value is found, the tool will display an error:</para>
   <para>sles-1:~ # crm_attribute --get-value -n clusta-deway</para>
   <para>name=clusta-deway value=(null)</para>
   <para>Error performing operation: The object/attribute does not exist</para>
   <para/>
   <para>To use a different value, eg. 30s, simply run:</para>
   <para>crm_attribute --attr-name cluster-delay --attr-value 30s</para>
   <para>To go back to the cluster’s default value, you can then delete the value with:</para>
   <para>crm_attribute --attr-name cluster-delay --delete-attr</para>
   <para/></section><section><title>When Options are Listed More Than Once</title>
   <para>If you ever see something like the following, it means that the option you’re modifying is present more than once.</para>
   <para># crm_attribute --attr-name batch-limit --delete-attr</para>
   <para>Multiple attributes match name=batch-limit in crm_config:</para>
   <para>Value: 50                 (set=cib-bootstrap-options, id=cib-bootstrap-options-batch-limit)</para>
   <para>Value: 100         (set=custom, id=custom-batch-limit)</para>
   <para>Please choose from one of the matches above and suppy the 'id' with --attr-id</para>
   <para>#</para>
   <para>Example of deleting an option that is listed twice</para>
   <para>In such cases follow the on-screen instructions to perform the requested action.  To determine which value is currently being used by the cluster, please refer to the the section on <link linkend="">rules</link>.</para>
   </section>
   </section>
   </section>
   <section id="nodes"><title>Cluster Nodes</title>
     <section><title>Defining a Cluster Node</title>
   <para>Each node in the cluster will have an entry in the nodes section containing its UUID, uname and type.</para>
   <para>   &lt;node id="1186dc9a-324d-425a-966e-d757e693dc86" uname="sles-1" type="normal"/&gt;</para>
   <para>An example of a cluster node</para>
   <para>In normal circumstances, the admin should let the cluster populate this information automatically from the communications and membership data.  However one can use the crm_uuid tool to read an existing UUID or define a value before the cluster starts.</para></section><section><title>
      <anchor id="DescribingaClusterNode"/>Describing a Cluster Node</title>
   <para>Beyond the basic definition of a node, the administrator can also describe the node’s attributes, such as how much RAM, disk, what OS or kernel version it has, perhaps even its physical location.  This information can then be used by the cluster when deciding where to place resources.  For more information on the use of node attributes, see the section on <link linkend="">Rules</link>.  </para>
   <para>Node attributes can be specified ahead of time or populated later, when the cluster is running, using the crm_attribute command.</para>
   <para>Below is what the node’s definition would look like if the admin ran the command:</para>
   <para>crm_attribute --type nodes --node-uname sles-1 --attr-name kernel --attr-value `uname -r` </para>
   <para>&lt;node uname="sles-1" type="normal" id="1186dc9a-324d-425a-966e-d757e693dc86"&gt;</para>
   <para>  &lt;instance_attributes id="nodes-1186dc9a-324d-425a-966e-d757e693dc86"&gt;</para>
   <para>      &lt;nvpair id="kernel-1186dc9a-324d-425a-966e-d757e693dc86" name="kernel" value="2.6.16.46-0.4-default"/&gt;</para>
   <para>  &lt;/instance_attributes&gt;</para>
   <para>&lt;/node&gt;</para>
   <para>The result of using crm_attribute to specify which kernel sles-1 is running</para>
   <para>A simpler way to determine the current value of an attribute is to use crm_attribute command again:</para>
   <para>crm_attribute --type nodes --node-uname sles-1 --attr-name kernel --get-value</para>
   <para/>
   <para>By specifying --type nodes the admin tells the cluster that this attribute is persistent.  There are also transient attributes which are kept in the status section which are “forgotten” whenever the node rejoins the cluster.  The cluster uses this area to store a record of how many times a resource has failed on that node but administrators can also read and write to this section by specifying --type status.</para></section><section><title>Adding a New Cluster Node</title><section><title>OpenAIS</title>
   <para>Adding a new is as simple as installing OpenAIS and Pacemaker, and copying /etc/ais/openais.conf and /etc/ais/authkey (if it exists) from an existing node.  You may need to modify the mcastaddr option to match the new node’s IP address.</para>
   <para>If a log message containing "Invalid digest" appears from OpenAIS, the keys are not consistent between the machines.</para></section><section><title>Heartbeat</title>
   <para>Provided you specified autojoin any in ha.cf, adding a new is as simple as installing heartbeat and copying ha.cf and authkeys from an existing node.</para>
   <para>If not, then after setting up ha.cf and authkeys, you must use the hb_addnode command before starting the new node. </para></section></section><section><title>Removing a Cluster Node</title><section><title>OpenAIS</title>
   <para>TBA</para></section><section><title>Heartbeat</title>
   <para>Because the messaging and membership layers are the authoritative source for cluster nodes, deleting them from the CIB is not a reliable solution.  First one must arrange for heartbeat to forget about the node (sles-1 in the example below).  To do this, shut down heartbeat on the node and then, from one of the remaining active cluster nodes, run:</para>
   <para>hb_delnode sles-1</para>
   <para>Only then is it safe to delete the node from the CIB with:</para>
   <para>cibadmin --delete --obj_type nodes --crm_xml ‘&lt;node uname=”sles-1”/&gt;’</para>
   <para>cibadmin --delete --obj_type status --crm_xml ‘&lt;node_status uname=”sles-1”/&gt;’</para></section></section><section><title>Replacing a Cluster Node</title><section><title>OpenAIS</title>
   <para>The five-step guide to replacing an existing cluster node:</para>
   <orderedlist>
      <listitem>
         <para>Make sure the old node is completely stopped</para>
      </listitem>
      <listitem>
         <para>Give the new machine the same hostname and IP address as the old one</para>
      </listitem>
      <listitem>
         <para>Install the cluster software:)</para>
      </listitem>
      <listitem>
         <para/>
      </listitem>
      <listitem>
         <para>Copy /etc/ais/openais.conf and /etc/ais/authkey (if it exists) to the new node</para>
      </listitem>
      <listitem>
         <para>Start the new cluster node</para>
      </listitem>
   </orderedlist>
   <para>If a log message containing "Invalid digest" appears from OpenAIS, the keys are not consistent between the machines.</para></section><section><title>Heartbeat</title>
   <para>The seven-step guide to replacing an existing cluster node:</para>
   <orderedlist>
      <listitem>
         <para>Make sure the old node is completely stopped</para>
      </listitem>
      <listitem>
         <para>Give the new machine the same hostname as the old one</para>
      </listitem>
      <listitem>
         <para>Go to an active cluster node and look up the UUID for the old node in /var/lib/heartbeat/hostcache</para>
      </listitem>
      <listitem>
         <para>Install the cluster software</para>
      </listitem>
      <listitem>
         <para>Copy ha.cf and authkeys to the new node</para>
      </listitem>
      <listitem>
         <para>On the new node, populate it’s UUID using crm_uuid -w and the UUID from step 2</para>
      </listitem>
      <listitem>
         <para>Start the new cluster node</para>
      </listitem>
   </orderedlist>
       </section>
     </section>
   </section>
   <section id="resources">
     <anchor id="ClusterResources"/>
     <title>Cluster Resources</title>
     <section><title>What is a Cluster Resource</title>
   <para>The role of a resource agent is to abstract the service it provides and present a consistent view to the cluster, which allows the cluster to be agnostic about the resources it manages.  The cluster doesn’t need to understand how the resource works because it relies on the resource agent to do the right thing when given a start, stop or monitor command.</para>
   <para>For this reason it is crucial that resource agents are well tested. </para>
   <para>Typically resource agents come in the form of shell scripts, however they can be written using any technology (such as C, Python or Perl) that the author is comfortable with.</para></section><section><title>Supported Resource Classes</title>
   <para>There are three basic classes of agents supported by Pacemaker. In order of encouraged usage they are:</para><section><title>Open Cluster Framework</title>
   <para>The OCF Spec (as it relates to resource agents can be found at: <ulink url="http://www.opencf.org/cgi-bin/viewcvs.cgi/specs/ra/resource-agent-api.txt?rev=HEAD">http://www.opencf.org/cgi-bin/viewcvs.cgi/specs/ra/resource-agent-api.txt?rev=HEAD</ulink> 
      <footnote>
         <para> Note: The Pacemaker implementation has been somewhat extended from the OCF Specs, but none of those changes are incompatible with the original OCF specification</para>
      </footnote> and is basically an extension of the Linux Standard Base conventions for init scripts to</para>
   <orderedlist>
      <listitem>
         <para>support parameters</para>
      </listitem>
      <listitem>
         <para>make them self describing, and</para>
      </listitem>
      <listitem>
         <para>extendable</para>
      </listitem>
   </orderedlist>
   <para/>
   <para>OCF specs have strict definitions of what exit codes actions must return<footnote>
         <para> Included with the cluster is the ocf-tester script which can be useful in this regard.</para>
      </footnote>. The cluster follows these specifications exactly, and exiting with the wrong exit code will cause the cluster to behave in ways you will likely find puzzling and annoying. In particular, the cluster needs to distinguish a completely stopped resource from one which is in some erroneous and indeterminate state.</para>
   <para>Parameters are passed to the script as environment variables, with the special prefix OCF_RESKEY_. So, if you need to be given a parameter which the user thinks of as ip it will be passed to the script as OCF_RESKEY_ip.  The number and purpose of the parameters is completely arbitrary, however your script should advertise any that it supports using the meta-data command.</para>
   <para>For more information, see <ulink url="http://wiki.linux-ha.org/OCFResourceAgent">http://wiki.linux-ha.org/OCFResourceAgent</ulink> and <link linkend="">What Do I need to Know When Writing an OCF Resource Agent</link> in the FAQ section.</para></section><section><title>Linux Standard Base</title>
   <para>LSB resource agents are those found in /etc/init.d. Generally they are provided by the OS/distribution and in order to be used with the cluster, must conform to the LSB Spec.</para>
   <para>The LSB Spec (as it relates to init scripts) can be found at: <ulink url="http://refspecs.linux-foundation.org/LSB_3.0.0/LSB-Core-generic/LSB-Core-generic/iniscrptact.html">http://refspecs.linux-foundation.org/LSB_3.0.0/LSB-Core-generic/LSB-Core-generic/iniscrptact.html</ulink>
   </para>
   <para>Many distributions claim LSB compliance but ship with broken init scripts. To see if your init script is LSB-compatible, see the FAQ entry <link linkend="">How Can I Tell if an Init Script is LSB Compatible</link>.  The most common problems are:</para>
   <orderedlist>
      <listitem>
         <para>Not implementing the status operation at all</para>
      </listitem>
      <listitem>
         <para>Not observing the correct exit status codes for start/stop/status actions</para>
      </listitem>
      <listitem>
         <para>Starting a started resource returns an error (this violates the LSB spec)</para>
      </listitem>
      <listitem>
         <para>Stopping a stopped resource returns an error (this violates the LSB spec)</para>
      </listitem>
   </orderedlist>
   <para/></section><section><title>Legacy Heartbeat</title>
   <para>Version 1 of Heartbeat came with its own style of resource agents and it is highly likely that many people have written their own agents based on its conventions.  To enable administrators to continue to use these agents, they are supported by the new cluster manager.</para>
   <para>For more information, see: <ulink url="http://wiki.linux-ha.org/HeartbeatResourceAgent">http://wiki.linux-ha.org/HeartbeatResourceAgent</ulink>
   </para>
   <para/>
   <para>The OCF class is the most preferred one as it is an industry standard, highly flexible (allowing parameters to be passed to agents in a non-positional manner) and self-describing.</para>
   <para>There is also an additional class, STONITH, which is used exclusively for fencing related resources.  This is discussed later in the section on <link linkend="">fencing</link>.</para></section></section><section><title>Properties</title>
   <para>These values tell the cluster which script to use for the resource, where to find that script and what standards it conforms to.</para>
   <informaltable frame="all">
      <tgroup cols="2">
         <thead>
            <row>
               <entry>
                  <para>Field</para>
               </entry>
               <entry>
                  <para>Description</para>
               </entry>
            </row>
         </thead><tbody><row>
            <entry>
               <para>id</para>
            </entry>
            <entry>
               <para>Your name for the resource</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>class</para>
            </entry>
            <entry>
               <para>The standard the script conforms to.  Allowed values: heartbeat, lsb, ocf, stonith</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>type</para>
            </entry>
            <entry>
               <para>The name of the Resource Agent you wish to use. eg. IPaddr or Filesystem</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>provider</para>
            </entry>
            <entry>
               <para>The OCF spec allows multiple vendors to supply the same ResourceAgent.  To use the OCF resource agents supplied with Heartbeat, you should specify heartbeat here.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>Properties of a primitive resource</para>
   <para>Resource definitions can be queried with the crm_resource tool.  For example</para>
   <para>crm_resource --resource Email --query-xml</para>
   <para>might produce</para>
   <para>&lt;primitive id="Email" class="lsb" type="exim"/&gt;</para>
   <para>An example LSB resource<footnote>
         <para> LSB resources do not allow any parameters</para>
      </footnote>
   </para>
   <para>or, for an OCF resource:</para>
   <para>&lt;primitive id="Public-IP" class="ocf" type="IPaddr" provider=”heartbeat”&gt;</para>
   <para>    &lt;instance_attributes id="params-public-ip"&gt;</para>
   <para>          &lt;nvpair id="public-ip-addr" name="ip" value="1.2.3.4"/&gt;</para>
   <para>    &lt;/instance_attributes&gt;</para>
   <para>&lt;/primitive&gt; </para>
   <para>An example OCF resource</para>
   <para>or, finally for the equivalent legacy Heartbeat resource:</para>
   <para>&lt;primitive id="Public-IP-legacy" class="heartbeat" type="IPaddr”&gt;</para>
   <para>    &lt;instance_attributes id="params-public-ip-legacy"&gt;</para>
   <para>          &lt;nvpair id="public-ip-addr-legacy" name="1" value="1.2.3.4"/&gt;</para>
   <para>    &lt;/instance_attributes&gt;</para>
   <para>&lt;/primitive&gt; </para>
   <para>An example Heartbeat resource<footnote>
         <para> Heartbeat resources take only ordered and unnamed parameters.  The supplied name therefor indicates the order in which they are passed to the script.  Only single digit values are allowed.</para>
      </footnote>
   </para>
   <para/></section><section><title>
      <anchor id="Options"/>Options</title>
   <para>Options are used by the cluster to decide how your resource should behave and can be easily set using the --meta option of the crm_resource command.</para>
   <informaltable frame="all">
      <tgroup cols="3">
         <thead>
            <row>
               <entry>
                  <para>Field</para>
               </entry>
               <entry>
                  <para>Default</para>
               </entry>
               <entry>
                  <para>Description</para>
               </entry>
            </row>
         </thead><tbody><row>
            <entry>
               <para>priority</para>
            </entry>
            <entry>
               <para>0</para>
            </entry>
            <entry>
               <para>If not all resources can be active, the cluster will stop lower priority resources in order to keep higher priority ones active.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>target-role</para>
            </entry>
            <entry>
               <para>Started</para>
            </entry>
            <entry>
               <para>What state should the cluster attempt to keep this resource in?  Allowed values: </para>
               <orderedlist>
                  <listitem>
                     <para>Stopped - Force the resource to </para>
                  </listitem>
                  <listitem>
                     <para>Started - Allow the resource to be started (In the case of <link linkend="">multi-state</link> resources, they will not promoted to master)</para>
                  </listitem>
                  <listitem>
                     <para>Master - Allow the resource to be started and, if appropriate, promoted</para>
                  </listitem>
               </orderedlist>
            </entry>
         </row>
         <row>
            <entry>
               <para>is-managed</para>
            </entry>
            <entry>
               <para>TRUE</para>
            </entry>
            <entry>
               <para>Is the cluster allowed to start and stop the resource?  Allowed values: true, false</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>resource-stickiness</para>
            </entry>
            <entry>
               <para>Inherited</para>
            </entry>
            <entry>
               <para>How much does the resource prefer to stay where it is?  </para>
               <para>Defaults to the value of resource-stickiness in the rsc_defaults section</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>migration-threshold</para>
            </entry>
            <entry>
               <para>0 (disabled)</para>
            </entry>
            <entry>
               <para>How many failures should occur for this resource on a node before making the node ineligible to host this resource. </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>failure-timeout</para>
            </entry>
            <entry>
               <para>0 (disabled)</para>
            </entry>
            <entry>
               <para>How many seconds to wait before acting as if the failure had not occurred (and potentially allowing the resource back to the node on which it failed.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>multiple-active</para>
            </entry>
            <entry>
               <para>stop_start</para>
            </entry>
            <entry>
               <para>What should the cluster do if it ever finds the resource active on more than one node.  Allowed values: </para>
               <orderedlist>
                  <listitem>
                     <para>block - mark the resource as unmanaged</para>
                  </listitem>
                  <listitem>
                     <para>stop_only - stop all active instances and leave them that way</para>
                  </listitem>
                  <listitem>
                     <para>stop_start - stop all active instances and start the resource in one location only</para>
                  </listitem>
               </orderedlist>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>Available options for a primitive resource</para>
   <para>If you performed the following commands on the above resource</para>
   <para>crm_resource --meta --resource Email --set-parameter priority --property-value 100</para>
   <para>crm_resource --meta --resource Email --set-parameter multiple-active --property-value block</para>
   <para>the resulting resource definition would be</para>
   <para>&lt;primitive id="Email" class="lsb" type="exim"&gt;</para>
   <para>   &lt;meta_attributes id="meta-email"&gt;</para>
   <para>         &lt;nvpair id="email-priority" name="priority" value="100"/&gt;</para>
   <para>         &lt;nvpair id="email-active" name="multiple-active" value="block"/&gt;</para>
   <para>   &lt;/meta_attributes&gt;</para>
   <para>&lt;/primitive&gt;</para>
   <para>An example LSB resource with cluster options</para></section><section><title>
      <anchor id="SettingGlobalDefaultsforReso"/>Setting Global Defaults for Resource Options</title>
   <para>To set a default value for a resource option, simply add it to the rsc_defaults section with crm_attribute.</para>
   <para>Thus, </para>
   <para>crm_attribute --type rsc_defaults --attr-name is-managed --attr-value false</para>
   <para>would prevent the cluster from starting or stopping any of the resources in the configuration (unless of course the individual resources were specifically enabled and had is-managed set to true).</para></section><section><title>Instance Attributes</title>
   <para>The scripts of some resource classes (LSB not being one of them) can be given parameters which determine how they behave and which instance of a service they control.</para>
   <para>If your resource agent supports parameters, you can add them with the crm_resource command.  For instance</para>
   <para>crm_resource --resource Public-IP --set-parameter ip --property-value 1.2.3.4</para>
   <para>would create an entry in the resource like this</para>
   <para>&lt;primitive id="Public-IP" class="ocf" type="IPaddr" provider=”heartbeat”&gt;</para>
   <para>    &lt;instance_attributes id="params-public-ip"&gt;</para>
   <para>          &lt;nvpair id="public-ip-addr" name="ip" value="1.2.3.4"/&gt;</para>
   <para>    &lt;/instance_attributes&gt;</para>
   <para>&lt;/primitive&gt;</para>
   <para>An example OCF resource with instance attributes</para>
   <para>For an OCF resource, the result would be an environment variable called OCF_RESKEY_ip with a value of 1.2.3.4</para>
   <para>The list of instance attributes supported by an OCF script can be found by calling the resource script with the meta-data command.  The output contains an XML description of all the supported attributes, their purpose and default values. </para>
   <para>export OCF_ROOT=/usr/lib/ocf; $OCF_ROOT/resource.d/heartbeat/IPaddr2 meta-data </para>
   <para>Displaying the metadata for the IPaddr resource agent </para></section><section><title>Resource Operations</title><section><title>Monitoring Resources for Failure </title>
   <para>By default, the cluster will not ensure your resources are still healthy.  To instruct the cluster to do this, you need to add a monitor operation to the resource’s definition.</para>
   <para>&lt;primitive id="Public-IP" class="ocf" type="IPaddr" provider=”heartbeat”&gt;</para>
   <para>    &lt;operations&gt;</para>
   <para>       &lt;op id="public-ip-check" name="monitor" interval="60s"/&gt;</para>
   <para>    &lt;/operations&gt;</para>
   <para>    &lt;instance_attributes id="params-public-ip"&gt;</para>
   <para>          &lt;nvpair id="public-ip-addr" name="ip" value="1.2.3.4"/&gt;</para>
   <para>    &lt;/instance_attributes&gt;</para>
   <para>&lt;/primitive&gt;</para>
   <para>An OCF resource with a recurring health check</para>
   <informaltable frame="all">
      <tgroup cols="2">
         <thead>
            <row>
               <entry>
                  <para>Field</para>
               </entry>
               <entry>
                  <para>Description</para>
               </entry>
            </row>
         </thead><tbody><row>
            <entry>
               <para>id</para>
            </entry>
            <entry>
               <para>Your name for the action.  Must be unique.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>name</para>
            </entry>
            <entry>
               <para>The action to perform.  Common values: monitor, start, stop</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>interval</para>
            </entry>
            <entry>
               <para>How frequently (in seconds) to perform the operation.  Default value: 0</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>timeout</para>
            </entry>
            <entry>
               <para>How long to wait before declaring the action has failed.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>requires</para>
            </entry>
            <entry>
               <para>What conditions need to be satisfied before this action occurs. Allowed values: </para>
               <orderedlist>
                  <listitem>
                     <para>nothing - The cluster may start this resource at any time </para>
                  </listitem>
                  <listitem>
                     <para>quorum - The cluster can only start this resource if a majority of the configured nodes are active </para>
                  </listitem>
                  <listitem>
                     <para>fencing - The cluster can only start this resource if a majority of the configured nodes are active and any failed or unknown nodes have been powered off.</para>
                  </listitem>
               </orderedlist>
               <para>STONITH resources default to nothing, and all others default to fencing if STONITH is enabled and quorum otherwise.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>on-fail</para>
            </entry>
            <entry>
               <para>The action to take if this action ever fails.  Allowed values: </para>
               <orderedlist>
                  <listitem>
                     <para>ignore - Pretend the resource did not fail</para>
                  </listitem>
                  <listitem>
                     <para>block - Don’t perform any further operations on the resource</para>
                  </listitem>
                  <listitem>
                     <para>stop - Stop the resource and do not start it elsewhere</para>
                  </listitem>
                  <listitem>
                     <para>restart - Stop the resource and start it again (possibly on a different node) </para>
                  </listitem>
                  <listitem>
                     <para>fence - STONITH the node on which the resource failed</para>
                  </listitem>
                  <listitem>
                     <para>standby - Move all resources away from the node on which the resource failed</para>
                  </listitem>
               </orderedlist>
               <para>The default for the stop operation is fence when STONITH is enabled and block otherwise. All other operations default to stop.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>enabled</para>
            </entry>
            <entry>
               <para>If false, the operation is treated as if it does not exist.  Allowed values: <emphasis>true</emphasis>, false</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>Valid fields for an operation</para></section></section><section><title>
      <anchor id="SettingGlobalDefaultsforOper"/>Setting Global Defaults for Operations</title>
   <para>To set a default value for a operation option, simply add it to the op_defaults section with crm_attribute.</para>
   <para>Thus, </para>
   <para>crm_attribute --type op_defaults --attr-name timeout --attr-value 20s</para>
   <para>would default each operation’s timeout to 20 seconds.  If an operation’s definition also includes a value for timeout, then that value would be used instead (for that operation only).</para><section><title>When Resources Take a Long Time to Start/Stop</title>
   <para>There are a number of implicit operations that the cluster will always perform - start, stop and a non-recurring monitor operation (used at startup to check the resource isn’t already active).  If one of these is taking too long, then you can create an entry for them and simply specify a new value.</para>
   <para>&lt;primitive id="Public-IP" class="ocf" type="IPaddr" provider=”heartbeat”&gt;</para>
   <para>    &lt;operations&gt;</para>
   <para>       &lt;op id="public-ip-startup" name="monitor" interval="0" timeout=”90s”/&gt;</para>
   <para>       &lt;op id="public-ip-start" name="start" interval="0" timeout=”180s”/&gt;</para>
   <para>       &lt;op id="public-ip-stop" name="stop" interval="0" timeout=”15min”/&gt;</para>
   <para>    &lt;/operations&gt;</para>
   <para>    &lt;instance_attributes id="params-public-ip"&gt;</para>
   <para>          &lt;nvpair id="public-ip-addr" name="ip" value="1.2.3.4"/&gt;</para>
   <para>    &lt;/instance_attributes&gt;</para>
   <para>&lt;/primitive&gt;</para>
   <para>An OCF resource with custom timeouts for its implicit actions</para></section><section><title>Multiple Monitor Operations</title>
   <para>Provided no two operations (for a single resource) have the same name and interval you can have as many monitor operations as you like.  In this way you can do a superficial health check every minute and progressively more intense ones at higher intervals.</para>
   <para>To tell the resource agent what kind of check to perform, you need to provide each monitor with a different value for a common parameter.  The OCF standard creates a special parameter called OCF_CHECK_LEVEL for this purpose and dictates that it is <emphasis>made available to the resource agent without the normal OCF_RESKEY_ prefix</emphasis>.  </para>
   <para>Whatever name you choose, you can specify it by adding an instance_attributes block to the op tag.  Note that it is up to each resource agent to look for the parameter and decide how to use it.</para>
   <para>&lt;primitive id="Public-IP" class="ocf" type="IPaddr" provider=”heartbeat”&gt;</para>
   <para>    &lt;operations&gt;</para>
   <para>       &lt;op id="public-ip-health-60" name="monitor" interval="60"&gt;</para>
   <para>           &lt;instance_attributes id="params-public-ip-depth-60"&gt;</para>
   <para>                  &lt;nvpair id="public-ip-depth-60" name="OCF_CHECK_LEVEL" value="10"/&gt;</para>
   <para>           &lt;/instance_attributes&gt;</para>
   <para>       &lt;/op&gt;</para>
   <para>       &lt;op id="public-ip-health-300" name="monitor" interval="300"&gt;</para>
   <para>           &lt;instance_attributes id="params-public-ip-depth-300"&gt;</para>
   <para>                  &lt;nvpair id="public-ip-depth-300" name="OCF_CHECK_LEVEL" value="20"/&gt;</para>
   <para>           &lt;/instance_attributes&gt;</para>
   <para>       &lt;/op&gt;</para>
   <para>    &lt;/operations&gt;</para>
   <para>    &lt;instance_attributes id="params-public-ip"&gt;</para>
   <para>          &lt;nvpair id="public-ip-level" name="ip" value="1.2.3.4"/&gt;</para>
   <para>    &lt;/instance_attributes&gt;</para>
   <para>&lt;/primitive&gt;</para>
   <para>An OCF resource with two recurring health checks performing different levels of checks</para></section><section><title>Disabling a Monitor Operation</title>
   <para>The easiest way to stop a recurring monitor is to just delete it.  However there can be times when you only want to disable it temporarily.  In such cases, simply add disabled=”true” to the operation’s definition.</para>
   <para>&lt;primitive id="Public-IP" class="ocf" type="IPaddr" provider=”heartbeat”&gt;</para>
   <para>    &lt;operations&gt;</para>
   <para>       &lt;op id="public-ip-check" name="monitor" interval="60s" disabled=”true”/&gt;</para>
   <para>    &lt;/operations&gt;</para>
   <para>    &lt;instance_attributes id="params-public-ip"&gt;</para>
   <para>          &lt;nvpair id="public-ip-addr" name="ip" value="1.2.3.4"/&gt;</para>
   <para>    &lt;/instance_attributes&gt;</para>
   <para>&lt;/primitive&gt;</para>
   <para>Example of an OCF resource with a disabled health check</para>
   <para>This can be achieved from the command-line by executing</para>
   <para>cibadmin -M -X ‘&lt;op id="public-ip-check" disabled=”true”/&gt;’</para>
   <para>Once you’ve done whatever you needed to do, you can then re-enable it with</para>
   <para>cibadmin -M -X ‘&lt;op id="public-ip-check" disabled=”false”/&gt;’</para>
   </section>
     </section>
   </section>
   <section id="constraints"><title>Resource Constraints</title>
     <section><title>Scores</title>
   <para>Scores of all kinds are integral to how the cluster works.  Practically everything from moving a resource to deciding which resource to stop in a degraded cluster is achieved by manipulating scores in some way. </para>
   <para>Scores are calculated on a per-resource basis and any node with a negative score for a resource can’t run that resource.  After calculating the scores for a resource, the cluster then chooses the node with the highest one.  </para><section><title>Infinity Math</title>
   <para>INFINITY is currently defined as 1,000,000 and addition/subtraction with it follows the following 3 basic rules:</para>
   <orderedlist>
      <listitem>
         <para>Any value + INFINITY = INFINITY</para>
      </listitem>
      <listitem>
         <para>Any value - INFINITY = -INFINITY</para>
      </listitem>
      <listitem>
         <para>INFINITY - INFINITY  = -INFINITY</para>
      </listitem>
   </orderedlist></section></section><section><title>Deciding Which Nodes a Resource Can Run On</title>
   <para>There are two alternative strategies for specifying which nodes a resources can run on.  One way is to say that by default they can run anywhere and then create location constraints for nodes that are not allowed.  The other option is to have nodes “opt-in”... to start with nothing able to run anywhere and selectively enable allowed nodes.</para><section><title>Options</title>
   <informaltable frame="all">
      <tgroup cols="2">
         <thead>
            <row>
               <entry>
                  <para>Field</para>
               </entry>
               <entry>
                  <para>Description</para>
               </entry>
            </row>
         </thead><tbody><row>
            <entry>
               <para>id</para>
            </entry>
            <entry>
               <para>A unique name for the constraint</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>rsc</para>
            </entry>
            <entry>
               <para>A resource name</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>node</para>
            </entry>
            <entry>
               <para>A node’s uname</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>score</para>
            </entry>
            <entry>
               <para>Positive values indicate the resource can run on this node.  Negative values indicate the resource can not run on this node.  Values of +/- INFINITY change “can” to “must”.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section><section><title>Asymmetrical “Opt-In” Clusters</title>
   <para>To create an opt-in cluster, start by preventing resources from running anywhere by default</para>
   <para>crm_attribute --attr-name symmetric-cluster --attr-value false</para>
   <para>Then start enabling nodes.  The following fragment says that the web server prefers sles-1, the database prefers sles-2 and both can failover to sles-3 if their most preferred node fails.  </para>
   <para>&lt;constraints&gt;</para>
   <para>    &lt;rsc_location id=”loc-1” rsc=”Webserver” node=”sles-1” score=”200”/&gt;</para>
   <para>    &lt;rsc_location id=”loc-2” rsc=”Webserver” node=”sles-3” score=”0”/&gt;</para>
   <para>    &lt;rsc_location id=”loc-3” rsc=”Database” node=”sles-2” score=”200”/&gt;</para>
   <para>    &lt;rsc_location id=”loc-4” rsc=”Database” node=”sles-3” score=”0”/&gt;</para>
   <para>&lt;/constraints&gt;</para>
   <para>Example set of opt-in location constraints</para></section><section><title>Symmetrical “Opt-Out” Clusters</title>
   <para>To create an opt-out cluster, start by allowing resources to run anywhere by default</para>
   <para>crm_attribute --attr-name symmetric-cluster --attr-value true</para>
   <para>Then start disabling nodes.  The following fragment is the equivalent of the above opt-in configuration.</para>
   <para>&lt;constraints&gt;</para>
   <para>    &lt;rsc_location id=”loc-1” rsc=”Webserver” node=”sles-1” score=”200”/&gt;</para>
   <para>    &lt;rsc_location id=”loc-2-dont-run” rsc=”Webserver” node=”sles-2” score=”-INFINITY”/&gt;</para>
   <para>    &lt;rsc_location id=”loc-3-dont-run” rsc=”Database” node=”sles-1” score=”-INFINITY”/&gt;</para>
   <para>    &lt;rsc_location id=”loc-4” rsc=”Database” node=”sles-2” score=”200”/&gt;</para>
   <para>&lt;/constraints&gt;</para>
   <para>Example set of opt-out location constraints</para>
   <para>Whether you should choose opt-in or opt-out depends both on your personal preference and the make-up of your cluster.  If most of your resources can run on most of the nodes, then an opt-out arrangement is likely to result in a simpler configuration.  On the other-hand, if most resources can only run on a small subset of nodes an opt-in configuration might be simpler.</para></section><section><title>
      <anchor id="WhatifTwoNodesHavetheSame"/>What if Two Nodes Have the Same Score</title>
   <para>If two nodes have the same score, then the cluster will choose one.  This choice may seem random and may not be what was intended, however the cluster was not given enough information to know what was intended.</para>
   <para>&lt;constraints&gt;</para>
   <para>    &lt;rsc_location id=”loc-1” rsc=”Webserver” node=”sles-1” score=”INFINITY”/&gt;</para>
   <para>    &lt;rsc_location id=”loc-2” rsc=”Webserver” node=”sles-2” score=”INFINITY”/&gt;</para>
   <para>    &lt;rsc_location id=”loc-3” rsc=”Database” node=”sles-1” score=”500”/&gt;</para>
   <para>    &lt;rsc_location id=”loc-4” rsc=”Database” node=”sles-2” score=”300”/&gt;</para>
   <para>    &lt;rsc_location id=”loc-5” rsc=”Database” node=”sles-2” score=”200”/&gt;</para>
   <para>&lt;/constraints&gt;</para>
   <para>Example of two resources that prefer two nodes equally</para>
   <para>In the example above, assuming no other constraints and an inactive cluster, Webserver would probably be placed on sles-1 and Database on sles-2.  It would likely have placed Webserver based on the node’s uname and Database based on the desire to spread the resource load evenly across the cluster.  However other factors can also be involved in more complex configurations.</para></section><section><title>
      <anchor id="SpecifyingtheOrderResourcesS"/>Specifying the Order Resources Should Start/Stop In</title>
   <para>The way to specify the order in which resources should start is by creating rsc_order constraints.</para>
   <informaltable frame="all">
      <tgroup cols="2">
         <thead>
            <row>
               <entry>
                  <para>Field</para>
               </entry>
               <entry>
                  <para>Description</para>
               </entry>
            </row>
         </thead><tbody><row>
            <entry>
               <para>id</para>
            </entry>
            <entry>
               <para>A unique name for the constraint</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>first</para>
            </entry>
            <entry>
               <para>The name of a resource that must be started before the then resource is allowed to. </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>then</para>
            </entry>
            <entry>
               <para>The name of a resource.  This resource will start after the first resource.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>score</para>
            </entry>
            <entry>
               <para>If greater than zero, the constraint is mandatory.  Otherwise it is only a suggestion. Default value: <emphasis>INFINITY</emphasis>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>symmetrical</para>
            </entry>
            <entry>
               <para>If true, which is the default, stop the resources in the reverse order.  Default value: <emphasis>true</emphasis>
               </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para/></section><section><title>Mandatory Ordering</title>
   <para>When the then resource cannot run without the first resource being active, one should use mandatory constraints. To specify a constraint is mandatory, use a scores greater than zero.  This will ensure that the then resource will react when the first resource changes state.</para>
   <orderedlist>
      <listitem>
         <para>If the first resource was running and is stopped, the then resource will also be stopped (if it is running)</para>
      </listitem>
      <listitem>
         <para>If the first resource was not running and cannot be started, the then resource will be stopped (if it is running)</para>
      </listitem>
      <listitem>
         <para>If the first resource is (re)started while the then resource is running, the then resource will be stopped and restarted</para>
      </listitem>
   </orderedlist></section><section><title>Advisory Ordering</title>
   <para>On the other-hand, when score=”0” is specified for a constraint, the constraint is considered optional and only has an effect when both resources are stopping and or starting.  Any change in state by the first resource will have no effect on the then resource.</para>
   <para>&lt;constraints&gt;</para>
   <para>    &lt;rsc_order id=”order-1” first=”Database” then=”Webserver” /&gt;</para>
   <para>    &lt;rsc_order id=”order-2” first=”IP” then=”Webserver”  score=”0”/&gt;</para>
   <para>&lt;/constraints&gt;</para>
   <para>Example of an optional and mandatory ordering constraint</para>
   <para>Some additional information on ordering constraints can be found in the document <ulink url="http://oss.beekhof.net/~beekhof/heartbeat/docs/Ordering-Explained.pdf">Ordering Explained</ulink>
   </para></section></section><section><title>
      <anchor id="PlacingResourcesRelativetoot"/>Placing Resources Relative to other Resources</title>
   <para>When the location of one resource depends on the location of another one, we call this colocation.</para>
   <para>There is an important side-effect of creating a colocation constraint between two resources, that it affects the order in which resources are assigned to a node.  If you think about it, its somewhat obvious.  You can’t place A relative to B unless you know where B is<footnote>
         <para> While the human brain is sophisticated enough to read the constraint in any order and choose the correct one depending on the situation, the cluster is not quite so smart.  Yet.</para>
      </footnote>.  So when you are creating colocation constraints, it is important to consider whether you should colocate A with B or B with A.</para>
   <para>Another thing to keep in mind is that, assuming A is collocated with B, the cluster will also take into account A’s preferences when deciding which node to choose for B.  For a detailed look at exactly how this occurs, see the <ulink url="http://oss.beekhof.net/~beekhof/heartbeat/docs/Colocation-Explained.pdf">Colocation Explained</ulink> document.</para><section><title>Options</title>
   <informaltable frame="all">
      <tgroup cols="2">
         <thead>
            <row>
               <entry>
                  <para>Field</para>
               </entry>
               <entry>
                  <para>Description</para>
               </entry>
            </row>
         </thead><tbody><row>
            <entry>
               <para>id</para>
            </entry>
            <entry>
               <para>A unique name for the constraint</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>rsc</para>
            </entry>
            <entry>
               <para>The colocation source.  If the constraint cannot be satisfied, the cluster may decide not to allow the resource to run at all.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>with-rsc</para>
            </entry>
            <entry>
               <para>The colocation target.  The cluster will decide where to put this resource first and then decide where to put the resource in the rsc field</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>score</para>
            </entry>
            <entry>
               <para>Positive values indicate the resource should run on the same node.  Negative values indicate the resources should not run on the same node.  Values of +/- INFINITY change “should” to “must”.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section><section><title>Mandatory Placement</title>
   <para>Mandatory placement occurs any time the constraint’s score is +INFINITY or -INFINITY.  In such cases, if the constraint can’t be satisfied, then the rsc resource is not permitted to run.  For score=INFINITY, this includes cases where the with-rsc resource is not active.</para>
   <para>If you need resource1 to always run on the same machine as resource2, you would add the following constraint: </para>
   <para>&lt;rsc_colocation id=”colocate” rsc=”resource1” with-rsc=”resource2” score=”INFINITY”/&gt; </para>
   <para>An example colocation constraint</para>
   <para>Remember, because INFINITY was used, if resource2 can’t run on any of the cluster nodes (for whatever reason) then resource1 will not be allowed to run.</para>
   <para>Alternatively, you may want the opposite... that resource1 cannot run on the same machine as resource2.  In this case use score=”-INFINITY”</para>
   <para>&lt;rsc_colocation id=”anti-colocate” rsc=”resource1” with-rsc=”resource2” score=”-INFINITY”/&gt; </para>
   <para>An example anti-colocation constraint</para>
   <para>Again, by specifying -INFINTY, the constraint is binding.  So if the only place left to run is where resource2 already is, then resource1 may not run anywhere.</para></section><section><title>Advisory Placement</title>
   <para>If mandatory placement is about “must” and “must not”, then advisory placement is the “I’d prefer if” alternative.  For constraints with scores greater than -INFINITY and less than INFINITY, the cluster will try and accommodate your wishes but may ignore them if the alternative is to stop some of the cluster resources.</para>
   <para>Like in life, where if enough people prefer something it effectively becomes mandatory, advisory colocation constraints can combine with other elements of the configuration to behave as if they were mandatory.   </para>
   <para>&lt;rsc_colocation id=”colocate-maybe” rsc=”resource1” with-rsc=”resource2” score=”500”/&gt; </para>
   <para>An example advisory-only colocation constraint</para></section></section><section><title>
      <anchor id="OrderingSetsofResources"/>Ordering Sets of Resources</title>
   <para>A common situation is for an administrator to create a chain of ordered resources, such as:</para>
   <para>&lt;constraints&gt;</para>
   <para>    &lt;rsc_order id=”order-1” first=”A” then=”B” /&gt;</para>
   <para>    &lt;rsc_order id=”order-2” first=”B” then=”C” /&gt;</para>
   <para>    &lt;rsc_order id=”order-3” first=”C” then=”D” /&gt;</para>
   <para>&lt;/constraints&gt;</para>
   <para>A chain of ordered resources</para>
   <para>
      <inlinegraphic fileref="embedded:graphics9" width="16cm" depth="2.5cm"/>Visual representation of the four resources’ start order for the above constraints</para>
   <para/>
   <para>To simplify this situation, there is an alternate format for ordering constraints</para>
   <para>&lt;constraints&gt;</para>
   <para>    &lt;rsc_order id=”order-1”&gt;</para>
   <para>        &lt;resource_set id=”ordered-set-example” sequential=”true”&gt;</para>
   <para>            &lt;resource_ref id=”A”/&gt;</para>
   <para>            &lt;resource_ref id=”B”/&gt;</para>
   <para>            &lt;resource_ref id=”C”/&gt;</para>
   <para>            &lt;resource_ref id=”D”/&gt;</para>
   <para>        &lt;/resource_set&gt;</para>
   <para>    &lt;/rsc_order&gt;</para>
   <para>&lt;/constraints&gt;</para>
   <para>A chain of ordered resources expressed as a set</para>
   <para>NOTE: Resource sets have the opposite ordering semantics to groups.</para>
   <para>&lt;group id=”dummy”&gt;</para>
   <para>    &lt;primitive id=”D” .../&gt;</para>
   <para>    &lt;primitive id=”C” .../&gt;</para>
   <para>    &lt;primitive id=”B” .../&gt;</para>
   <para>    &lt;primitive id=”A” .../&gt;</para>
   <para>&lt;/group&gt;</para>
   <para>A group resource with the equivalent ordering rules</para>
   <para>While the set-based format is not less verbose, it is significantly easier to get right and maintain.  It can also be expanded to allow ordered sets of (un)ordered resources. In the example below, rscA and rscB can both start in parallel, as can rscC and rscD, however  rscC and rscD can only start once <emphasis>both</emphasis> rscA <emphasis>and</emphasis> rscB are active.</para>
   <para>&lt;constraints&gt;</para>
   <para>    &lt;rsc_order id=”order-1”&gt;</para>
   <para>        &lt;resource_set id=”ordered-set-1” sequential=”false”&gt;</para>
   <para>            &lt;resource_ref id=”A”/&gt;</para>
   <para>            &lt;resource_ref id=”B”/&gt;</para>
   <para>        &lt;/resource_set&gt;</para>
   <para>        &lt;resource_set id=”ordered-set-2” sequential=”false”&gt;</para>
   <para>            &lt;resource_ref id=”C”/&gt;</para>
   <para>            &lt;resource_ref id=”D”/&gt;</para>
   <para>        &lt;/resource_set&gt;</para>
   <para>    &lt;/rsc_order&gt;</para>
   <para>&lt;/constraints&gt;</para>
   <para>Ordered sets of unordered resources</para>
   <para>
      <inlinegraphic fileref="embedded:graphics10" width="10cm" depth="5cm"/>Visual representation of the start order for two ordered sets of unordered resources  </para>
   <para>Of course either or both sets of resources can also be internally ordered (by setting sequential=”true”) and there is no limit to the number of sets that can be specified.</para>
   <para>&lt;constraints&gt;</para>
   <para>    &lt;rsc_order id=”order-1”&gt;</para>
   <para>        &lt;resource_set id=”ordered-set-1” sequential=”false”&gt;</para>
   <para>            &lt;resource_ref id=”A”/&gt;</para>
   <para>            &lt;resource_ref id=”B”/&gt;</para>
   <para>        &lt;/resource_set&gt;</para>
   <para>        &lt;resource_set id=”ordered-set-2” sequential=”true”&gt;</para>
   <para>            &lt;resource_ref id=”C”/&gt;</para>
   <para>            &lt;resource_ref id=”D”/&gt;</para>
   <para>        &lt;/resource_set&gt;</para>
   <para>        &lt;resource_set id=”ordered-set-3” sequential=”false”&gt;</para>
   <para>            &lt;resource_ref id=”E”/&gt;</para>
   <para>            &lt;resource_ref id=”F”/&gt;</para>
   <para>        &lt;/resource_set&gt;</para>
   <para>    &lt;/rsc_order&gt;</para>
   <para>&lt;/constraints&gt;</para>
   <para>Advanced use of set ordering - Three ordered sets, two of which are internally unordered </para>
   <para>
      <inlinegraphic fileref="embedded:graphics11" width="16cm" depth="7.5cm"/>Visual representation of the start order for the three sets defined above </para></section><section><title>
      <anchor id="CollocatingSetsofResources"/>Collocating Sets of Resources</title>
   <para>Another common situation is for an administrator to create a set of collocated resources.  Previously this possible either by defining a resource group (See <link linkend="">Groups - A Syntactic Shortcut</link>) which could not always accurately express the design; or by defining each relationship as an individual constraint, causing a constraint explosion as the number of resources and combinations grew.</para>
   <para>&lt;constraints&gt;</para>
   <para>    &lt;rsc_colcoation id=”coloc-1” rsc=”B” with-rsc=”A” score=”INFINITY”/&gt;</para>
   <para>    &lt;rsc_colcoation id=”coloc-2” rsc=”C” with-rsc=”B” score=”INFINITY”/&gt;</para>
   <para>    &lt;rsc_colcoation id=”coloc-3” rsc=”D” with-rsc=”C” score=”INFINITY”/&gt;</para>
   <para>&lt;/constraints&gt;</para>
   <para>A chain of collocated resources</para>
   <para>To make things easier, we allow an alternate form of colocation constraints using resource_sets.  Just like the expanded version, a resource that can’t be active also prevents any resource that must be collocated with it from being active.  For example if B was not able to run, then both C (and by inference D) must also remain stopped.</para>
   <para>&lt;constraints&gt;</para>
   <para>    &lt;rsc_colocation id=”coloc-1” score=”INFINITY” &gt;</para>
   <para>        &lt;resource_set id=”collocated-set-example” sequential=”true”&gt;</para>
   <para>            &lt;resource_ref id=”A”/&gt;</para>
   <para>            &lt;resource_ref id=”B”/&gt;</para>
   <para>            &lt;resource_ref id=”C”/&gt;</para>
   <para>            &lt;resource_ref id=”D”/&gt;</para>
   <para>        &lt;/resource_set&gt;</para>
   <para>    &lt;/rsc_colocation&gt;</para>
   <para>&lt;/constraints&gt;</para>
   <para>The equivalent colocation chain expressed using resource_sets</para>
   <para>NOTE: Resource sets have the same colocation semantics as groups.</para>
   <para>&lt;group id=”dummy”&gt;</para>
   <para>    &lt;primitive id=”A” .../&gt;</para>
   <para>    &lt;primitive id=”B” .../&gt;</para>
   <para>    &lt;primitive id=”C” .../&gt;</para>
   <para>    &lt;primitive id=”D” .../&gt;</para>
   <para>&lt;/group&gt;</para>
   <para>A group resource with the equivalent colocation rules</para>
   <para/>
   <para/>
   <para/>
   <para/>
   <para/>
   <para>This notation can also be used in this context to tell the cluster that a set of resources must all be located with a common peer, but have no dependancies on each other.  In this scenario, unlike the previous on, B would be allowed to remain active even if A or C (or both) were inactive.</para>
   <para>&lt;constraints&gt;</para>
   <para>    &lt;rsc_colocation id=”coloc-1” score=”INFINITY” &gt;</para>
   <para>        &lt;resource_set id=”collocated-set-1” sequential=”false”&gt;</para>
   <para>            &lt;resource_ref id=”A”/&gt;</para>
   <para>            &lt;resource_ref id=”B”/&gt;</para>
   <para>            &lt;resource_ref id=”C”/&gt;</para>
   <para>        &lt;/resource_set&gt;</para>
   <para>        &lt;resource_set id=”collocated-set-2” sequential=”true”&gt;</para>
   <para>            &lt;resource_ref id=”D”/&gt;</para>
   <para>        &lt;/resource_set&gt;</para>
   <para>    &lt;/rsc_colocation&gt;</para>
   <para>&lt;/constraints&gt;</para>
   <para>Using colocation sets to specify a common peer. </para>
   <para>Of course there is no limit to the number and size of the sets used.  The only thing that matters is that in order for any member of set N to be active, all the members of set N+1 must also be active (and naturally on the same node), and that if a set has sequential=”true”, then in order for member M to be active, member M+1 must also be active.  You can even specify the role in which the members of a set must be in using the set’s role attribute.</para>
   <para>&lt;constraints&gt;</para>
   <para>    &lt;rsc_colocation id=”coloc-1” score=”INFINITY” &gt;</para>
   <para>        &lt;resource_set id=”collocated-set-1” sequential=”true”&gt;</para>
   <para>            &lt;resource_ref id=”A”/&gt;</para>
   <para>            &lt;resource_ref id=”B”/&gt;</para>
   <para>        &lt;/resource_set&gt;</para>
   <para>        &lt;resource_set id=”collocated-set-2” sequential=”false”&gt;</para>
   <para>            &lt;resource_ref id=”C”/&gt;</para>
   <para>            &lt;resource_ref id=”D”/&gt;</para>
   <para>            &lt;resource_ref id=”E”/&gt;</para>
   <para>        &lt;/resource_set&gt;</para>
   <para>        &lt;resource_set id=”collocated-set-2” sequential=”true” role=”Master”&gt;</para>
   <para>            &lt;resource_ref id=”F”/&gt;</para>
   <para>            &lt;resource_ref id=”G”/&gt;</para>
   <para>        &lt;/resource_set&gt;</para>
   <para>    &lt;/rsc_colocation&gt;</para>
   <para>&lt;/constraints&gt;</para>
   <para>A colocation chain where the members of the middle set have no interdependencies and the last has master status.</para>
   <para>
      <inlinegraphic fileref="embedded:graphics12" width="16cm" depth="7.5cm"/>Visual representation of a colocation chain where the members of the middle set have no interdependencies</para>
     </section>
   </section>
   <section id="events"><title>Receiving Notification of Cluster Events</title>
     <section><title>Configuring Email Notifications</title></section>
     <section><title>Configuring SNMP Notifications</title></section>
   </section>
   <section id="rules">
     <title>Rules</title>
     <anchor id="Rules"/>Rules
   <para>Rules can be used to make your configuration more dynamic.  One common example is to set one value for resource-stickiness during working hours, to prevent resources from being moved back to their most preferred location, and another on weekends when no-one is around to notice an outage.  </para>
   <para>Another use of rules might be to assign machines to different processing groups (using a node attribute) based on time and to then use that attribute when creating location constraints.</para>
   <para>Each rule can contain a number of expressions, date-expressions and even other rules.  The results of the expressions are combined based on the rule’s boolean-op field to determine if the rule ultimately evaluates to true or false.  What happens next depends on the context in which the rule is being used.  </para>
   <informaltable frame="all">
      <tgroup cols="2">
         <thead>
            <row>
               <entry>
                  <para>Environment Variable</para>
               </entry>
               <entry>
                  <para>Description</para>
               </entry>
            </row>
         </thead><tbody><row>
            <entry>
               <para>role</para>
            </entry>
            <entry>
               <para>Limits the rule to only apply when the resource is in that role. Allowed values: <emphasis>Started</emphasis>, Slave, Master.  NOTE: A rule with role="Master" can not determine the initial location of a clone instance.  It will only affect which of the active instances will be promoted.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>score</para>
            </entry>
            <entry>
               <para>The score to apply if the rule evaluates to “true”.  Limited to use in rules that are part of location constraints.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>score-attribute</para>
            </entry>
            <entry>
               <para>The node attribute to look up and use as a score if the rule evaluates to “true”.  Limited to use in rules that are part of location constraints.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>boolean-op</para>
            </entry>
            <entry>
               <para>How to combine the result of multiple expression objects.  Allowed values: <emphasis>and</emphasis>, or</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>Properties of a rule object</para>
   <section><title>Node Attribute Expressions</title>
   <para>Expression objects are used to control a resource based on the attributes defined by a node or nodes.  In addition to any attributes added by the administrator, each node has a built-in node attribute called #uname that can also be used.</para>
   <informaltable frame="all">
      <tgroup cols="2">
         <thead>
            <row>
               <entry>
                  <para>Field</para>
               </entry>
               <entry>
                  <para>Description</para>
               </entry>
            </row>
         </thead><tbody><row>
            <entry>
               <para>value</para>
            </entry>
            <entry>
               <para>User supplied value for comparison</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>attribute</para>
            </entry>
            <entry>
               <para>The node attribute to test</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>type</para>
            </entry>
            <entry>
               <para>Determines how the value(s) should be tested.  Allowed values: integer, <emphasis>string</emphasis>, version</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>operation</para>
            </entry>
            <entry>
               <para>The comparison to perform. Allowed values: </para>
               <orderedlist>
                  <listitem>
                     <para>lt,- True if the node attribute’s value is less than value</para>
                  </listitem>
                  <listitem>
                     <para>gt - True if the node attribute’s value is greater than value</para>
                  </listitem>
                  <listitem>
                     <para>lte- True if the node attribute’s value is less than or equal to value</para>
                  </listitem>
                  <listitem>
                     <para>gte- True if the node attribute’s value is greater than or equal to value</para>
                  </listitem>
                  <listitem>
                     <para>eq- True if the node attribute’s value is equal to value</para>
                  </listitem>
                  <listitem>
                     <para>ne - True if the node attribute’s value is not equal to value</para>
                  </listitem>
                  <listitem>
                     <para>defined- True if the node has an the named attribute</para>
                  </listitem>
                  <listitem>
                     <para>not_defined- True if the node does not have the named attribute</para>
                  </listitem>
               </orderedlist>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>Properties of expression objects</para></section><section><title>Time/Date Based Expressions</title>
   <para>As the name suggests, date_expressions are used to control a resource or cluster option based on the current date/time.  They can contain an optional date_spec and/or duration object depending on the context. </para>
   <informaltable frame="all">
      <tgroup cols="2">
         <thead>
            <row>
               <entry>
                  <para>Field</para>
               </entry>
               <entry>
                  <para>Description</para>
               </entry>
            </row>
         </thead><tbody><row>
            <entry>
               <para>start</para>
            </entry>
            <entry>
               <para>A date/time conforming to the ISO8601 specification.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>end</para>
            </entry>
            <entry>
               <para>A date/time conforming to the ISO8601 specification.  Can be inferred by supplying a value for start and a duration.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>operation</para>
            </entry>
            <entry>
               <para>Compares the current date/time with the start and/or end date, depending on the context.  Allowed values: </para>
               <orderedlist>
                  <listitem>
                     <para>gt - True if the current date/time is after start</para>
                  </listitem>
                  <listitem>
                     <para>lt - True if the current date/time is before end</para>
                  </listitem>
                  <listitem>
                     <para>in-range - True if the current date/time is after start and before end</para>
                  </listitem>
                  <listitem>
                     <para>date-spec - performs a cron-like comparison between the contents of date_spec and now  </para>
                  </listitem>
               </orderedlist>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>Properties of date_expression objects</para>
   <para>NOTE: Because the comparisons (except for date_spec) include the time, the eq, neq, gte and lte operators have not been implemented.</para><section><title>Date Specifications</title>
   <para>date_spec objects are used to create cron-like expressions relating to time.  Each field can contain a single number or a single range.  Instead of defaulting to zero, any field not supplied is ignored.</para>
   <para>For example, monthdays="1" matches the first day of every month and hours="09-17" matches the hours between 9am and 5pm inclusive).  However at this time one cannot specify weekdays="1,2" or weekdays="1-2,5-6" since they contain multiple ranges.  Depending on demand, this may be implemented in a future release.</para>
   <informaltable frame="all">
      <tgroup cols="2">
         <thead>
            <row>
               <entry>
                  <para>Field</para>
               </entry>
               <entry>
                  <para>Description</para>
               </entry>
            </row>
         </thead><tbody><row>
            <entry>
               <para>id</para>
            </entry>
            <entry>
               <para>A unique name for the date</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>hours</para>
            </entry>
            <entry>
               <para>Allowed values: 0-23</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>monthdays</para>
            </entry>
            <entry>
               <para>Allowed values: 0-31 (depending on current month and year)</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>weekdays</para>
            </entry>
            <entry>
               <para>Allowed values: 1-7 (1=Monday, 7=Sunday)</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>yeardays</para>
            </entry>
            <entry>
               <para>Allowed values: 1-366 (depending on the current year)</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>months</para>
            </entry>
            <entry>
               <para>Allowed values: 1-12</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>weeks</para>
            </entry>
            <entry>
               <para>Allowed values: 1-53 (depending on weekyear)</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>years</para>
            </entry>
            <entry>
               <para>Year according the Gregorian calendar</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>weekyears</para>
            </entry>
            <entry>
               <para>May differ from Gregorian years.</para>
               <para>Eg. “2005-001 Ordinal” is also “2005-01-01 Gregorian” is also “2004-W53-6 Weekly” </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>moon</para>
            </entry>
            <entry>
               <para>Allowed values: 0..7 (0 is new, 4 is full moon).  Seriously, you can use this.  This was implemented to demonstrate the ease with which new comparisons could be added.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>Properties of date_spec objects</para></section><section><title>Durations</title>
   <para>Durations are used to calculate a value for end when one is not supplied to in_range operations.  They contain the same fields as date_spec objects but without the limitations (ie. you can have a duration of 19 days).   Like date_specs, any field not supplied is ignored. </para><section><title>Sample Time Based Expressions</title>
   <para>&lt;rule id="rule1"&gt;</para>
   <para>  &lt;date_expression id="date_expr1" start="2005-001" operation="in_range"&gt;</para>
   <para>    &lt;duration years="1"/&gt;</para>
   <para>  &lt;/date_expression&gt;</para>
   <para>&lt;/rule&gt;</para>
   <para>True if now is any time in the year 2005</para>
   <para>&lt;rule id="rule2"&gt;</para>
   <para>  &lt;date_expression id="date_expr2" operation="date_spec"&gt;</para>
   <para>    &lt;date_spec years="2005"/&gt;</para>
   <para>  &lt;/date_expression&gt;</para>
   <para>&lt;/rule&gt;</para>
   <para>Equivalent expression. </para><section id="Section1"><para>&lt;rule id="rule3"&gt;</para>
   <para>  &lt;date_expression id="date_expr3" operation="date_spec"&gt;</para>
   <para>    &lt;date_spec hours="9-16" days="1-5"/&gt;</para>
   <para>  &lt;/date_expression&gt;</para>
   <para>&lt;/rule&gt;</para>
   <para>9am-5pm, Mon-Friday</para>
   <para>&lt;rule id="rule4" boolean_op="or"&gt;</para>
   <para>  &lt;date_expression id="date_expr4-1" operation="date_spec"&gt;</para>
   <para>    &lt;date_spec hours="9-16" days="1-5"/&gt;</para>
   <para>  &lt;/date_expression&gt;</para>
   <para>  &lt;date_expression id="date_expr4-2" operation="date_spec"&gt;</para>
   <para>    &lt;date_spec days="6"/&gt;</para>
   <para>  &lt;/date_expression&gt;</para>
   <para>&lt;/rule&gt;</para>
   <para>9am-5pm, Mon-Friday, or all day saturday</para>
   <para>&lt;rule id="rule5" boolean_op="and"&gt;</para>
   <para>  &lt;rule id="rule5-nested1" boolean_op="or"&gt;</para>
   <para>    &lt;date_expression id="date_expr5-1" operation="date_spec"&gt;</para>
   <para>      &lt;date_spec hours="9-16"/&gt;</para>
   <para>    &lt;/date_expression&gt;</para>
   <para>    &lt;date_expression id="date_expr5-2" operation="date_spec"&gt;</para>
   <para>      &lt;date_spec hours="21-23"/&gt;</para>
   <para>    &lt;/date_expression&gt;</para>
   <para>  &lt;/rule&gt;</para>
   <para>  &lt;date_expression id="date_expr5-3" operation="date_spec"&gt;</para>
   <para>    &lt;date_spec days="1-5"/&gt;</para>
   <para>  &lt;/date_expression&gt;</para>
   <para>&lt;/rule&gt;</para>
   <para>9am-5pm or 9pm-12pm, Mon-Friday</para>
   <para>&lt;rule id="rule6" boolean_op="and"&gt;</para>
   <para>  &lt;date_expression id="date_expr6-1" operation="date_spec"&gt;</para>
   <para>    &lt;date_spec weekdays="1"/&gt;</para>
   <para>  &lt;/date_expression&gt;</para>
   <para>  &lt;date_expression id="date_expr6"-2 operation="in_range" start="2005-03-01" end="2005-04-01"/&gt;</para>
   <para>&lt;/rule&gt;</para>
   <para>Mondays in March 2005</para>
   <para>NOTE: Because no time is specified, 00:00:00 is implied.</para>
   <para>This means that the range includes all of 2005-03-01 but none of 2005-04-01.</para>
   <para>You may wish to write end="2005-03-31T23:59:59" to avoid confusion.</para>
   <para/>
   <para>&lt;rule id="rule7" boolean_op="and"&gt;</para>
   <para>  &lt;date_expression id="date_expr7" operation="date_spec"&gt;</para>
   <para>    &lt;date_spec weekdays="5" monthdays="13" moon="4"/&gt;</para>
   <para>  &lt;/date_expression&gt;</para>
   <para>&lt;/rule&gt;</para>
   <para>A full moon on Friday the 13th</para>
   <title>Using Rules to Determine Resource Location</title>
   <para>If the constraint’s outer-most rule evaluates to false, the cluster treats the constraint as if it was not there.  When the rule evaluates to true, the node’s preference for running the resource is updated with the score associated with the rule.</para>
   <para>If this sounds familiar, its because you have been using a simplified syntax for location constraint rules already.  Consider the following location constraint:</para>
   <para>&lt;rsc_location id="dont-run-apache-on-c001n03" rsc="myApacheRsc" score=”-INFINITY” node=”c001n03”/&gt;</para>
   <para>Prevent myApacheRsc from running on c001n03</para>
   <para>This constraint can be more verbosely written as:</para>
   <para>&lt;rsc_location id="dont-run-apache-on-c001n03" rsc="myApacheRsc"&gt;</para>
   <para>    &lt;rule id="dont-run-apache-rule" score="-INFINITY"&gt;</para>
   <para>          &lt;expression id=”dont-run-apache-expr” attribute="#uname" operation="eq" value="c00n03"/&gt;</para>
   <para>    &lt;/rule&gt;</para>
   <para> &lt;/rsc_location&gt;</para>
   <para>Prevent myApacheRsc from running on c001n03 - expanded version</para>
   <para>The advantage of using the expanded form is that one can then add extra clauses to the rule, such as limiting the rule such that it only applies during certain times of the day or days of the week (this is discussed in subsequent sections).</para>
   <para>It also allows us to match on node properties other than its name.  If we rated each machine’s CPU power such that the cluster had the following nodes section:</para>
   <para>   &lt;nodes&gt;</para>
   <para>      &lt;node id="uuid1" uname="c001n01" type="normal"&gt;</para>
   <para>        &lt;instance_attributes id="uuid1-custom_attrs"&gt;</para>
   <para>            &lt;nvpair id="uuid1-cpu_mips" name="cpu_mips" value="1234"/&gt;</para>
   <para>        &lt;/instance_attributes&gt;</para>
   <para>      &lt;/node&gt;</para>
   <para>      &lt;node id="uuid2" uname="c001n02" type="normal"&gt;</para>
   <para>        &lt;instance_attributes id="uuid2-custom_attrs"&gt;</para>
   <para>            &lt;nvpair id="uuid2-cpu_mips" name="cpu_mips" value="5678"/&gt;</para>
   <para>        &lt;/instance_attributes&gt;</para>
   <para>      &lt;/node&gt;</para>
   <para>    &lt;/nodes&gt;</para>
   <para>A sample nodes section for use with score-attribute </para>
   <para>then we could prevent resources from running on underpowered machines with the rule</para>
   <para>&lt;rule id="need-more-power-rule" score="-INFINITY"&gt;</para>
   <para>          &lt;expression id=” need-more-power-expr” attribute="cpu_mips" operation="lt" value="3000"/&gt;</para>
   <para>&lt;/rule&gt;</para>
   <title>Using score-attribute Instead of score</title>
   <para>When using score-attribute instead of score, each node matched by the rule has its score adjusted differently, according to its value for the named node attribute.  Thus in the previous example, if a rule used score-attribute="cpu_mips", c001n01 would have its preference to run the resource increased by 1234 whereas c001n02 would have its preference increased by 5678.</para>
   <title>Using Rules to Control Resource Options</title>
   <para>Often some cluster nodes will be different from their peers, sometimes these differences (the location of a binary or the names of network interfaces) require resources be configured differently depending on the machine they’re hosted on.</para>
   <para>By defining multiple instance_attributes objects for the resource and adding a rule to each, we can easily handle these special cases.</para>
   <para>In the example below, mySpecialRsc will use eth1 and port 9999 when run on node1, eth2 and port 8888 on node2 and default to eth0 and port 9999 for all other nodes. </para>
   <para>&lt;primitive id="mySpecialRsc" class="ocf" type="Special" provider=”me”&gt;</para>
   <para>  &lt;instance_attributes id=”special-node1” score=”3”&gt;</para>
   <para>    &lt;rule id="node1-special-case" score=”INFINITY” &gt;</para>
   <para>      &lt;expression id="node1-special-case-expr" attribute="#uname" operation="eq" value="node1"/&gt;</para>
   <para>    &lt;/rule&gt;</para>
   <para>    &lt;nvpair id="node1-interface" name="interface" value="eth1"/&gt;</para>
   <para>  &lt;/instance_attributes&gt;</para>
   <para>  &lt;instance_attributes id=”special-node2” score=”2” &gt;</para>
   <para>    &lt;rule id="node2-special-case" score=”INFINITY”&gt;</para>
   <para>      &lt;expression id="node2-special-case-expr" attribute="#uname" operation="eq" value="node2"/&gt;</para>
   <para>    &lt;/rule&gt;</para>
   <para>    &lt;nvpair id="node2-interface" name="interface" value="eth2"/&gt;</para>
   <para>    &lt;nvpair id="node2-port" name="port" value="8888"/&gt;</para>
   <para>  &lt;/instance_attributes&gt;</para>
   <para>  &lt;instance_attributes id=”defaults” score=”1” &gt;</para>
   <para>    &lt;nvpair id="default-interface" name="interface" value="eth0"/&gt;</para>
   <para>    &lt;nvpair id="default-port" name="port" value="9999"/&gt;</para>
   <para>  &lt;/instance_attributes&gt;</para>
   <para>&lt;/primitive&gt;</para>
   <para>Defining different resource options based on the node name</para>
   <para>The order in which instance_attributes objects are evaluated is determined by their score (highest to lowest).  If not supplied, score defaults to zero and objects with an equal score are processed in listed order.  If the instance_attributes object does not have a rule or has a rule that evaluates to true, then for any parameter the resource does not yet have a value for, the resource will use the parameter values defined by the instance_attributes object.</para>
   <title>Using Rules to Control Cluster Options</title>
   <para>Controlling cluster options is achieved in much the same manner as specifying different resource options on different nodes.</para>
   <para>The difference is that because they are cluster options, one cannot (or should not because they wont work) use attribute based expressions.  The following example illustrates how to set a different resource-stickiness value during and outside of work hours.  This allows resources to automatically move back to their most preferred hosts, but at a time that (in theory) does not interfere with business activities.</para>
   <para>&lt;rsc_defaults&gt;</para>
   <para>  &lt;meta_attributes id=”core-hours” score=”2”&gt;</para>
   <para>     &lt;rule id="core-hour-rule" score=”0”&gt;</para>
   <para>         &lt;date_expression id="nine-to-five-Mon-to-Fri" operation="date_spec"&gt;</para>
   <para>            &lt;date_spec id=”nine-to-five-Mon-to-Fri-spec” hours="9-17" weekdays="1-5"/&gt;</para>
   <para>         &lt;/date_expression&gt;</para>
   <para>     &lt;/rule&gt;</para>
   <para>     &lt;nvpair id="core-stickiness" name="resource-stickiness" value="INFINITY"/&gt;</para>
   <para>  &lt;/meta_attributes&gt;</para>
   <para>  &lt;meta_attributes id=”after-hours” score=”1” &gt;</para>
   <para>    &lt;nvpair id="after-stickiness" name="resource-stickiness" value="0"/&gt;</para>
   <para>  &lt;/meta_attributes&gt;</para>
   <para>&lt;/rsc_defaults&gt;</para>
   <para>Set resource-stickiness=INFINITY Mon-Fri between 9am and 6pm, and resource-stickiness=0 all other times</para>
   <title>
      <anchor id="EnsuringTimeBasedRulesTakeEffect"/>Ensuring Time Based Rules Take Effect</title>
   <para>A Pacemaker cluster is an event driven system.  As such, it wont recalculate the best place for resources to run in unless something (like a resource failure or configuration change) happens.  This can mean that a location constraint that only allows resource X to run between 9am and 5pm is not enforced.</para>
   <para>If you rely on time based rules, it is essential that you set the cluster-recheck-interval option.  This tells the cluster to periodically recalculate the ideal state of the cluster.  For example, if you set cluster-recheck-interval=5m, then sometime between 9:00 and 9:05 the cluster would notice that it needs to start resource X, and between 17:00 and 17:05 it would realize it needed to be stopped.  </para>
   <para>Note that the timing of the actual start and stop actions depends on what else needs to be performed first.  </para></section></section></section></section><section><title>Using Rules to Determine Resource Location</title>
   <para>If the constraint’s outer-most rule evaluates to false, the cluster treats the constraint as if it was not there.  When the rule evaluates to true, the node’s preference for running the resource is updated with the score associated with the rule.</para>
   <para>If this sounds familiar, its because you have been using a simplified syntax for location constraint rules already.  Consider the following location constraint:</para>
   <para>&lt;rsc_location id="dont-run-apache-on-c001n03" rsc="myApacheRsc" score=”-INFINITY” node=”c001n03”/&gt;</para>
   <para>Prevent myApacheRsc from running on c001n03</para>
   <para>This constraint can be more verbosely written as:</para>
   <para>&lt;rsc_location id="dont-run-apache-on-c001n03" rsc="myApacheRsc"&gt;</para>
   <para>    &lt;rule id="dont-run-apache-rule" score="-INFINITY"&gt;</para>
   <para>          &lt;expression id=”dont-run-apache-expr” attribute="#uname" operation="eq" value="c00n03"/&gt;</para>
   <para>    &lt;/rule&gt;</para>
   <para> &lt;/rsc_location&gt;</para>
   <para>Prevent myApacheRsc from running on c001n03 - expanded version</para>
   <para>The advantage of using the expanded form is that one can then add extra clauses to the rule, such as limiting the rule such that it only applies during certain times of the day or days of the week (this is discussed in subsequent sections).</para>
   <para>It also allows us to match on node properties other than its name.  If we rated each machine’s CPU power such that the cluster had the following nodes section:</para>
   <para>   &lt;nodes&gt;</para>
   <para>      &lt;node id="uuid1" uname="c001n01" type="normal"&gt;</para>
   <para>        &lt;instance_attributes id="uuid1-custom_attrs"&gt;</para>
   <para>            &lt;nvpair id="uuid1-cpu_mips" name="cpu_mips" value="1234"/&gt;</para>
   <para>        &lt;/instance_attributes&gt;</para>
   <para>      &lt;/node&gt;</para>
   <para>      &lt;node id="uuid2" uname="c001n02" type="normal"&gt;</para>
   <para>        &lt;instance_attributes id="uuid2-custom_attrs"&gt;</para>
   <para>            &lt;nvpair id="uuid2-cpu_mips" name="cpu_mips" value="5678"/&gt;</para>
   <para>        &lt;/instance_attributes&gt;</para>
   <para>      &lt;/node&gt;</para>
   <para>    &lt;/nodes&gt;</para>
   <para>A sample nodes section for use with score-attribute </para>
   <para>then we could prevent resources from running on underpowered machines with the rule</para>
   <para>&lt;rule id="need-more-power-rule" score="-INFINITY"&gt;</para>
   <para>          &lt;expression id=” need-more-power-expr” attribute="cpu_mips" operation="lt" value="3000"/&gt;</para>
   <para>&lt;/rule&gt;</para><section><title/><section><title>Using score-attribute Instead of score</title>score-attributescore<para>When using score-attribute instead of score, each node matched by the rule has its score adjusted differently, according to its value for the named node attribute.  Thus in the previous example, if a rule used score-attribute="cpu_mips", c001n01 would have its preference to run the resource increased by 1234 whereas c001n02 would have its preference increased by 5678.</para></section></section></section><section><title>Using Rules to Control Resource Options</title>
   <para>Often some cluster nodes will be different from their peers, sometimes these differences (the location of a binary or the names of network interfaces) require resources be configured differently depending on the machine they’re hosted on.</para>
   <para>By defining multiple instance_attributes objects for the resource and adding a rule to each, we can easily handle these special cases.</para>
   <para>In the example below, mySpecialRsc will use eth1 and port 9999 when run on node1, eth2 and port 8888 on node2 and default to eth0 and port 9999 for all other nodes. </para>
   <para>&lt;primitive id="mySpecialRsc" class="ocf" type="Special" provider=”me”&gt;</para>
   <para>  &lt;instance_attributes id=”special-node1” score=”3”&gt;</para>
   <para>    &lt;rule id="node1-special-case" score=”INFINITY” &gt;</para>
   <para>      &lt;expression id="node1-special-case-expr" attribute="#uname" operation="eq" value="node1"/&gt;</para>
   <para>    &lt;/rule&gt;</para>
   <para>    &lt;nvpair id="node1-interface" name="interface" value="eth1"/&gt;</para>
   <para>  &lt;/instance_attributes&gt;</para>
   <para>  &lt;instance_attributes id=”special-node2” score=”2” &gt;</para>
   <para>    &lt;rule id="node2-special-case" score=”INFINITY”&gt;</para>
   <para>      &lt;expression id="node2-special-case-expr" attribute="#uname" operation="eq" value="node2"/&gt;</para>
   <para>    &lt;/rule&gt;</para>
   <para>    &lt;nvpair id="node2-interface" name="interface" value="eth2"/&gt;</para>
   <para>    &lt;nvpair id="node2-port" name="port" value="8888"/&gt;</para>
   <para>  &lt;/instance_attributes&gt;</para>
   <para>  &lt;instance_attributes id=”defaults” score=”1” &gt;</para>
   <para>    &lt;nvpair id="default-interface" name="interface" value="eth0"/&gt;</para>
   <para>    &lt;nvpair id="default-port" name="port" value="9999"/&gt;</para>
   <para>  &lt;/instance_attributes&gt;</para>
   <para>&lt;/primitive&gt;</para>
   <para>Defining different resource options based on the node name</para>
   <para>The order in which instance_attributes objects are evaluated is determined by their score (highest to lowest).  If not supplied, score defaults to zero and objects with an equal score are processed in listed order.  If the instance_attributes object does not have a rule or has a rule that evaluates to true, then for any parameter the resource does not yet have a value for, the resource will use the parameter values defined by the instance_attributes object.</para></section><section><title>Using Rules to Control Cluster Options</title>
   <para>Controlling cluster options is achieved in much the same manner as specifying different resource options on different nodes.</para>
   <para>The difference is that because they are cluster options, one cannot (or should not because they wont work) use attribute based expressions.  The following example illustrates how to set a different resource-stickiness value during and outside of work hours.  This allows resources to automatically move back to their most preferred hosts, but at a time that (in theory) does not interfere with business activities.</para>
   <para>&lt;rsc_defaults&gt;</para>
   <para>  &lt;meta_attributes id=”core-hours” score=”2”&gt;</para>
   <para>     &lt;rule id="core-hour-rule" score=”0”&gt;</para>
   <para>         &lt;date_expression id="nine-to-five-Mon-to-Fri" operation="date_spec"&gt;</para>
   <para>            &lt;date_spec id=”nine-to-five-Mon-to-Fri-spec” hours="9-17" weekdays="1-5"/&gt;</para>
   <para>         &lt;/date_expression&gt;</para>
   <para>     &lt;/rule&gt;</para>
   <para>     &lt;nvpair id="core-stickiness" name="resource-stickiness" value="INFINITY"/&gt;</para>
   <para>  &lt;/meta_attributes&gt;</para>
   <para>  &lt;meta_attributes id=”after-hours” score=”1” &gt;</para>
   <para>    &lt;nvpair id="after-stickiness" name="resource-stickiness" value="0"/&gt;</para>
   <para>  &lt;/meta_attributes&gt;</para>
   <para>&lt;/rsc_defaults&gt;</para>
   <para>Set resource-stickiness=INFINITY Mon-Fri between 9am and 6pm, and resource-stickiness=0 all other times</para></section><section><title>
      <anchor id="EnsuringTimeBasedRulesTakeE"/>Ensuring Time Based Rules Take Effect</title>
   <para>A Pacemaker cluster is an event driven system.  As such, it wont recalculate the best place for resources to run in unless something (like a resource failure or configuration change) happens.  This can mean that a location constraint that only allows resource X to run between 9am and 5pm is not enforced.</para>
   <para>If you rely on time based rules, it is essential that you set the cluster-recheck-interval option.  This tells the cluster to periodically recalculate the ideal state of the cluster.  For example, if you set cluster-recheck-interval=5m, then sometime between 9:00 and 9:05 the cluster would notice that it needs to start resource X, and between 17:00 and 17:05 it would realize it needed to be stopped.  </para>
   <para>Note that the timing of the actual start and stop actions depends on what else needs to be performed first.  </para>
   </section>
   </section>
   <section id="advanced-config"><title>Advanced Configuration</title>
      <section>
	<anchor id="ConnectingtotheClusterConfig"/>
	<title>Connecting to the Cluster Configuration from a Remote Machine</title>
   <para>Provided Pacemaker is installed on a machine, it is possible to connect to the cluster even if the machine itself is not a part of it.   To do this, one simply sets up a number of environment variables and runs the same commands as you would when working on a cluster node.</para>
   <informaltable frame="all">
      <tgroup cols="2">
         <thead>
            <row>
               <entry>
                  <para>Environment Variable</para>
               </entry>
               <entry>
                  <para>Description</para>
               </entry>
            </row>
         </thead><tbody><row>
            <entry>
               <para>CIB_user</para>
            </entry>
            <entry>
               <para>The user to connect as.  Needs to be part of the hacluster group on the target host.  Defaults to <emphasis>$USER</emphasis>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>CIB_password</para>
            </entry>
            <entry>
               <para>The user’s password.  Read from the command line if unset</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>CIB_server</para>
            </entry>
            <entry>
               <para>The host to contact.  Defaults to <emphasis>localhost</emphasis>.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>CIB_port</para>
            </entry>
            <entry>
               <para>The port on which to contact the server.  Required.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>Variables used to connect to remote instances of the CIB </para>
   <para>So if c001n01 is an active cluster node and is listening on 1234 for connections, and someguy is a member of the hacluster group.  Then the following would prompt for someguy’s password and return the cluster’s current configuration:</para>
   <para>export CIB_port=1234; export CIB_server=c001n01; export CIB_user=someguy; </para>
   <para>cibadmin -Q</para>
   <para>For security reasons, the cluster does not listen remote connections by default.  If you wish to allow remote access, you need to set the remote-tls-port (encrypted) or remote-open-port (unencrypted) top-level options (ie. those kept in the cib tag , like num_updates and epoch). </para>
   <informaltable frame="all">
      <tgroup cols="2">
         <thead>
            <row>
               <entry>
                  <para>Field</para>
               </entry>
               <entry>
                  <para>Description</para>
               </entry>
            </row>
         </thead><tbody><row>
            <entry>
               <para>remote-tls-port</para>
            </entry>
            <entry>
               <para>Listen for encrypted remote connections on this port.  Default: <emphasis>none</emphasis>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>remote-clear-port</para>
            </entry>
            <entry>
               <para>Listen for plaintext remote connections on this port.  Default: <emphasis>none</emphasis>
               </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>Extra top-level CIB options for remote access </para></section><section><title>
      <anchor id="SpecifyingWhenRecurringActioncopy"/>Specifying When Recurring Actions are Performed</title>
   <para>By default, recurring actions are scheduled relative to when the resource started.  So if your resource was last started at 14:32 and you have a backup set to be performed every 24 hours, then the backup will always run at in the middle of the business day - hardly desirable.</para>
   <para>To specify a date/time that the operation should be relative to, set the operation’s interval-origin.  The cluster uses this point to calculate the correct start-delay such that the operation will occur at origin + (interval * N).</para>
   <para>So if the operation’s interval is 24h, it’s interval-origin is set to 02:00 and it is currently 14:32, then the cluster would initiate the operation with a start delay of 11 hours and 28 minutes.  If the resource is moved to another node before 2am, then the operation is of course cancelled.</para>
   <para>The value specified for interval and interval-origin can be any date/time conforming to the <ulink url="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 standard</ulink>.  By way of example, to specify an operation that would run on the first Monday of 2009 and every monday after that you would add: </para>
   <para>&lt;op id=”my-weekly-action” name=”custom-action” interval=”P7D” interval-origin=”2009-W01-1”/&gt; </para></section><section><title>Moving Resources</title><section><title>Manual Intervention</title>
   <para>There are primarily two occasions when you would want to move a resource from it’s current location:  when the whole node  is under maintenance and when a single resource needs to be moved.</para>
   <para>In the case where everything needs to move, since everything eventually comes down to a score, you could create constraints for every resource you have preventing it from running on that node.  While the configuration can seem convoluted at times, not even we would require this of administrators.</para>
   <para>Instead one can set a special node attribute which tells the cluster “don’t let anything run here”.  There is even a helpful tool to help query and set it called crm_standby.  To check the standby status of the current machine, simply run:</para>
   <para>crm_standby --get-value</para>
   <para>A value of true indicates that the node is NOT able to host any resources and a value of false indicates that it CAN.  You can also check the status of other nodes in the cluster by specifying the --node-uname option.  Eg.</para>
   <para>crm_standby --get-value --node-uname sles-2</para>
   <para>To change the current node’s standby status, use --attr-value instead of --get-value.  Eg.</para>
   <para>crm_standby --attr-value</para>
   <para>Again, you can change another host’s value by supplying a host name with --node-uname.</para>
   <para/>
   <para>When only one resource is required to move, we do this by creating location constraints.  However once again we provide a user friendly shortcut as part of the crm_resource command which creates and modifies the extra constraints for you.  If Email was running on sles-1 and you wanted it moved to a specific location, the command would look something like:</para>
   <para>crm_resource -M -r Email -H sles-2</para>
   <para>Behind the scenes, the tool will create the following location constraint:</para>
   <para>         &lt;rsc_location rsc=”Email” node=”sles-2” score=”INFINITY”/&gt;</para>
   <para>It is important to note that subsequent invocations of crm_resource -M are not cumulative.  So if you ran:</para>
   <para>crm_resource -M -r Email -H sles-2</para>
   <para>crm_resource -M -r Email -H sles-3</para>
   <para>then it is as if you had never performed the first command.</para>
   <para>To allow the resource to move back again, use:</para>
   <para>crm_resource -U -r Email</para>
   <para>Note the use of the word allow.  The resource can move back to its original location but, depending on resource stickiness, it may stay where it is.  To be absolutely certain that it moves back to sles-1, move it there before issuing the call to crm_resource -U: </para>
   <para>crm_resource -M -r Email -H sles-1</para>
   <para>crm_resource -U -r Email</para>
   <para/>
   <para>Alternatively, if you only care that the resource should be moved from its current location, try </para>
   <para>crm_resource -M -r Email</para>
   <para>Which will instead create a negative constraint.  Eg.</para>
   <para> &lt;rsc_location rsc=”Email” node=”sles-1” score=”-INFINITY”/&gt;</para>
   <para>This will achieve the desired effect but will also have long-term consequences.  As the tool will warn you, the creation of a     -INFINITY constraint will prevent the resource from running on that node until crm_resource -U is used.  This includes the situation where every other cluster node is no longer available.</para>
   <para>In some cases, such as when resource stickiness is set to INFINITY, it is possible that you will end up with the problem described in <link linkend="">What if Two Nodes Have the Same Score</link>.  The tool can detect some of these cases and deals with them by also creating both a positive and negative constraint.  Eg. </para>
   <para>        Email prefers sles-1 with a score of -INFINITY</para>
   <para>        Email prefers sles-2 with a score of INFINITY</para>
   <para>which has the same long-term consequences as discussed earlier.</para></section><section><title>
      <anchor id="MigratingDuetoFailure"/>Moving Resources Due to Failure</title>
   <para>New in 1.0 is the concept of a migration threshold<footnote>
         <para> The naming of this option was unfortunate as it is easily confused with true migration, the process of moving a resource from one node to another without stopping it.  Xen virtual guests are the most common example of resources that can be migrated in this manner.</para>
      </footnote>.  Simply define migration-threshold=N for a resource and it will migrate to a new node after N failures. There is no threshold defined by default.  To determine the resource’s current failure status and limits, use crm_mon --failcounts</para>
   <para>By default, once the threshold has been reached, node will no longer be allowed to run the failed resource until the administrator manually resets the resource’s failcount using crm_failcount (after hopefully first fixing the failure’s cause).  However it is possible to expire them by setting the resource’s failure-timeout option.  </para>
   <para>So a setting of migration-threshold=2 and failure-timeout=60s would cause the resource to move to a new node after 2 failures and potentially allow it to move back (depending on the stickiness and constraint scores) after one minute.</para>
   <para>There are two exceptions to the migration threshold concept and occur when a resource either fails to start or fails to stop.  Start failures cause the failcount to be set to INFINITY and thus always cause the resource to move immediately.</para>
   <para>Stop failures are slightly different and crucial.  If a resource fails to stop and STONITH is enabled, then the cluster will fence the node in order to be able to start the resource elsewhere.  If STONITH is not enabled, then the cluster has no way to continue and will not try to start the resource elsewhere, but will try to stop it again after the failure timeout.</para>
   <para>Note: Please read the section on <link linkend="">Ensuring Time Based Rules Take Effect</link> before enabling this option. </para></section><section><title>Moving Resources Due to Connectivity Changes</title>
   <para>Setting up the cluster to move resources when external connectivity is lost, is a two-step process.</para>
   <para>
      <emphasis>Tell Pacemaker to monitor connectivity</emphasis>
   </para>
   <para>To do this, you need to add a ping resource to the cluster.  The ping resource uses the system utility of the same name to a test if list of machines (specified by DNS hostname or IPv4/ IPv6 address) are reachable and uses the results to maintain a node attribute normally called pingd<footnote>
         <para> The attribute name is customizable which allows multiple ping groups to be defined</para>
      </footnote>.</para>
   <para>NOTE: Older versions of Heartbeat required users to add ping nodes to ha.cf - this is no longer required.</para>
   <para>NOTE: Older versions of Pacemaker used a custom binary called pingd for this functionality, this is now deprecated in favor of ping.  If your version of Pacemaker does not contain the ping agent, you can download the latest version from:                 <ulink url="http://hg.clusterlabs.org/pacemaker/stable-1.0/raw-file/tip/extra/resources/ping">http://hg.clusterlabs.org/pacemaker/stable-1.0/raw-file/tip/extra/resources/ping</ulink>
   </para>
   <para/>
   <para>Normally the resource will run on all cluster nodes, which means that you’ll need to create a clone.  A template for this can be found below along with a description of the most interesting parameters.</para>
   <informaltable frame="all">
      <tgroup cols="2">
         <thead>
            <row>
               <entry>
                  <para>Field</para>
               </entry>
               <entry>
                  <para>Description</para>
               </entry>
            </row>
         </thead><tbody><row>
            <entry>
               <para>dampen</para>
            </entry>
            <entry>
               <para>The time to wait (dampening) for further changes occur.  Use this to prevent a resource from bouncing around the cluster when cluster nodes notice the loss of connectively at slightly different times. </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>multiplier</para>
            </entry>
            <entry>
               <para>The number by which to multiply the number of connected ping nodes by.  Useful when there are multiple ping nodes configured.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>host_list</para>
            </entry>
            <entry>
               <para>The machines to contact in order to determine the current connectivity status.  Allowed values include resolvable DNS hostnames, IPv4 and IPv6 addresses.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>Standard ping options</para>
   <para>&lt;clone id="Connected"&gt;</para>
   <para>  &lt;primitive id="ping" provider="pacemaker" class="ocf" type="ping"&gt;</para>
   <para>    &lt;instance_attributes id="ping-attrs"&gt;</para>
   <para>         &lt;nvpair id="pingd-dampen" name="dampen" value="5s"/&gt;</para>
   <para>         &lt;nvpair id="pingd-multiplier" name="multiplier" value="1000"/&gt;</para>
   <para>         &lt;nvpair id="pingd-hosts" name="host_list" value="my.gateway.com www.bigcorp.com"/&gt;</para>
   <para>    &lt;/instance_attributes&gt;</para>
   <para>     &lt;operations&gt;</para>
   <para>         &lt;op id="ping-monitor-60s" interval="60s" name="monitor"/&gt;</para>
   <para>     &lt;/operations&gt;</para>
   <para>  &lt;/primitive&gt;</para>
   <para>&lt;/clone&gt;</para>
   <para>An example ping cluster resource, checks node connectivity once every minute</para>
   <para>
      <emphasis>Tell Pacemaker how to interpret the connectivity data</emphasis>
   </para>
   <para>NOTE: Before reading the following, please make sure you have read and understood the <link linkend="">Rules</link> section above.</para>
   <para>There are a number of ways to use the connectivity data provided by Heartbeat.  The most common setup is for people to have a single ping node and want to prevent the cluster from running a resource on any unconnected node.</para>
   <para>&lt;rsc_location id="WebServer-no-connectivity" rsc="Webserver"&gt;</para>
   <para>  &lt;rule id="ping-exclude-rule" score="-INFINITY" &gt;</para>
   <para>    &lt;expression id="ping-exclude" attribute="pingd" operation="not_defined"/&gt;</para>
   <para>  &lt;/rule&gt;</para>
   <para>&lt;/rsc_location&gt;</para>
   <para>Don’t run on unconnected nodes</para>
   <para>A more complex setup is to have a number of ping nodes configured.  You can require the cluster to only run resources on nodes that can connect to all (or a minimum subset) of them </para>
   <para>&lt;rsc_location id="WebServer-connectivity" rsc="Webserver"&gt;</para>
   <para>  &lt;rule id="ping-prefer-rule" score="-INFINITY" &gt;</para>
   <para>    &lt;expression id="ping-prefer" attribute="pingd" operation="lt" value=”3000”/&gt;</para>
   <para>  &lt;/rule&gt;</para>
   <para>&lt;/rsc_location&gt; </para>
   <para>Run only on nodes connected to 3 or more ping nodes (assumes multiplier is set to 1000)</para>
   <para>or instead you can tell the cluster only to prefer nodes with the most connectivity. Just be sure to set the multiplier to a value higher than that of resource-stickiness (and don’t set either of them to INFINITY).</para>
   <para>&lt;rsc_location id="WebServer-connectivity" rsc="Webserver"&gt;</para>
   <para>  &lt;rule id="ping-prefer-rule" score-attribute="pingd" &gt;</para>
   <para>    &lt;expression id="ping-prefer" attribute="pingd" operation="defined"/&gt;</para>
   <para>  &lt;/rule&gt;</para>
   <para>&lt;/rsc_location&gt; </para>
   <para>Prefer the node with the most connected ping nodes</para>
   <para>It is perhaps easier to think of this in terms of the simple constraints that the cluster translates it into.  For example, if sles-1 is connected to all 5 ping nodes but sles-2 is only connected to 2, then it would be as if you instead had the following constraints in your configuration:</para>
   <para>&lt;rsc_location id=”ping-1” rsc=”Webserver” node=”sles-1” score=”5000”/&gt;</para>
   <para>&lt;rsc_location id=”ping-2” rsc=”Webserver” node=”sles-2” score=”2000”/&gt;</para>
   <para>How the cluster translates the pingd constraint </para>
   <para>The advantage being that you don’t have to manually update them whenever your network connectivity changes.</para>
   <para>You can also combine the concepts above into something even more complex.  The example below shows how you can prefer the node with the most connected ping nodes provided they have connectivity to at least three (assuming multiplier is set to 1000).</para>
   <para>&lt;rsc_location id="WebServer-connectivity" rsc="Webserver"&gt;</para>
   <para>  &lt;rule id="ping-exclude-rule" score="-INFINITY" &gt;</para>
   <para>    &lt;expression id="ping-exclude" attribute="pingd" operation="lt" value=”3000”/&gt;</para>
   <para>  &lt;/rule&gt;</para>
   <para>  &lt;rule id="ping-prefer-rule" score-attribute="pingd" &gt;</para>
   <para>    &lt;expression id="ping-prefer" attribute="pingd" operation="defined"/&gt;</para>
   <para>  &lt;/rule&gt;</para>
   <para>&lt;/rsc_location&gt; </para>
   <para>A more complex example of choosing a location based on connectivity  </para></section><section><title>Resource Migration</title>
   <para>Some resources, such as Xen virtual guests, are able to move to another location without lose of state.  We call this resource migration and is different from the normal practice of stopping the resource on the first machine and starting it elsewhere.</para>
   <para>Not all resources are able to migrate, see the Migration Checklist below, and those that can wont do so in all situations.  Conceptually there are two requirements from which the other prerequisites follow: </para>
   <orderedlist>
      <listitem>
         <para>the resource must be active and healthy at the old location </para>
      </listitem>
      <listitem>
         <para>everything required for the resource to run must be available on both the old and new locations</para>
      </listitem>
   </orderedlist>
   <para>The cluster is able to accommodate both push and pull migration models by requiring the resource agent to support two new actions: migrate_to (performed on the current location) and migrate_from (performed on the destination).</para>
   <para>In push migration, the process on the current location transfers the to the new location where is it later activated.  In this scenario, most of the work would be done in the migrate_to action and, if anything, the activation would occur during migrate_from.</para>
   <para>Conversely for pull, the migrate_to action is practically empty and migrate_from does most of the work, extracting the relevant resource state from the old location and activating it.</para>
   <para>There is no wrong or right way to implement migration for your service, as long as it works. </para><section><title>Migration Checklist</title>
   <orderedlist>
      <listitem>
         <para>The resource may not be a clone.</para>
      </listitem>
      <listitem>
         <para>The resource must use an OCF style agent.</para>
      </listitem>
      <listitem>
         <para>The resource must not be in a failed or degraded state.</para>
      </listitem>
      <listitem>
         <para>The resource must not, directly or indirectly, depend on any primitive or group resources.</para>
      </listitem>
      <listitem>
         <para>The resources must support two new actions: migrate_to and migrate_from and advertise them in its metadata.</para>
      </listitem>
      <listitem>
         <para>The resource must have the allow-migrate meta-attribute set to true (not the default).</para>
      </listitem>
   </orderedlist>
   <para>If the resource depends on a clone, and at the time the resource needs to be move, the clone has instances that are stopping and instances that are starting, then the resource will be moved in the traditional manner.  The Policy Engine is not yet able to model this situation correctly and so takes the safe (yet less optimal) path. </para></section></section></section><section><title>
      <anchor id="ReusingRulesandSetsofOption"/>Reusing Rules, Options and Sets of Operations</title>
   <para>Sometimes a number of constraints need to use the same set of rules and resources need to set the same options an parameters.  To simplify this situation, you can refer to an existing object using an id-ref instead of an id.</para>
   <para>So if for one resource you have</para>
   <para>&lt;rsc_location id="WebServer-connectivity" rsc="Webserver"&gt;</para>
   <para>  &lt;rule id="ping-prefer-rule" score-attribute="pingd" &gt;</para>
   <para>    &lt;expression id="ping-prefer" attribute="pingd" operation="defined"/&gt;</para>
   <para>  &lt;/rule&gt;</para>
   <para>&lt;/rsc_location&gt;</para>
   <para>Then instead of duplicating the rule for all your other resources, you can instead specify</para>
   <para>&lt;rsc_location id="WebDB-connectivity" rsc="WebDB"&gt;</para>
   <para>        &lt;rule id-ref=”ping-prefer-rule”/&gt;</para>
   <para>&lt;/rsc_location&gt; </para>
   <para>Illustration of the ability to reference rule from other constraints</para>
   <para>NOTE: The cluster will insist that the rule exists somewhere.  Attempting to add a reference to a non-existing rule will cause a validation failure, as will attempting to remove a rule that is referenced elsewhere.</para>
   <para>The same principle applies for meta_attributes and instance_attributes as illustrated in the example below</para>
   <para>&lt;primitive id="mySpecialRsc" class="ocf" type="Special" provider=”me”&gt;</para>
   <para>  &lt;instance_attributes id=”mySpecialRsc-attrs” score=”1” &gt;</para>
   <para>     &lt;nvpair id="default-interface" name="interface" value="eth0"/&gt;</para>
   <para>     &lt;nvpair id="default-port" name="port" value="9999"/&gt;</para>
   <para>  &lt;/instance_attributes&gt;</para>
   <para>  &lt;meta_attributes id=”mySpecialRsc-options”&gt;</para>
   <para>     &lt;nvpair id="failure-timeout" name="failure-timeout" value="5m"/&gt;</para>
   <para>     &lt;nvpair id="migration-threshold" name="migration-threshold" value="1"/&gt;</para>
   <para>     &lt;nvpair id="stickiness" name="resource-stickiness" value="0"/&gt;</para>
   <para>   &lt;/meta_attributes&gt;</para>
   <para>   &lt;operations id=”health-checks”&gt;</para>
   <para>       &lt;op id="health-check" name="monitor" interval="60s"/&gt;</para>
   <para>       &lt;op id="health-check" name="monitor" interval="30min"/&gt;</para>
   <para>    &lt;/operations&gt;</para>
   <para>&lt;/primitive&gt;</para>
   <para>&lt;primitive id="myOtherlRsc" class="ocf" type="Other" provider=”me”&gt;</para>
   <para>  &lt;instance_attributes id-ref=”mySpecialRsc-attrs”/&gt;</para>
   <para>  &lt;meta_attributes id-ref=”mySpecialRsc-options”/&gt;</para>
   <para>  &lt;operations id-ref=”health-checks”/&gt;</para>
   <para>&lt;/primitive&gt;</para>
   <para>Illustration of the ability to reference attributes, options and operations from other resources</para>
   <para/>
      </section>
   </section>
   <section id="advanced-rsc"><title>Advanced Resource Types</title>
     <section>
       <anchor id="GroupsASyntacticShortcut"/>
       <title>Groups - A Syntactic Shortcut</title>
   <para>One of the most common elements of a cluster is a set of resources that need to be located together, start sequentially and stop in the reverse order.  To simplify this configuration we support the concept of groups.  </para>
   <para>&lt;group id=”shortcut”&gt;</para>
   <para>  &lt;primitive id="Public-IP" class="ocf" type="IPaddr" provider=”heartbeat”&gt;</para>
   <para>    &lt;instance_attributes id="params-public-ip"&gt;</para>
   <para>          &lt;nvpair id="public-ip-addr" name="ip" value="1.2.3.4"/&gt;</para>
   <para>    &lt;/instance_attributes&gt;</para>
   <para>  &lt;/primitive&gt;</para>
   <para>  &lt;primitive id="Email" class="lsb" type="exim"/&gt;</para>
   <para>&lt;/group&gt;</para>
   <para>An example group</para>
   <para>Although the example above contains only two resources, there is no limit to the number of resources a group can contain.  The example is also sufficient to explain the fundamental properties of a group:</para>
   <orderedlist>
      <listitem>
         <para>Resources are started in the order they appear in (Public-IP first, then Email)</para>
      </listitem>
      <listitem>
         <para>Resources are stopped in the reverse order to which they appear in (Email first, then Public-IP)</para>
      </listitem>
      <listitem>
         <para>If a resource in the group can’t run anywhere, then nothing after that is allowed to run</para>
      </listitem>
   </orderedlist>
   <para>The group above is logically equivalent to writing:</para>
   <para>&lt;configuration&gt;</para>
   <para>  &lt;resources&gt;</para>
   <para>    &lt;primitive id="Public-IP" class="ocf" type="IPaddr" provider=”heartbeat”&gt;</para>
   <para>      &lt;instance_attributes id="params-public-ip"&gt;</para>
   <para>            &lt;nvpair id="public-ip-addr" name="ip" value="1.2.3.4"/&gt;</para>
   <para>      &lt;/instance_attributes&gt;</para>
   <para>    &lt;/primitive&gt;</para>
   <para>    &lt;primitive id="Email" class="lsb" type="exim"/&gt;</para>
   <para>  &lt;/resources&gt;</para>
   <para>  &lt;constraints&gt;</para>
   <para>        &lt;rsc_colocation id=”xxx” rsc=”Email” with-rsc=”Public-IP” score=”INFINITY”/&gt;</para>
   <para>        &lt;rsc_order id=”yyy” first=”Public-IP then=”Email””/&gt;</para>
   <para>  &lt;/constraints&gt;</para>
   <para>&lt;/configuration&gt;</para>
   <para>How the cluster sees a group resource</para>
   <para>Obviously as the group grows bigger, the reduced configuration effort can become significant.</para><section><title>Properties</title>
   <informaltable frame="all">
      <tgroup cols="2">
         <thead>
            <row>
               <entry>
                  <para>Field</para>
               </entry>
               <entry>
                  <para>Description</para>
               </entry>
            </row>
         </thead><tbody><row>
            <entry>
               <para>id</para>
            </entry>
            <entry>
               <para>Your name for the group</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section><section><title>Options</title>
   <para>Options inherited from <link linkend="">simple resources</link>: priority, target-role, is-managed</para></section><section><title>Using Groups</title><section><title>Instance Attributes</title>
   <para>Groups have no instance attributes, however any that are set here will be inherited by the group’s children. </para></section><section><title>Contents</title>
   <para>Groups may only contain a collection of <link linkend="">primitive</link> cluster resources.  To refer to the child of a group resource, just use the child’s id instead of the group’s.</para></section><section><title>Constraints</title>
   <para>Although it is possible to reference the group’s children in constraints, it is usually preferable to use the group’s name instead.</para>
   <para>&lt;constraints&gt;</para>
   <para>    &lt;rsc_location id=”group-prefers-node1” rsc=”shortcut” node=”node1” score=”500”/&gt;</para>
   <para>    &lt;rsc_colocation id=”webserver-with-group” rsc=”Webserver” with-rsc=”shortcut”/&gt;</para>
   <para>    &lt;rsc_order id=”start-group-then-webserver” first=”Webserver” then=”shortcut”/&gt;</para>
   <para>&lt;/constraints&gt;</para>
   <para>Example constraints involving groups</para></section><section><title>Stickiness</title>
   <para>Stickiness, the measure of how much a resource wants to stay where it is, is additive in groups.  Every active member of the group will contribute its stickiness value to the group’s total.  So if the default resource-stickiness is 100 a group has seven members, five of which are active, then the group as a whole will prefer its current location with a score of 500.</para></section></section></section><section><title>
      <anchor id="ClonesResourcesThatShouldb"/>Clones - Resources That Should be Active on Multiple Hosts</title>
   <para>Clones were initially conceived as a convenient way to start N instances of an IP resource and have them distributed throughout the cluster for load balancing. They have turned out to quite useful for a number of purposes including integrating with Red Hat's DLM, the fencing subsystem and OCFS2.</para>
   <para>You can clone any resource provided the resource agent supports it.</para>
   <para>Three types of cloned resources exist.</para>
   <orderedlist>
      <listitem>
         <para>Anonymous</para>
      </listitem>
      <listitem>
         <para>Globally Unique</para>
      </listitem>
      <listitem>
         <para>Stateful</para>
      </listitem>
   </orderedlist>
   <para/>
   <para>Anonymous clones are the simplest type.  These resources behave completely identically everywhere they are running.  Because of this, there can only be one copy of an anonymous clone active per machine.</para>
   <para>Globally unique clones are distinct entities. A copy of the clone running on one machine is not equivalent to another instance on another node. Nor would any two copies on the same node be equivalent.</para>
   <para>Stateful clones are covered later in the <link linkend="">Advanced Resources - Multi-state</link> section.</para>
   <para>&lt;clone id=”apache-clone”&gt;</para>
   <para>    &lt;meta_attributes id="apache-clone-meta"&gt;</para>
   <para>          &lt;nvpair id="apache-unique" name="globally-unique" value="false"/&gt;</para>
   <para>    &lt;/meta_attributes&gt;</para>
   <para>    &lt;primitive id="apache" class="lsb" type="apache"/&gt;</para>
   <para>&lt;/clone&gt;</para>
   <para>An example clone</para><section><title>Properties</title></section><section><title/>
   <informaltable frame="all">
      <tgroup cols="2">
         <thead>
            <row>
               <entry>
                  <para>Field</para>
               </entry>
               <entry>
                  <para>Description</para>
               </entry>
            </row>
         </thead><tbody><row>
            <entry>
               <para>id</para>
            </entry>
            <entry>
               <para>Your name for the clone</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section><section><title>Options</title>
   <para>Options inherited from <link linkend="">simple resources</link>: priority, target-role, is-managed</para>
   <informaltable frame="all">
      <tgroup cols="2">
         <thead>
            <row>
               <entry>
                  <para>Field</para>
               </entry>
               <entry>
                  <para>Description</para>
               </entry>
            </row>
         </thead><tbody><row>
            <entry>
               <para>clone-max</para>
            </entry>
            <entry>
               <para>How many copies of the resource to start.  Defaults to the number of nodes in the cluster.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>clone-node-max</para>
            </entry>
            <entry>
               <para>How many copies of the resource can be started on a single node.  Defaults to 1.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>notify</para>
            </entry>
            <entry>
               <para>When stopping or starting a copy of the clone, tell all the other copies beforehand and when the action was successful. Allowed values: true, <emphasis>false</emphasis>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>globally-unique</para>
            </entry>
            <entry>
               <para>Does each copy of the clone perform a different function?  Allowed values: <emphasis>true</emphasis>, false</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>ordered</para>
            </entry>
            <entry>
               <para>Should the copies be started in series (instead of in parallel). Allowed values: true, <emphasis>false</emphasis>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>interleave</para>
            </entry>
            <entry>
               <para>Changes the behavior of ordering constraints (between clones/masters) so that instances can start/stop as soon as their peer instance has (rather than waiting for every instance of the other clone has).  Allowed values: true, <emphasis>false</emphasis>
               </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>Clone specific configuration options</para></section><section><title>Using Clones</title><section><title>Instance Attributes</title>
   <para>Clones have no instance attributes, however any that are set here will be inherited by the clone’s children. </para></section><section><title>Contents</title>
   <para>Clones must contain exactly one group or one regular resource.</para>
   <para>You should never reference the name of a clone’s child. If you think you need to do this, you probably need to re-evaluate your design.</para></section><section><title>Constraints</title>
   <para>In most cases, a clone will have a single copy on each active cluster node.  However if this is not the case, you can indicate which nodes the cluster should to preferentially assign copies to with resource location constraints.  These constraints are written no differently to those for regular resources except that the clone’s id is used.   </para>
   <para>Ordering constraints behave slightly differently for clones.  In the example below, apache-stats will wait until all copies of the clone that need to be started have done so before being started itself.  Only if no copies can be started will apache-stats be prevented from being active.  Additionally, the clone will wait for apache-stats to be stopped before stopping the clone.</para>
   <para>Colocation of a regular (or group) resource with a clone means that the resource can run on any machine with an active copy of the clone.  The cluster will choose a copy based on where the clone is running and the rsc resource’s own location preferences.</para>
   <para>Colocation between clones is also possible.  In such cases, the set of allowed locations for the rsc clone is limited to nodes on which the with clone is (or will be) active.  Allocation is then performed as-per-normal.</para>
   <para>&lt;constraints&gt;</para>
   <para>    &lt;rsc_location id=”clone-prefers-node1” rsc=”apache-clone node=”node1” score=”500”/&gt;</para>
   <para>    &lt;rsc_colocation id=”stats-with-clone” rsc=”apache-stats” with=”apache-clone”/&gt;</para>
   <para>    &lt;rsc_order id=”start-clone-then-stats” first=”apache-clone” then=”apache-stats”/&gt;</para>
   <para>&lt;/constraints&gt;</para>
   <para>Example constraints involving clones</para></section><section><title>Stickiness</title>
   <para>To achieve a stable allocation pattern, clones are slightly sticky by default.  If no value for resource-stickiness is provided, the clone will use a value of 1.  Being a small value, it causes minimal disturbance to the score calculations of other resources but is enough to prevent Pacemaker from needlessly moving copies around the cluster. </para></section><section><title>Resource Agent Requirements</title>
   <para>Any resource can be used as an anonymous clone as it requires no additional support from the resource agent.  Whether it makes sense to do so depends on your resource and its resource agent.</para>
   <para>Globally unique clones do require some additional support in the resource agent.  In particular, it must only respond with      ${OCF_SUCCESS} if the node has that exact instance active. All other probes for instances of the clone should result in      ${OCF_NOT_RUNNING}. Unless of course they are failed, in which case they should return one of the other OCF error codes.</para>
   <para>Copies of a clone are identified by appending a colon and a numerical offset.  Eg. apache:2</para>
   <para>Resource agents can find out how many copies there are by examining the OCF_RESKEY_CRM_meta_clone_max environment variable and which copy it is by examining OCF_RESKEY_CRM_meta_clone.</para>
   <para>You should not make any assumptions (based on OCF_RESKEY_CRM_meta_clone) about which copies are active.  In particular, the list of active copies will not always be an unbroken sequence, nor always start at 0.</para></section><section><title>Notifications</title>
   <para>Supporting notifications requires the notify action to be implemented.  Once supported, the notify action will be passed a number of extra variables which, when combined with additional context, can be used to calculate the current state of the cluster and what is about to happen to it.</para>
   <para> </para>
   <informaltable frame="all">
      <tgroup cols="2">
         <thead>
            <row>
               <entry>
                  <para>Variable</para>
               </entry>
               <entry>
                  <para>Description</para>
               </entry>
            </row>
         </thead><tbody><row>
            <entry>
               <para>OCF_RESKEY_CRM_meta_notify_type</para>
            </entry>
            <entry>
               <para>Allowed values: pre, post</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>OCF_RESKEY_CRM_meta_notify_operation</para>
            </entry>
            <entry>
               <para>Allowed values: start, stop</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>OCF_RESKEY_CRM_meta_notify_start_resource</para>
            </entry>
            <entry>
               <para>Resources to be started</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>OCF_RESKEY_CRM_meta_notify_stop_resource</para>
            </entry>
            <entry>
               <para>Resources to be stopped</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>OCF_RESKEY_CRM_meta_notify_active_resource</para>
            </entry>
            <entry>
               <para>Resources the that are running</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>OCF_RESKEY_CRM_meta_notify_inactive_resource</para>
            </entry>
            <entry>
               <para>Resources the that are not running</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>OCF_RESKEY_CRM_meta_notify_start_uname</para>
            </entry>
            <entry>
               <para>Nodes on which resources will be started</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>OCF_RESKEY_CRM_meta_notify_stop_uname</para>
            </entry>
            <entry>
               <para>Nodes on which resources will be stopped</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>OCF_RESKEY_CRM_meta_notify_active_uname</para>
            </entry>
            <entry>
               <para>Nodes on which resources are running</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>OCF_RESKEY_CRM_meta_notify_inactive_uname</para>
            </entry>
            <entry>
               <para>Nodes on which resources are not running</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>Environment variables supplied with Clone notify actions</para>
   <para>The variables come in pairs, such as OCF_RESKEY_CRM_meta_notify_start_resource and OCF_RESKEY_CRM_meta_notify_start_uname and should be treated as an array of whitespace separated elements.</para>
   <para>Thus in order to indicate that clone:0 will be started on sles-1, clone:2 will be started on sles-3, and clone:3 will be started on sles-2, the cluster would set</para>
   <para>OCF_RESKEY_CRM_meta_notify_start_resource=”clone:0 clone:2 clone:3”</para>
   <para>OCF_RESKEY_CRM_meta_notify_start_uname=”sles-1 sles-3 sles-2”</para>
   <para>Example notification variables</para></section><section><title>Proper Interpretation of Notification Environment Variables</title>
   <para>Pre-notification (stop)</para>
   <orderedlist>
      <listitem>
         <para>Active resources: $OCF_RESKEY_CRM_meta_notify_active_resource</para>
      </listitem>
      <listitem>
         <para>Inactive resources: $OCF_RESKEY_CRM_meta_notify_inactive_resource</para>
      </listitem>
      <listitem>
         <para>Resources to be started: $OCF_RESKEY_CRM_meta_notify_start_resource</para>
      </listitem>
      <listitem>
         <para>Resources to be stopped: $OCF_RESKEY_CRM_meta_notify_stop_resource</para>
      </listitem>
   </orderedlist>
   <para/>
   <para>Post-notification (stop) / Pre-notification (start)</para>
   <orderedlist>
      <listitem>
         <para>Active resources:</para>
      </listitem>
   </orderedlist>
   <para>        $OCF_RESKEY_CRM_meta_notify_active_resource</para>
   <para>                minus $OCF_RESKEY_CRM_meta_notify_stop_resource </para>
   <orderedlist>
      <listitem>
         <para>Inactive resources:</para>
      </listitem>
   </orderedlist>
   <para>        $OCF_RESKEY_CRM_meta_notify_inactive_resource</para>
   <para>                plus $OCF_RESKEY_CRM_meta_notify_stop_resource </para>
   <orderedlist>
      <listitem>
         <para>Resources that were started: $OCF_RESKEY_CRM_meta_notify_start_resource</para>
      </listitem>
      <listitem>
         <para>Resources that were stopped: $OCF_RESKEY_CRM_meta_notify_stop_resource</para>
      </listitem>
   </orderedlist>
   <para/>
   <para>Post-notification (start)</para>
   <orderedlist>
      <listitem>
         <para>Active resources:</para>
      </listitem>
   </orderedlist>
   <para>        $OCF_RESKEY_CRM_meta_notify_active_resource</para>
   <para>                minus $OCF_RESKEY_CRM_meta_notify_stop_resource</para>
   <para>                plus $OCF_RESKEY_CRM_meta_notify_start_resource </para>
   <orderedlist>
      <listitem>
         <para>Inactive resources: </para>
      </listitem>
   </orderedlist>
   <para>        $OCF_RESKEY_CRM_meta_notify_inactive_resource</para>
   <para>                plus $OCF_RESKEY_CRM_meta_notify_stop_resource</para>
   <para>                minus $OCF_RESKEY_CRM_meta_notify_start_resource </para>
   <orderedlist>
      <listitem>
         <para>Resources that were started: $OCF_RESKEY_CRM_meta_notify_start_resource</para>
      </listitem>
      <listitem>
         <para>Resources that were stopped: $OCF_RESKEY_CRM_meta_notify_stop_resource</para>
      </listitem>
   </orderedlist></section></section></section><section><title>Multi-state - <anchor id="AdvancedResourcesMultistate"/>Resources That Have Multiple Modes</title>
   <para>Multi-state resources are a specialization of Clones (please ensure you understand the section on clones before continuing) that allow the instances to be in one of two operating modes.  These modes are called Master and Slave but can mean whatever you wish them to mean.  The only limitation is that when an instance is started, it must come up in the Slave state.</para><section><title>Properties</title>
   <informaltable frame="all">
      <tgroup cols="2">
         <thead>
            <row>
               <entry>
                  <para>Field</para>
               </entry>
               <entry>
                  <para>Description</para>
               </entry>
            </row>
         </thead><tbody><row>
            <entry>
               <para>id</para>
            </entry>
            <entry>
               <para>Your name for the multi-state resource</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section><section><title>Options</title>
   <para>Options inherited from <link linkend="">simple resources</link>: priority, target-role, is-managed</para>
   <para>Options inherited from <link linkend="">clone resources</link>: clone-max, clone-node-max, notify, globally-unique, ordered, interleave</para>
   <informaltable frame="all">
      <tgroup cols="2">
         <thead>
            <row>
               <entry>
                  <para>Field</para>
               </entry>
               <entry>
                  <para>Description</para>
               </entry>
            </row>
         </thead><tbody><row>
            <entry>
               <para>master-max</para>
            </entry>
            <entry>
               <para>How many copies of the resource can be promoted to master status.  Defaults to 1.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>master-node-max</para>
            </entry>
            <entry>
               <para>How many copies of the resource can be promoted to master status on a single node.  Defaults to 1.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>Multi-state specific resource configuration options</para></section><section><title>Using Multi-state Resources</title><section><title>Instance Attributes</title>
   <para>Multi-state resources have no instance attributes, however any that are set here will be inherited by the master’s children. </para></section><section><title>Contents</title>
   <para>Masters must contain exactly one group or one regular resource.</para>
   <para>You should never reference the name of a master’s child. If you think you need to do this, you probably need to re-evaluate your design.</para></section><section><title>Monitoring Multi-State Resources</title>
   <para>The normal type of monitor actions you define are not sufficient to monitor a multi-state resource in the Master state.  To detect failures of the master instance, you need to define an additional monitor action with role=”Master”. </para>
   <para>NOTE: It is crucial that every monitor operation has a different interval</para>
   <para>&lt;master id=”myMasterRsc”&gt;</para>
   <para>  &lt;primitive id="myRsc" class="ocf" type="myApp" provider=”myCorp”&gt;</para>
   <para>    &lt;operations&gt;</para>
   <para>       &lt;op id="public-ip-slave-check" name="monitor" interval="60"/&gt;</para>
   <para>       &lt;op id="public-ip-master-check" name="monitor" interval="61" role=”Master”/&gt;</para>
   <para>    &lt;/operations&gt;</para>
   <para>  &lt;/primitive&gt;</para>
   <para>&lt;/master&gt;</para>
   <para>Monitoring both states of a multi-state resource</para></section><section><title>Constraints</title>
   <para>In most cases, a multi-state resources will have a single copy on each active cluster node.  However if this is not the case, you can indicate which nodes the cluster should to preferentially assign copies to with resource location constraints.  These constraints are written no differently to those for regular resources except that the master’s id is used.   </para>
   <para>When considering multi-state resources in constraints, for most purposes it is sufficient to treat them as clones.  The exception is when the rsc-role and/or with-rsc-role (for colocation constraints) and first-action and/or then-action (for ordering constraints) are used.</para>
   <informaltable frame="all">
      <tgroup cols="2">
         <thead>
            <row>
               <entry>
                  <para>Field</para>
               </entry>
               <entry>
                  <para>Description</para>
               </entry>
            </row>
         </thead><tbody><row>
            <entry>
               <para>rsc-role</para>
            </entry>
            <entry>
               <para>An additional attribute of colocation constraints that specifies the role that rsc must be in. </para>
               <para>Allowed values: <emphasis>Started</emphasis>, Master, Slave</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>with-rsc-role</para>
            </entry>
            <entry>
               <para>An additional attribute of colocation constraints that specifies the role that with-rsc must be in.</para>
               <para>Allowed values: <emphasis>Started</emphasis>, Master, Slave</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>first-action</para>
            </entry>
            <entry>
               <para>An additional attribute of ordering constraints that specifies the action that the first resource must complete before executing the specified action for the then resource. </para>
               <para>Allowed values: <emphasis>start</emphasis>, stop, promote, demote</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>then-action</para>
            </entry>
            <entry>
               <para>An additional attribute of ordering constraints that specifies the action that the then resource can only execute after the first-action on the first resource has completed.</para>
               <para>Allowed values: start, stop, promote, demote.  Defaults to the value of first-action</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>Additional constraint options relevant to multi-state resources</para>
   <para>In the example below, myApp will wait until one of database copies has been started and promoted to master before being started itself.  Only if no copies can be promoted will apache-stats be prevented from being active.  Additionally, the database will wait for myApp to be stopped before it is demoted.</para>
   <para>Colocation of a regular (or group) resource with a multi-state resource means that it can run on any machine with an active copy of the clone that is in the specified state (Master or Slave).  In the example, the cluster will choose a location based on where database is running as a Master, and if there are multiple Master instances it will also factor in myApp‘s own location preferences when deciding which location to choose.</para>
   <para>Colocation with regular clones and other multi-state resources is also possible.  In such cases, the set of allowed locations for the rsc clone is (after role filtering) limited to nodes on which the with-rsc clone is (or will be) in the specified role.  Allocation is then performed as-per-normal.</para>
   <para>&lt;constraints&gt;</para>
   <para>  &lt;rsc_location id=”db-prefers-node1” rsc=”database” node=”node1” score=”500”/&gt;</para>
   <para>  &lt;rsc_colocation id=”backup-with-db-slave” rsc=”backup” with-rsc=”database” with-rsc-role=”Slave”/&gt;</para>
   <para>  &lt;rsc_colocation id=”myapp-with-db-master” rsc=”myApp” with-rsc=”database” with-rsc-role=”Master”/&gt;</para>
   <para>  &lt;rsc_order id=”start-db-before-backup” first=”database” then=”backup”/&gt;</para>
   <para>  &lt;rsc_order id=”promote-db-then-app” first=”database” first-action=”promote” then=”myApp” then-action=”start”/&gt;</para>
   <para>&lt;/constraints&gt;</para>
   <para>Example constraints involving multi-state resources</para></section><section><title>Stickiness</title>
   <para>To achieve a stable allocation pattern, clones are slightly sticky by default.  If no value for resource-stickiness is provided, the clone will use a value of 1.  Being a small value, it causes minimal disturbance to the score calculations of other resources but is enough to prevent Pacemaker from needlessly moving copies around the cluster. </para></section><section><title>Which Resource Instance is Promoted</title>
   <para>During the start operation, most Resource Agent scripts should call the crm_master utility. This tool automatically detects both the resource and host and should be used to set a preference for being promoted. Based on this, master-max, and master-node-max, the instance(s) with the highest preference will be promoted.</para>
   <para>The other alternative is to create a location constraint that indicates which nodes are most preferred as masters. </para>
   <para>&lt;rsc_location id="master-location" rsc="myMasterRsc"&gt;</para>
   <para>    &lt;rule id="master-rule" score="100" role="Master"&gt;</para>
   <para>        &lt;expression id="master-exp" attribute="#uname" operation="eq" value="node1"/&gt;</para>
   <para>    &lt;/rule&gt;</para>
   <para>&lt;/rsc_location&gt;</para>
   <para>Manually specifying which node should be promoted</para></section><section><title>Resource Agent Requirements</title>
   <para>Since multi-state resources are an extension of cloned resources, all the requirements of Clones are also requirements of multi-state resources.  Additionally, multi-state resources require two extra actions demote and promote.  These actions are responsible for changing the state of the resource.  Like start and stop, they should return OCF_SUCCESS if they completed successfully or a relevant error code if they did not.</para>
   <para>The states can mean whatever you wish, but when the resource is started, it must come up in the mode called Slave.  From there the cluster will then decide which instances to promote into a Master.</para>
   <para>In addition to the Clone requirements for monitor actions, agents must also <emphasis>accurately</emphasis> report which state they are in. The cluster relies on the agent to report its status (including role) accurately and does not indicate to the agent what role it currently believes it to be in.   </para>
   <informaltable frame="all">
      <tgroup cols="2">
         <thead>
            <row>
               <entry>
                  <para>Monitor Return Code</para>
               </entry>
               <entry>
                  <para>Description</para>
               </entry>
            </row>
         </thead><tbody><row>
            <entry>
               <para>OCF_NOT_RUNNING</para>
            </entry>
            <entry>
               <para>Stopped</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>OCF_SUCCESS</para>
            </entry>
            <entry>
               <para>Running (Slave)</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>OCF_RUNNING_MASTER</para>
            </entry>
            <entry>
               <para>Running (Master)</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>OCF_FAILED_MASTER</para>
            </entry>
            <entry>
               <para>Failed (Master)</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>Other</para>
            </entry>
            <entry>
               <para>Failed (Slave)</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>Role implications of OCF return codes</para></section><section><title>Notifications</title>
   <para>Like with clones, supporting notifications requires the notify action to be implemented.  Once supported, the notify action will be passed a number of extra variables which, when combined with additional context, can be used to calculate the current state of the cluster and what is about to happen to it. </para>
   <informaltable frame="all">
      <tgroup cols="2">
         <thead>
            <row>
               <entry>
                  <para>Variable</para>
               </entry>
               <entry>
                  <para>Description</para>
               </entry>
            </row>
         </thead><tbody><row>
            <entry>
               <para>OCF_RESKEY_CRM_meta_notify_type</para>
            </entry>
            <entry>
               <para>Allowed values: pre, post</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>OCF_RESKEY_CRM_meta_notify_operation</para>
            </entry>
            <entry>
               <para>Allowed values: start, stop</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>OCF_RESKEY_CRM_meta_notify_active_resource</para>
            </entry>
            <entry>
               <para>Resources the that are running</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>OCF_RESKEY_CRM_meta_notify_inactive_resource</para>
            </entry>
            <entry>
               <para>Resources the that are not running</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>
                  <emphasis>OCF_RESKEY_CRM_meta_notify_master_resource</emphasis>
               </para>
            </entry>
            <entry>
               <para>Resources that are running in Master mode</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>
                  <emphasis>OCF_RESKEY_CRM_meta_notify_slave_resource</emphasis>
               </para>
            </entry>
            <entry>
               <para>Resources that are running in Slave mode</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>OCF_RESKEY_CRM_meta_notify_start_resource</para>
            </entry>
            <entry>
               <para>Resources to be started</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>OCF_RESKEY_CRM_meta_notify_stop_resource</para>
            </entry>
            <entry>
               <para>Resources to be stopped</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>
                  <emphasis>OCF_RESKEY_CRM_meta_notify_promote_resource</emphasis>
               </para>
            </entry>
            <entry>
               <para>Resources to be promoted</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>
                  <emphasis>OCF_RESKEY_CRM_meta_notify_demote_resource</emphasis>
               </para>
            </entry>
            <entry>
               <para>Resources to be demoted</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>OCF_RESKEY_CRM_meta_notify_start_uname</para>
            </entry>
            <entry>
               <para>Nodes on which resources will be started</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>OCF_RESKEY_CRM_meta_notify_stop_uname</para>
            </entry>
            <entry>
               <para>Nodes on which resources will be stopped</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>
                  <emphasis>OCF_RESKEY_CRM_meta_notify_promote_uname</emphasis>
               </para>
            </entry>
            <entry>
               <para>Nodes on which resources will be promoted</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>
                  <emphasis>OCF_RESKEY_CRM_meta_notify_demote_uname</emphasis>
               </para>
            </entry>
            <entry>
               <para>Nodes on which resources will be demoted</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>OCF_RESKEY_CRM_meta_notify_active_uname</para>
            </entry>
            <entry>
               <para>Nodes on which resources are running</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>OCF_RESKEY_CRM_meta_notify_inactive_uname</para>
            </entry>
            <entry>
               <para>Nodes on which resources are not running</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>
                  <emphasis>OCF_RESKEY_CRM_meta_notify_master_uname</emphasis>
               </para>
            </entry>
            <entry>
               <para>Nodes on which resources are running in Master mode</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>
                  <emphasis>OCF_RESKEY_CRM_meta_notify_slave_uname</emphasis>
               </para>
            </entry>
            <entry>
               <para>Nodes on which resources are running in Slave mode</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>Environment variables supplied with Master notify actions<footnote>
         <para> Variables in bold are specific to Master resources and all behave in the same manner as described for Clone resources.</para>
      </footnote>
   </para></section><section><title>Proper Interpretation of Notification Environment Variables</title>
   <para>Pre-notification (demote)</para>
   <orderedlist>
      <listitem>
         <para>Active resources: $OCF_RESKEY_CRM_meta_notify_active_resource</para>
      </listitem>
      <listitem>
         <para>Master resources: $OCF_RESKEY_CRM_meta_notify_master_resource</para>
      </listitem>
      <listitem>
         <para>Slave resources: $OCF_RESKEY_CRM_meta_notify_slave_resource</para>
      </listitem>
      <listitem>
         <para>Inactive resources: $OCF_RESKEY_CRM_meta_notify_inactive_resource</para>
      </listitem>
      <listitem>
         <para>Resources to be started: $OCF_RESKEY_CRM_meta_notify_start_resource</para>
      </listitem>
      <listitem>
         <para>Resources to be promoted: $OCF_RESKEY_CRM_meta_notify_promote_resource</para>
      </listitem>
      <listitem>
         <para>Resources to be demoted: $OCF_RESKEY_CRM_meta_notify_demote_resource</para>
      </listitem>
      <listitem>
         <para>Resources to be stopped: $OCF_RESKEY_CRM_meta_notify_stop_resource</para>
      </listitem>
   </orderedlist>
   <para/>
   <para>Post-notification (demote) / Pre-notification (stop)</para>
   <orderedlist>
      <listitem>
         <para>Active resources: $OCF_RESKEY_CRM_meta_notify_active_resource</para>
      </listitem>
      <listitem>
         <para>Master resources: </para>
      </listitem>
   </orderedlist>
   <para>        $OCF_RESKEY_CRM_meta_notify_master_resource</para>
   <para>                minus $OCF_RESKEY_CRM_meta_notify_demote_resource </para>
   <orderedlist>
      <listitem>
         <para>Slave resources: $OCF_RESKEY_CRM_meta_notify_slave_resource</para>
      </listitem>
      <listitem>
         <para>Inactive resources: $OCF_RESKEY_CRM_meta_notify_inactive_resource</para>
      </listitem>
      <listitem>
         <para>Resources to be started: $OCF_RESKEY_CRM_meta_notify_start_resource</para>
      </listitem>
      <listitem>
         <para>Resources to be promoted: $OCF_RESKEY_CRM_meta_notify_promote_resource</para>
      </listitem>
      <listitem>
         <para>Resources to be demoted: $OCF_RESKEY_CRM_meta_notify_demote_resource</para>
      </listitem>
      <listitem>
         <para>Resources to be stopped: $OCF_RESKEY_CRM_meta_notify_stop_resource</para>
      </listitem>
      <listitem>
         <para>Resources that were demoted: $OCF_RESKEY_CRM_meta_notify_demote_resource</para>
      </listitem>
   </orderedlist>
   <para/>
   <para>Post-notification (stop) / Pre-notification (start)</para>
   <orderedlist>
      <listitem>
         <para>Active resources: </para>
      </listitem>
   </orderedlist>
   <para>        $OCF_RESKEY_CRM_meta_notify_active_resource</para>
   <para>                minus $OCF_RESKEY_CRM_meta_notify_stop_resource </para>
   <orderedlist>
      <listitem>
         <para>Master resources: </para>
      </listitem>
   </orderedlist>
   <para>        $OCF_RESKEY_CRM_meta_notify_master_resource</para>
   <para>                minus $OCF_RESKEY_CRM_meta_notify_demote_resource </para>
   <orderedlist>
      <listitem>
         <para>Slave resources: </para>
      </listitem>
   </orderedlist>
   <para>        $OCF_RESKEY_CRM_meta_notify_slave_resource</para>
   <para>                minus $OCF_RESKEY_CRM_meta_notify_stop_resource </para>
   <orderedlist>
      <listitem>
         <para>Inactive resources: </para>
      </listitem>
   </orderedlist>
   <para>        $OCF_RESKEY_CRM_meta_notify_inactive_resource</para>
   <para>                plus $OCF_RESKEY_CRM_meta_notify_stop_resource </para>
   <orderedlist>
      <listitem>
         <para>Resources to be started: $OCF_RESKEY_CRM_meta_notify_start_resource</para>
      </listitem>
      <listitem>
         <para>Resources to be promoted: $OCF_RESKEY_CRM_meta_notify_promote_resource</para>
      </listitem>
      <listitem>
         <para>Resources to be demoted: $OCF_RESKEY_CRM_meta_notify_demote_resource</para>
      </listitem>
      <listitem>
         <para>Resources to be stopped: $OCF_RESKEY_CRM_meta_notify_stop_resource</para>
      </listitem>
      <listitem>
         <para>Resources that were demoted: $OCF_RESKEY_CRM_meta_notify_demote_resource</para>
      </listitem>
      <listitem>
         <para>Resources that were stopped: $OCF_RESKEY_CRM_meta_notify_stop_resource</para>
      </listitem>
   </orderedlist>
   <para/>
   <para>Post-notification (start) / Pre-notification (promote)</para>
   <orderedlist>
      <listitem>
         <para>Active resources: </para>
      </listitem>
   </orderedlist>
   <para>        $OCF_RESKEY_CRM_meta_notify_active_resource</para>
   <para>                minus $OCF_RESKEY_CRM_meta_notify_stop_resource</para>
   <para>                plus $OCF_RESKEY_CRM_meta_notify_start_resource </para>
   <orderedlist>
      <listitem>
         <para>Master resources: </para>
      </listitem>
   </orderedlist>
   <para>        $OCF_RESKEY_CRM_meta_notify_master_resource</para>
   <para>                minus $OCF_RESKEY_CRM_meta_notify_demote_resource </para>
   <orderedlist>
      <listitem>
         <para>Slave resources: </para>
      </listitem>
   </orderedlist>
   <para>        $OCF_RESKEY_CRM_meta_notify_slave_resource</para>
   <para>                minus $OCF_RESKEY_CRM_meta_notify_stop_resource</para>
   <para>                plus $OCF_RESKEY_CRM_meta_notify_start_resource </para>
   <orderedlist>
      <listitem>
         <para>Inactive resources: </para>
      </listitem>
   </orderedlist>
   <para>        $OCF_RESKEY_CRM_meta_notify_inactive_resource</para>
   <para>                plus $OCF_RESKEY_CRM_meta_notify_stop_resource</para>
   <para>                minus $OCF_RESKEY_CRM_meta_notify_start_resource </para>
   <orderedlist>
      <listitem>
         <para>Resources to be started: $OCF_RESKEY_CRM_meta_notify_start_resource</para>
      </listitem>
      <listitem>
         <para>Resources to be promoted: $OCF_RESKEY_CRM_meta_notify_promote_resource</para>
      </listitem>
      <listitem>
         <para>Resources to be demoted: $OCF_RESKEY_CRM_meta_notify_demote_resource</para>
      </listitem>
      <listitem>
         <para>Resources to be stopped: $OCF_RESKEY_CRM_meta_notify_stop_resource</para>
      </listitem>
      <listitem>
         <para>Resources that were started: $OCF_RESKEY_CRM_meta_notify_start_resource</para>
      </listitem>
      <listitem>
         <para>Resources that were demoted: $OCF_RESKEY_CRM_meta_notify_demote_resource</para>
      </listitem>
      <listitem>
         <para>Resources that were stopped: $OCF_RESKEY_CRM_meta_notify_stop_resource</para>
      </listitem>
   </orderedlist>
   <para/>
   <para>Post-notification (promote)</para>
   <orderedlist>
      <listitem>
         <para>Active resources: </para>
      </listitem>
   </orderedlist>
   <para>        $OCF_RESKEY_CRM_meta_notify_active_resource</para>
   <para>                minus $OCF_RESKEY_CRM_meta_notify_stop_resource</para>
   <para>                plus $OCF_RESKEY_CRM_meta_notify_start_resource </para>
   <orderedlist>
      <listitem>
         <para>Master resources: </para>
      </listitem>
   </orderedlist>
   <para>        $OCF_RESKEY_CRM_meta_notify_master_resource</para>
   <para>                minus $OCF_RESKEY_CRM_meta_notify_demote_resource</para>
   <para>                        plus $OCF_RESKEY_CRM_meta_notify_promote_resource </para>
   <orderedlist>
      <listitem>
         <para>Slave resources: </para>
      </listitem>
   </orderedlist>
   <para>        $OCF_RESKEY_CRM_meta_notify_slave_resource</para>
   <para>                minus $OCF_RESKEY_CRM_meta_notify_stop_resource</para>
   <para>                plus $OCF_RESKEY_CRM_meta_notify_start_resource</para>
   <para>                minus $OCF_RESKEY_CRM_meta_notify_promote_resource </para>
   <orderedlist>
      <listitem>
         <para>Inactive resources: </para>
      </listitem>
   </orderedlist>
   <para>        $OCF_RESKEY_CRM_meta_notify_inactive_resource</para>
   <para>                plus $OCF_RESKEY_CRM_meta_notify_stop_resource</para>
   <para>                minus $OCF_RESKEY_CRM_meta_notify_start_resource </para>
   <orderedlist>
      <listitem>
         <para>Resources to be started: $OCF_RESKEY_CRM_meta_notify_start_resource</para>
      </listitem>
      <listitem>
         <para>Resources to be promoted: $OCF_RESKEY_CRM_meta_notify_promote_resource</para>
      </listitem>
      <listitem>
         <para>Resources to be demoted: $OCF_RESKEY_CRM_meta_notify_demote_resource</para>
      </listitem>
      <listitem>
         <para>Resources to be stopped: $OCF_RESKEY_CRM_meta_notify_stop_resource</para>
      </listitem>
      <listitem>
         <para>Resources that were started: $OCF_RESKEY_CRM_meta_notify_start_resource</para>
      </listitem>
      <listitem>
         <para>Resources that were promoted: $OCF_RESKEY_CRM_meta_notify_promote_resource</para>
      </listitem>
      <listitem>
         <para>Resources that were demoted: $OCF_RESKEY_CRM_meta_notify_demote_resource</para>
      </listitem>
      <listitem>
         <para>Resources that were stopped: $OCF_RESKEY_CRM_meta_notify_stop_resource</para>
      </listitem>
   </orderedlist>
     </section>
     </section>
     </section>
     </section>
   <section id="stonith">
     <title>Protecting Your Data - STONITH</title>
     <anchor id="ProtectingYourDatawithSTONIT"/>
     <section><title>Why You Need STONITH</title>
   <para>STONITH is an acronym for Shoot-The-Other-Node-In-The-Head and it protects your data from being corrupted by rouge nodes or concurrent access.</para>
   <para>Just because a node is unresponsive, this doesn’t mean it isn’t accessing your data.  The only way to be 100% sure that your data is safe, is to use STONITH so we can be certain that the node is truly offline, before allowing the data to be accessed from another node.</para>
   <para>STONITH also has a role to play in the event that a clustered service cannot be stopped.  In this case, the cluster uses STONITH to force the whole node offline, thereby making it safe to start the service elsewhere.</para></section><section><title>What STONITH Device Should You Use</title>
   <para>It is crucial that the STONITH device can allow the cluster to differentiate between a node failure and a network one.  </para>
   <para>The biggest mistake people make in choosing a STONITH device is to use remote power switch (such as many onboard IMPI controllers) that shares power with the node it controls.  In such cases, the cluster cannot be sure if the node is really offline, or active and suffering from a network fault.</para>
   <para>Likewise, any device that relies on the machine being active (such as SSH-based “devices” used during testing) are inappropriate.</para></section><section><title>Configuring STONITH</title>
   <orderedlist>
      <listitem>
         <para>Find the correct driver:  stonith -L</para>
      </listitem>
      <listitem>
         <para>Since every device is different, the parameters needed to configure it will vary.  To find out the parameters required by the device: stonith -t {type} -n</para>
      </listitem>
   </orderedlist>
   <para>Hopefully the developers chose names that make sense, if not you can query for some additional information by finding an active cluster node and running:</para>
   <orderedlist>
      <listitem/>
   </orderedlist>
   <para>       The output should be XML formatted text containing additional parameter descriptions</para>
   <orderedlist>
      <listitem>
         <para>Create a file called stonith.xml containing a primitive resource with a class of stonith, a type of {type} and a parameter for each of the values returned in step 2</para>
      </listitem>
      <listitem>
         <para>Create a clone from the primitive resource if the device can shoot more than one node<emphasis> and supports multiple simultaneous connections</emphasis>.</para>
      </listitem>
      <listitem>
         <para>Upload it into the CIB using cibadmin: cibadmin -C -o resources --xml-file stonith.xml</para>
      </listitem>
   </orderedlist><section><title>Example</title>
   <para>Assuming we have an IBM BladeCenter consisting of four nodes and the management interface is active on 10.0.0.1, then we would chose the external/ibmrsa driver in step 2 and obtain the following list of parameters</para>
   <para># stonith -t external/ibmrsa -n</para>
   <para>hostname  ipaddr  userid  passwd  type</para>
   <para>from which we would create a STONITH resource fragment that might look like this</para>
   <para>        &lt;clone id="Fencing"&gt;</para>
   <para>          &lt;meta_attributes id="fencing"&gt;</para>
   <para>              &lt;nvpair id="Fencing-unique" name="globally-unique" value="false"/&gt;</para>
   <para>          &lt;/meta_attributes&gt;</para>
   <para>          &lt;primitive id="rsa" class="stonith" type=”external/ibmrsa"&gt;</para>
   <para>            &lt;operations&gt;</para>
   <para>              &lt;op id="rsa-mon-1" name="monitor" interval="120s"/&gt;</para>
   <para>            &lt;/operations&gt;</para>
   <para>            &lt;instance_attributes id="rsa-parameters"&gt;</para>
   <para>                &lt;nvpair id="rsa-attr-1" name="hostname" value="node1 node2 node3"/&gt;</para>
   <para>                &lt;nvpair id="rsa-attr-1" name="ipaddr" value="10.0.0.1"/&gt;</para>
   <para>                &lt;nvpair id="rsa-attr-1" name="userid" value="testuser"/&gt;</para>
   <para>                &lt;nvpair id="rsa-attr-1" name="passwd" value="abc123"/&gt;</para>
   <para>                &lt;nvpair id="rsa-attr-1" name="type" value="ibm"/&gt;</para>
   <para>            &lt;/instance_attributes&gt;</para>
   <para>          &lt;/primitive&gt;</para>
   <para>        &lt;/clone&gt;</para>
   </section></section></section>
   <section id="status"><title>Status - Here be dragons</title>
   <para>Most users never need understand the contents of the status section and can be content with the output from crm_mon. However for those with a curious inclination, the following attempts to proved an overview of its contents.</para><section><title>Node Status</title>
   <para>In addition to the cluster’s configuration, the CIB holds an up-to-date representation of each cluster node in the status section.</para>
   <para>&lt;node_state id="cl-virt-1" uname="cl-virt-2" ha="active" in_ccm="true" crmd="online" join="member" expected="member" crm-debug-origin="do_update_resource"&gt;</para>
   <para>   &lt;transient_attributes id="cl-virt-1"/&gt;</para>
   <para>   &lt;lrm id="cl-virt-1"/&gt;</para>
   <para>&lt;/node_state&gt;</para>
   <para>A bare-bones status entry for a healthy node called cl-virt-1</para>
   <para>Users are highly recommended <emphasis>not to modify</emphasis> any part of a node’s state <emphasis>directly</emphasis>.  The cluster will periodically regenerate the entire section from authoritative sources.  So any changes should be with the tools for those subsystems. </para>
   <informaltable frame="all">
      <tgroup cols="2">
         <thead>
            <row>
               <entry>
                  <para>Dataset</para>
               </entry>
               <entry>
                  <para>Authoritative Source</para>
               </entry>
            </row>
         </thead><tbody><row>
            <entry>
               <para>node_state fields</para>
            </entry>
            <entry>
               <para>crmd</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>transient_attributes tag</para>
            </entry>
            <entry>
               <para>attrd</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>lrm tag</para>
            </entry>
            <entry>
               <para>lrmd</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>Authoritative Sources for State Information</para>
   <para>The fields used in the node_state objects are named as they are largely for historical reasons and are rooted in Pacemaker’s origins as the Heartbeat resource manager.  They have remained unchanged to preserve compatibility with older versions.</para>
   <informaltable frame="all">
      <tgroup cols="2">
         <thead>
            <row>
               <entry>
                  <para>Field</para>
               </entry>
               <entry>
                  <para>Description</para>
               </entry>
            </row>
         </thead><tbody><row>
            <entry>
               <para>id</para>
            </entry>
            <entry>
               <para>Unique identifier for the node. OpenAIS based clusters use the same value as uname, Heartbeat cluster use a human-readable (but annoying) UUID.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>uname</para>
            </entry>
            <entry>
               <para>The node’s machine name (output from uname -n)</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>ha</para>
            </entry>
            <entry>
               <para>Is the cluster software active on the node. Allowed values: active, dead</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>in_ccm</para>
            </entry>
            <entry>
               <para>Is the node part of the cluster’s membership. Allowed values: true, false</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>crmd</para>
            </entry>
            <entry>
               <para>Is the crmd process active on the node. Allowed values: online, offline</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>join</para>
            </entry>
            <entry>
               <para>Is the node participating in hosting resources.  Allowed values: down, pending, member, banned</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>expected</para>
            </entry>
            <entry>
               <para>Expected value for join</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>crm-debug-origin</para>
            </entry>
            <entry>
               <para>Diagnostic indicator. The origin of the most recent change(s).</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>Node Status Fields </para>
   <para>The cluster uses these fields to determine if, at the node level, the node is healthy or is in a failed state and needs to be fenced.</para></section><section><title>Transient Node Attributes</title>
   <para>Like regular <link linkend="">node attributes</link>, the name/value pairs listed here also help describe the node.  However they are forgotten by the cluster when the node goes offline.  This can be useful, for instance, when you only want a node to be in standby mode (not able to run resources) until the next reboot. </para>
   <para>In addition to any values the administrator sets, the cluster will also store information about failed resources here.</para>
   <para>      &lt;transient_attributes id="cl-virt-1"&gt;</para>
   <para>        &lt;instance_attributes id="status-cl-virt-1"&gt;</para>
   <para>          &lt;nvpair id="status-cl-virt-1-pingd" name="pingd" value="3"/&gt;</para>
   <para>          &lt;nvpair id="status-cl-virt-1-probe_complete" name="probe_complete" value="true"/&gt;</para>
   <para>          &lt;nvpair id="status-cl-virt-1-fail-count-pingd:0" name="fail-count-pingd:0" value="1"/&gt;</para>
   <para>          &lt;nvpair id="status-cl-virt-1-last-failure-pingd:0" name="last-failure-pingd:0" value="1239009742"/&gt;</para>
   <para>        &lt;/instance_attributes&gt;</para>
   <para>      &lt;/transient_attributes&gt;</para>
   <para>Example set of transient node attributes for node “cl-virt-1”</para>
   <para>In the above example, we can see that the pingd:0 resource has failed once, at Mon Apr  6 11:22:22 2009.<footnote>
         <para> You can use the following perl one-liner to print a human readable of any seconds-since-epoch value:</para>
         <para>         perl -e 'print scalar(localtime($seconds))."\n"'</para>
      </footnote>  We also see that the node is connected to three “pingd” peers and that all known resources have been checked for on this machine (probe_complete).</para></section><section><title>Operation History</title>
   <para>A node’s resource history is held in the lrm_resources tag (a child of the lrm tag). The information stored here includes enough information for the cluster to stop the resource safely if it is removed from the configuration section. Specifically we store the resource’s ID, class, type and provider.</para>
   <para>          &lt;lrm_resource id="apcstonith" type="apcmastersnmp" class="stonith"&gt;</para>
   <para>A record of the apcstonith resource</para>
   <para>Additionally, we store the last job for every combination of resource, action and interval.  The concatenation of the values in this tuple are used to create the id of the lrm_rsc_op object.</para>
   <informaltable frame="all">
      <tgroup cols="2">
         <thead>
            <row>
               <entry>
                  <para>Field</para>
               </entry>
               <entry>
                  <para>Description</para>
               </entry>
            </row>
         </thead><tbody><row>
            <entry>
               <para>id</para>
            </entry>
            <entry>
               <para>Identifier for the job constructed from the resource id, operation and interval.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>call-id</para>
            </entry>
            <entry>
               <para>The job’s ticket number.  Used as a sort key to determine the order in which the jobs were executed.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>operation</para>
            </entry>
            <entry>
               <para>The action the resource agent was invoked with.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>interval</para>
            </entry>
            <entry>
               <para>The frequency, in milliseconds, at which the operation will be repeated. 0 indicates a one-off job. </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>op-status</para>
            </entry>
            <entry>
               <para>The job’s status. Generally this will be either 0 (done) or -1 (pending).  Rarely used in favor of rc-code.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>rc-code</para>
            </entry>
            <entry>
               <para>The job’s result.  Refer to the <link linkend="">More About OCF Resource Agents</link> Appendix for details on what the values here mean and how they are interpreted.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>last-run</para>
            </entry>
            <entry>
               <para>Diagnostic indicator. Machine local date/time, in seconds since epoch, at which the job was executed.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>last-rc-change</para>
            </entry>
            <entry>
               <para>Diagnostic indicator. Machine local date/time, in seconds since epoch, at which the job first returned the current value of rc-code  </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>exec-time</para>
            </entry>
            <entry>
               <para>Diagnostic indicator. Time, in seconds, that the job was running for </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>queue-time</para>
            </entry>
            <entry>
               <para>Diagnostic indicator. Time, in seconds, that the job was queued for in the LRMd </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>crm_feature_set</para>
            </entry>
            <entry>
               <para>The version which this job description conforms to.  Used when processing op-digest</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>transition-key</para>
            </entry>
            <entry>
               <para>A concatenation of the job’s graph action number, the graph number, the expected result and the UUID of the crmd instance that scheduled it.  This is used to construct transition-magic (below).</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>transition-magic</para>
            </entry>
            <entry>
               <para>A concatenation of the job’s op-status, rc-code and transition-key.  Guaranteed to be unique for the life of the cluster (which ensures it is part of CIB update notifications) and contains all the information needed for the crmd to correctly analyze and process the completed job.  Most importantly, the decomposed elements tell the crmd if the job entry was expected and whether it failed. </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>op-digest</para>
            </entry>
            <entry>
               <para>An md5 sum representing the parameters passed to the job.  Used to detect changes to the configuration and restart resources if necessary.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>crm-debug-origin</para>
            </entry>
            <entry>
               <para>Diagnostic indicator. The origin of the current values.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>Contents of an lrm_rsc_op job. </para><section><title>Simple Example</title>
   <para>&lt;lrm_resource id="apcstonith" type="apcmastersnmp" class="stonith"&gt; </para>
   <para>    &lt;lrm_rsc_op id="apcstonith_monitor_0" operation="monitor" crm-debug-origin="do_update_resource" crm_feature_set="3.0.1" transition-key="22:2:7:2668bbeb-06d5-40f9-936d-24cb7f87006a" transition-magic="0:7;22:2:7:2668bbeb-06d5-40f9-936d-24cb7f87006a" call-id="2" rc-code="7" op-status="0" interval="0" last-run="1239008085" last-rc-change="1239008085" exec-time="10" queue-time="0" op-digest="2e3da9274d3550dc6526fb24bfcbcba0"/&gt;</para>
   <para>&lt;/lrm_resource&gt;</para>
   <para>A monitor operation performed by the cluster to determine the current state of the apcstonith resource</para>
   <para>In the above example, the job is a non-recurring monitor often referred to as a “probe” for the apcstonith resource. The cluster schedules probes for every configured resource on when a new node starts, in order to determine the resource’s current state before it takes further any further action.</para>
   <para>From the tranisition-key, we can see that this was the 22nd action of the 2nd graph produced by this instance of the crmd (2668bbeb-06d5-40f9-936d-24cb7f87006a).  The third field of the transition-key contains a 7, this indicates that the job expects to find the resource inactive.  By now looking at the rc-code property, we see that this was the case.</para>
   <para>Evidently, the cluster started the resource elsewhere as that is the only job recorded for this node.</para></section><section><title>Complex Resource History Example</title>
   <para/>
   <para>&lt;lrm_resource id="pingd:0" type="pingd" class="ocf" provider="pacemaker"&gt;</para>
   <para>    &lt;lrm_rsc_op id="pingd:0_monitor_30000" operation="monitor" crm-debug-origin="do_update_resource" crm_feature_set="3.0.1" transition-key="10:11:0:2668bbeb-06d5-40f9-936d-24cb7f87006a" transition-magic="0:0;10:11:0:2668bbeb-06d5-40f9-936d-24cb7f87006a" call-id="34" rc-code="0" op-status="0" interval="30000" last-run="1239009741" last-rc-change="1239009741" exec-time="10" queue-time="0" op-digest="a0f8398dac7ced82320fe99fd20fbd2f"/&gt;</para>
   <para>    &lt;lrm_rsc_op id="pingd:0_stop_0" operation="stop" crm-debug-origin="do_update_resource" crm_feature_set="3.0.1" transition-key="11:11:0:2668bbeb-06d5-40f9-936d-24cb7f87006a" transition-magic="0:0;11:11:0:2668bbeb-06d5-40f9-936d-24cb7f87006a" call-id="32" rc-code="0" op-status="0" interval="0" last-run="1239009741" last-rc-change="1239009741" exec-time="10" queue-time="0" op-digest="313aee7c6aad26e290b9084427bbab60"/&gt;</para>
   <para>    &lt;lrm_rsc_op id="pingd:0_start_0" operation="start" crm-debug-origin="do_update_resource" crm_feature_set="3.0.1" transition-key="31:11:0:2668bbeb-06d5-40f9-936d-24cb7f87006a" transition-magic="0:0;31:11:0:2668bbeb-06d5-40f9-936d-24cb7f87006a" call-id="33" rc-code="0" op-status="0" interval="0" last-run="1239009741" last-rc-change="1239009741" exec-time="10" queue-time="0" op-digest="313aee7c6aad26e290b9084427bbab60"/&gt;</para>
   <para>    &lt;lrm_rsc_op id="pingd:0_monitor_0" operation="monitor" crm-debug-origin="do_update_resource" crm_feature_set="3.0.1" transition-key="23:2:7:2668bbeb-06d5-40f9-936d-24cb7f87006a" transition-magic="0:0;23:2:7:2668bbeb-06d5-40f9-936d-24cb7f87006a" call-id="3" rc-code="0" op-status="0" interval="0" last-run="1239008085" last-rc-change="1239008085" exec-time="20" queue-time="0" op-digest="313aee7c6aad26e290b9084427bbab60"/&gt;</para>
   <para> &lt;/lrm_resource&gt;</para>
   <para>Resource history of a pingd clone with multiple jobs</para>
   <para>When more than one job record exists, it is important to first sort them by call-id before interpret them.  Once sorted, the above example can be summarized as:</para>
   <orderedlist>
      <listitem>
         <para>A non-recurring monitor operation returning 7 (not running), with a call-id of 3</para>
      </listitem>
      <listitem>
         <para>A stop operation returning 0 (success), with a call-id of 32</para>
      </listitem>
      <listitem>
         <para>A start operation returning 0 (success), with a call-id of 33</para>
      </listitem>
      <listitem>
         <para>A recurring monitor returning 0 (success), with a call-id of 34</para>
      </listitem>
   </orderedlist>
   <para>The cluster processes each job record to build up a picture of the resource’s state.  After the first and second entries, it is considered stopped and after the third it considered active. Based on the last operation, we can tell that the resource is currently active. </para>
   <para>Additionally, from the presence of a stop operation with a lower call-id than that of the start operation, we can conclude that the  resource has been restarted. Specifically this occurred as part of actions 11 and 31 of transition 11 from the crmd instance with the key 2668bbeb-06d5-40f9-936d-24cb7f87006a.  This information can be helpful for locating the relevant section of the logs when looking for the source of a failure.</para>
   </section>
   </section>
   </section>
   <section id="faq"><title>Appendix: FAQ</title>
   <section><title>Why is the Project Called Pacemaker?</title>
   <para>First of all, the reason its not called the CRM is because of the abundance of <ulink url="http://en.wikipedia.org/wiki/CRM">terms</ulink> that are commonly abbreviated to those three letters.</para>
   <para>The Pacemaker name came from <ulink url="http://khamsouk.souvanlasy.com/">Kham</ulink>, a good friend of mine, and was originally used by a Java GUI that I was prototyping in early 2007. Alas other commitments have prevented the GUI from progressing much and, when it came time to choose a name for this project, Lars suggested it was an even better fit for an independent CRM.</para>
   <para>The idea stems from the analogy between the role of this software and that of the little device that keeps the human heart pumping.  Pacemaker monitors the cluster and intervenes when necessary to ensure the smooth operation of the services it provides.</para>
   <para>There were a number of other names (and acronyms) tossed around, but suffice to say "Pacemaker" was the best</para></section><section><title>Why was the Pacemaker Project Created?</title>
   <para>The decision was made to spin-off the CRM into its own project after the 2.1.3 Heartbeat release in order to</para>
   <orderedlist>
      <listitem>
         <para>support both the OpenAIS and Heartbeat cluster stacks equally</para>
      </listitem>
      <listitem>
         <para>decouple the release cycles of two projects at very different stages of their life-cycles</para>
      </listitem>
      <listitem>
         <para>foster the clearer package boundaries, thus leading to</para>
      </listitem>
      <listitem>
         <para>better and more stable interfaces</para>
      </listitem>
   </orderedlist></section><section><title>What Messaging Layers are Supported?</title>
   <orderedlist>
      <listitem>
         <para>OpenAIS (<ulink url="http://www.openais.org/">http://www.openais.org</ulink>)</para>
      </listitem>
      <listitem>
         <para>Heartbeat (<ulink url="http://linux-ha.org/">http://linux-ha.org/</ulink>)</para>
      </listitem>
   </orderedlist></section><section><title>Can I Choose which Messaging Layer to use at Run Time?</title>
   <para>Yes. The CRM will automatically detect who started it and behave accordingly.</para></section><section><title>Can I Have a Mixed Heartbeat-OpenAIS Cluster?</title>
   <para>No.</para>
   <para>Which Messaging Layer Should I Choose?</para>
   <para>This is discussed in the <link linkend="">Installation</link> appendix</para></section><section><title>Where Can I Get Pre-built Packages?</title>
   <para>Official packages for most major .rpm and .deb based distributions are available from:</para>
   <para>        <ulink url="http://download.opensuse.org/repositories/server:/ha-clustering/">http://download.opensuse.org/repositories/server:/ha-clustering/</ulink>
   </para>
   <para>For more information, we have a <ulink url="http://clusterlabs.org/mw/Install%23Package_List">description of the available packages</ulink>.</para></section><section><title>What Versions of Pacemaker Are Supported?</title>
   <para>Please refer to the <ulink url="http://clusterlabs.org/mw/Releases">Releases</ulink> page for an up-to-date list of versions supported directly by the project.</para>
   <para>When seeking assistance, please try to ensure you have one of these versions.</para>
   </section>
   </section>

   <section id="ocf"><title>Appendix: More About OCF Resource Agents</title>
     <section><title>Location of Custom Scripts</title>
   <para>OCF Resource Agents are found in /usr/lib/ocf/resource.d/{provider}.</para>
   <para>When creating your own agents, you are encouraged to create a new directory under /usr/lib/ocf/resource.d/ so that they are not confused with (or overwritten by) the agents shipped with Heartbeat. So, for example, if you chose the provider name of bigCorp and wanted a new resource named bigApp, you would create a script called /usr/lib/ocf/resource.d/bigCorp/bigApp and define a resource:</para>
   <para>&lt;primitive id="custom-app" class="ocf" provider=”bigCorp” type="bigApp"/&gt;</para></section><section><title>Actions</title>
   <para>All OCF Resource Agents are required to implement the following actions</para>
   <informaltable frame="all">
      <tgroup cols="3">
         <thead>
            <row>
               <entry>
                  <para>Action</para>
               </entry>
               <entry>
                  <para>Description</para>
               </entry>
               <entry>
                  <para>Instructions</para>
               </entry>
            </row>
         </thead><tbody><row>
            <entry>
               <para>start</para>
            </entry>
            <entry>
               <para>Start the resource</para>
            </entry>
            <entry>
               <para>Return 0 on success and an appropriate error code otherwise.  Must not report success until the resource is fully active.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>stop</para>
            </entry>
            <entry>
               <para>Stop the resource</para>
            </entry>
            <entry>
               <para>Return 0 on success and an appropriate error code otherwise.  Must not report success until the resource is fully stopped.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>monitor</para>
            </entry>
            <entry>
               <para>Check the resource’s state </para>
            </entry>
            <entry>
               <para>Exit 0 if the resource is running, 7 if it is stopped and anything else if it is failed. </para>
               <para>NOTE: The monitor script should test the state of the resource on the local machine only.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>meta-data</para>
            </entry>
            <entry>
               <para>Describe the resource</para>
            </entry>
            <entry>
               <para>Provide information about this resource as an XML snippet. Exit with 0.</para>
               <para>NOTE: This is <emphasis>not</emphasis> performed as root.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>validate-all</para>
            </entry>
            <entry>
               <para>Verify the supplied parameters are correct</para>
            </entry>
            <entry>
               <para>Exit with 0 if parameters are valid, 2 if not valid, 6 if resource is not configured.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>Required OCF actions</para>
   <para>Additional requirements (not part of the OCF specs) are placed on agents that will be used for advanced concepts like clones and multi-state resources.</para>
   <informaltable frame="all">
      <tgroup cols="3">
         <thead>
            <row>
               <entry>
                  <para>Action</para>
               </entry>
               <entry>
                  <para>Description</para>
               </entry>
               <entry>
                  <para>Instructions</para>
               </entry>
            </row>
         </thead><tbody><row>
            <entry>
               <para>promote</para>
            </entry>
            <entry>
               <para>Promote the local instance of a multi-state resource to the master/primary state</para>
            </entry>
            <entry>
               <para>Return 0 on success</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>demote</para>
            </entry>
            <entry>
               <para>Demote the local instance of a multi-state resource to the slave/secondary state</para>
            </entry>
            <entry>
               <para>Return 0 on success</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>notify</para>
            </entry>
            <entry>
               <para>Used by the cluster to send the agent pre and post notification events telling the resource what is or did just take place</para>
            </entry>
            <entry>
               <para>Must not fail.  Must exit 0</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>Optional extra actions</para>
   <para>Some actions specified in the OCF specs are not currently used by the cluster</para>
   <orderedlist>
      <listitem>
         <para>reload - reload the configuration of the resource instance without disrupting the service </para>
      </listitem>
      <listitem>
         <para>recover - a variant of the start action, this should try to recover a resource locally.</para>
      </listitem>
   </orderedlist>
   <para/>
   <para>Remember to use ocf-tester to verify that your new agent complies with the OCF standard properly.</para></section><section><title>
      <anchor id="HowDoestheClusterInterprett"/>How Does the Cluster Interpret the OCF Return Codes?</title>
   <para>The first thing the cluster does is check the return code against the expected result.  If the result does not match the expected value, then the operation is considered to have failed and recovery action is initiated.  </para>
   <para>There are three types of failure recovery:</para>
   <informaltable frame="all">
      <tgroup cols="3">
         <thead>
            <row>
               <entry>
                  <para>Recovery Type</para>
               </entry>
               <entry>
                  <para>Description</para>
               </entry>
               <entry>
                  <para>Action Taken by the Cluster</para>
               </entry>
            </row>
         </thead><tbody><row>
            <entry>
               <para>soft</para>
            </entry>
            <entry>
               <para>A transient error occurred</para>
            </entry>
            <entry>
               <para>Restart the resource or move it to a new location</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>hard</para>
            </entry>
            <entry>
               <para>A non-transient error that may be specific to the current node occurred</para>
            </entry>
            <entry>
               <para>Move the resource elsewhere and prevent it from being retried on the current node</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>fatal</para>
            </entry>
            <entry>
               <para> A non-transient error that will be common to all cluster nodes (I.e. a bad configuration was specified)</para>
            </entry>
            <entry>
               <para>Stop the resource and prevent it from being started on any cluster node</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>Types of recovery performed by the cluster</para>
   <para>Assuming an action is considered to have failed, the following table outlines the different OCF return codes and the type of recovery the cluster will initiate when it is received. </para>
   <informaltable frame="all">
      <tgroup cols="4">
         <thead>
            <row>
               <entry>
                  <para>OCF Return Code</para>
               </entry>
               <entry>
                  <para>OCF Alias</para>
               </entry>
               <entry>
                  <para>Description</para>
               </entry>
               <entry>
                  <para>Recovery Type</para>
               </entry>
            </row>
         </thead><tbody><row>
            <entry>
               <para>0</para>
            </entry>
            <entry>
               <para>OCF_SUCCESS</para>
            </entry>
            <entry>
               <para>Success.  The command complete successfully.  This is the expected result for all start, stop, promote and demote commands.</para>
            </entry>
            <entry>
               <para>soft</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>1</para>
            </entry>
            <entry>
               <para>OCF_ERR_GENERIC</para>
            </entry>
            <entry>
               <para>Generic “there was a problem” error code.</para>
            </entry>
            <entry>
               <para>soft</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>2</para>
            </entry>
            <entry>
               <para>OCF_ERR_ARGS</para>
            </entry>
            <entry>
               <para>The resource’s configuration is not valid on this machine.  Eg. Refers to a location/tool not found on the node. </para>
            </entry>
            <entry>
               <para>hard</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>3</para>
            </entry>
            <entry>
               <para>OCF_ERR_UNIMPLEMENTED</para>
            </entry>
            <entry>
               <para>The requested action is not implemented.</para>
            </entry>
            <entry>
               <para>hard</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>4</para>
            </entry>
            <entry>
               <para>OCF_ERR_PERM</para>
            </entry>
            <entry>
               <para>The resource agent does not have sufficient privileges to complete the task.</para>
            </entry>
            <entry>
               <para>hard</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>5</para>
            </entry>
            <entry>
               <para>OCF_ERR_INSTALLED</para>
            </entry>
            <entry>
               <para>The tools required by the resource are not installed on this machine.</para>
            </entry>
            <entry>
               <para>hard</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>6</para>
            </entry>
            <entry>
               <para>OCF_ERR_CONFIGURED</para>
            </entry>
            <entry>
               <para>The resource’s configuration is invalid.  Eg. A required parameters are missing.</para>
            </entry>
            <entry>
               <para>fatal</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>7</para>
            </entry>
            <entry>
               <para>OCF_NOT_RUNNING</para>
            </entry>
            <entry>
               <para>The resource is safely stopped.  The cluster will not attempt to stop a resource that returns this for any action.</para>
            </entry>
            <entry>
               <para>N/A</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>8</para>
            </entry>
            <entry>
               <para>OCF_RUNNING_MASTER</para>
            </entry>
            <entry>
               <para>The resource is running in Master mode.</para>
            </entry>
            <entry>
               <para>soft</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>9</para>
            </entry>
            <entry>
               <para>OCF_FAILED_MASTER</para>
            </entry>
            <entry>
               <para>The resource is in Master mode but has failed.  The resource will be demoted, stopped and then started (and possibly promoted) again.</para>
            </entry>
            <entry>
               <para>soft</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>other</para>
            </entry>
            <entry>
               <para>NA</para>
            </entry>
            <entry>
               <para>Custom error code.</para>
            </entry>
            <entry>
               <para>soft</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>OCF Return Codes and How They are Handled</para>
   <para>Although counter intuitive, even actions that return 0 (aka. OCF_SUCCESS) can be considered to have failed.  This can happen when a resource that is expected to be in the Master state is found running as a Slave, or when a resource is found active on multiple machines..</para><section><title> Exceptions</title>
   <orderedlist>
      <listitem>
         <para>Non-recurring monitor actions (probes) that find a resource active (or in Master mode) will not result in recovery action unless it is also found active elsewhere</para>
      </listitem>
      <listitem>
         <para>The recovery action taken when a resource is found active more than once is determined by the multiple-active property of the resource</para>
      </listitem>
      <listitem>
         <para>Recurring actions that return OCF_ERR_UNIMPLEMENTED do not cause any type of recovery</para>
      </listitem>
   </orderedlist>
   </section></section>
   </section>
   <section id="changes">
     <anchor id="WhatChangedin10"/>     
     <title>Appendix: What Changed in 1.0</title>
     <section><title>New</title>
   <itemizedlist>
      <listitem>
         <para>Failure timeouts.  See <link linkend="">Moving Resources Due to Failure</link>
         </para>
      </listitem>
      <listitem>
         <para>New section for resource and operation defaults. See <link linkend="">Setting Global Defaults for Resource Options</link> and  <link linkend="">Setting Global Defaults for Operations</link>
         </para>
      </listitem>
      <listitem>
         <para>Tool for making offline configuration changes.  See <link linkend="">Making Configuration Changes in a Sandbox</link>
         </para>
      </listitem>
      <listitem>
         <para>Rules, instance_attributes, meta_attributes and sets of operations can be defined once and referenced in multiple places.  See <link linkend="">Reusing Rules, Options and Sets of Operations</link>
         </para>
      </listitem>
      <listitem>
         <para>The CIB now accepts XPath-based create/modify/delete operations. See the cibadmin help text.</para>
      </listitem>
      <listitem>
         <para>Multi-dimensional colocation and ordering constraints.  See <link linkend="">Ordering</link> and <link linkend="">Collocating Sets of Resources</link>
         </para>
      </listitem>
      <listitem>
         <para>The ability to connect to the CIB from non-cluster machines. See <link linkend="">Connecting to the Cluster Configuration from Remote Machines</link>
         </para>
      </listitem>
      <listitem>
         <para>Allow recurring actions to be triggered at known times. See <link linkend="">Specifying When Recurring Actions are Performed</link>
         </para>
      </listitem>
   </itemizedlist>
   <para/></section><section><title>Changed</title>
   <itemizedlist>
      <listitem>
         <para>Syntax</para>
	 <itemizedlist>
	   <listitem>
	     <para>All resource and cluster options now use dashes (-) instead of underscores (_)</para>
	   </listitem>
	   <listitem>
	     <para>master_slave was renamed to master</para>
	   </listitem>
	   <listitem>
	     <para>The attributes container tag was removed</para>
	   </listitem>
	   <listitem>
	     <para>The operation field pre-req has been renamed requires </para>
	   </listitem>
	   <listitem>
	     <para>All operations must have an interval, start/stop must have it set to zero</para>
	   </listitem>
	 </itemizedlist>
      </listitem>
      <listitem>
         <para>The stonith-enabled option now defaults to true.</para>
      </listitem>
      <listitem>
         <para>The cluster will refuse to start resources if stonith-enabled is true (or unset) and no STONITH resources have been defined</para>
      </listitem>
      <listitem>
         <para>The attributes of colocation and ordering constraints were renamed for clarity.  See <link linkend="">Specifying the Order Resources Should Start/Stop In</link> and  <link linkend="">Placing Resources Relative to other Resources</link>
         </para>
      </listitem>
      <listitem>
         <para>resource-failure-stickiness has been replaced by migration-threshold.  See <link linkend="">Moving Resources Due to Failure</link> 
         </para>
      </listitem>
      <listitem>
         <para>The arguments for command-line tools has been made consistent</para>
      </listitem>
      <listitem>
         <para>Switched to RelaxNG schema validation and libxml2 parser.</para>
	 <itemizedlist>
	   <listitem>
	     id fields are now XML IDs which have the following limitations
	     <itemizedlist>
	       <listitem>
		 id’s cannot contain colons (:)
	       </listitem>
	       <listitem>
		 id’s cannot begin with a number
	       </listitem>
	       <listitem>
		 id’s must be globally unique (not just unique for that tag)
	       </listitem>
	     </itemizedlist>
	   </listitem>
	   <listitem>
	     Some fields (such as those in constraints that refer to resources) are IDREFs.  This means that they must reference existing resources or objects in order for the configuration to be valid.  Removing an object which is referenced elsewhere will therefor fail.
	   </listitem>
	   <listitem>
	     The CIB representation from which the md5 digest used to verify CIBs has changed.  This means that every CIB update will require a full refresh on any upgraded nodes until the cluster is fully upgraded to 1.0.  This will result in significant performance degradation and it is therefor highly inadvisable to run a mixed 1.0/0.6 cluster for any longer than absolutely necessary.
	   </listitem>
	 </itemizedlist>
      </listitem>
      <listitem>
         <para>Ping node information no longer needs to be added to ha.cf  Simply include the lists of hosts in your ping resource(s).</para>
      </listitem>
   </itemizedlist></section><section><title>Removed</title>
   <itemizedlist>
      <listitem>
         <para>Syntax</para>
	 <itemizedlist>
	   <listitem>
	     It is no longer possible to set resource meta options as top-level attributes.  Use meta attributes instead.
	   </listitem>
	   <listitem>
	     Resource and operation defaults are no longer read from crm_config.  See <link linkend="">Setting Global Defaults for Resource Options</link> and <link linkend="">Setting Global Defaults for Operations</link> instead.
	   </listitem>
	 </itemizedlist>
      </listitem>
   </itemizedlist>
   </section>
   </section>
   <section id="install">
     <title>Appendix: Installation</title>
     <section>
       <anchor id="ChoosingaClusterStack"/>
       <title>Choosing a Cluster Stack</title>
   <para>Ultimately the choice of cluster stack is a personal decision that must be made in the context of you or your company’s needs and strategic direction.  Pacemaker currently functions equally well with both stacks.</para>
   <para>Here are some factors that may influence the decision</para>
   <orderedlist>
      <listitem>
         <para> SUSE/Novell, Red Hat and Oracle are all putting their collective weight behind the OpenAIS cluster stack.</para>
      </listitem>
      <listitem>
         <para>OpenAIS is an OSI Certified implementation of an industry standard (the Service Availability Forum Application Interface Specification).</para>
      </listitem>
      <listitem>
         <para>Using OpenAIS gives your applications access to the following additional cluster services</para>
	 <itemizedlist>
	   <listitem>
	     checkpoint service
	   </listitem>
	   <listitem>
	     distributed locking service
	   </listitem>
	   <listitem>
	     extended virtual synchrony service
	   </listitem>
	   <listitem>
	     cluster closed process group service
	   </listitem>
	 </itemizedlist>
      </listitem>
      <listitem>
         <para>It is likely that Pacemaker, at some point in the future, will make use of some of these additional services not provided by Heartbeat</para>
      </listitem>
      <listitem>
         <para>To date, Pacemaker has received less real-world testing on OpenAIS than it has on Heartbeat.</para>
      </listitem>
   </orderedlist></section><section><title>Enabling Pacemaker</title><section><title>For OpenAIS</title>
   <para>The OpenAIS configuration is normally located in /etc/ais/openais.conf and an example for a machine with an address of 1.2.3.4 in a cluster communicating on port 1234 (without peer authentication and message encryption) is shown below.</para>
   <para>totem {</para>
   <para>        version: 2</para>
   <para>        secauth: off</para>
   <para>        threads: 0</para>
   <para>        interface {</para>
   <para>                ringnumber: 0</para>
   <para>                bindnetaddr: 1.2.3.4</para>
   <para>                mcastaddr: 226.94.1.1</para>
   <para>                mcastport: 1234</para>
   <para>        }</para>
   <para>}</para>
   <para>logging {</para>
   <para>        fileline: off</para>
   <para>        to_syslog: yes</para>
   <para>        syslog_facility: daemon</para>
   <para>}</para>
   <para>amf {</para>
   <para>        mode: disabled</para>
   <para>}</para>
   <para>An example OpenAIS configuration file</para>
   <para>The logging should be mostly obvious and the amf section refers to the Availability Management Framework and is not covered in this document.</para>
   <para>The interesting part of the configuration is the totem section.  This is where we define the how the node can communicate with the rest of the cluster and what protocol version and options (including encryption<footnote>
         <para> Please consult the OpenAIS website and documentation for details on enabling encryption and peer authentication for the cluster.</para>
      </footnote>) it should use.  Beginners are encouraged to use the values shown and modify the interface section based on their network.  </para>
   <para>It is also possible to configure OpenAIS for an IPv6 based environment.  Simply configure bindnetaddr and mcastaddr with their IPv6 equivalents.  Eg </para>
   <para>bindnetaddr: fec0::1:a800:4ff:fe00:20 </para>
   <para>mcastaddr: ff05::1</para>
   <para>Example options for an IPv6 environment</para>
   <para>To tell OpenAIS to use the Pacemaker cluster manager, add the following fragment to a functional OpenAIS configuration and restart the cluster.</para>
   <para> aisexec {</para>
   <para>        user:   root</para>
   <para>        group:  root</para>
   <para> }</para>
   <para>service {</para>
   <para>        name: pacemaker</para>
   <para>        ver:  0</para>
   <para>}</para>
   <para>Configuration fragment for enabling Pacemaker under OpenAIS </para>
   <para>The cluster needs to be run as root so that its child processes (the lrmd in particular) have sufficient privileges to perform the actions requested of it.  After-all, a cluster manager that can’t add an IP address or start apache is of little use.</para>
   <para>The second directive is the one that actually instructs the cluster to run Pacemaker.</para></section><section><title>For Heartbeat</title>
   <para>Add the following to a functional ha.cf configuration file and restart Heartbeat</para>
   <para>crm respawn</para>
   <para>Configuration fragment for enabling Pacemaker under Heartbeat</para>
     </section></section>
     </section>
   <section id="upgrade">
      <anchor id="AppendixUpgradingClusterSoft"/>
      <title>Appendix: Upgrading Cluster Software</title>
      <section><title>Upgrade Methodologies</title><section><title>Version Compatibility</title>
   <para>When releasing newer versions we take care to make sure we are backwardly compatible with older versions. While you will always be able to upgrade from version x to x+1, in order to continue to produce high quality software it may occasionally be necessary to drop compatibility with older versions.</para>
   <para>There will always be an upgrade path from any series-2 release to any other series-2 release.</para>
   <para>There are three approaches to upgrading your cluster software</para>
   <orderedlist>
      <listitem>
         <para>Complete <ulink url="http://linux-ha.org/v2/upgrade/shutdown">Cluster Shutdown</ulink>
         </para>
      </listitem>
      <listitem>
         <para>Rolling (node by node)</para>
      </listitem>
      <listitem>
         <para>Disconnect &amp; Reattach</para>
      </listitem>
   </orderedlist>
   <para>Each method has advantages and disadvantages, some of which are listed in the table below, and you should chose the one most appropriate to your needs. </para>
   <informaltable frame="all">
      <tgroup cols="6">
         <thead>
            <row>
               <entry>
                  <para>Type</para>
               </entry>
               <entry>
                  <para>Available between all software versions</para>
               </entry>
               <entry>
                  <para>Service Outage During Upgrade</para>
               </entry>
               <entry>
                  <para>Service Recovery During Upgrade</para>
               </entry>
               <entry>
                  <para>Exercises Failover Logic/Configuration</para>
               </entry>
               <entry>
                  <para>Allows change of cluster stack</para>
               </entry>
            </row>
         </thead><tbody><row>
            <entry>
               <para>Shutdown</para>
            </entry>
            <entry>
               <para>yes</para>
            </entry>
            <entry>
               <para>always</para>
            </entry>
            <entry>
               <para>N/A</para>
            </entry>
            <entry>
               <para>no</para>
            </entry>
            <entry>
               <para>yes</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>Rolling</para>
            </entry>
            <entry>
               <para>no</para>
            </entry>
            <entry>
               <para>always</para>
            </entry>
            <entry>
               <para>yes</para>
            </entry>
            <entry>
               <para>yes</para>
            </entry>
            <entry>
               <para>no</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>Reattach</para>
            </entry>
            <entry>
               <para>yes</para>
            </entry>
            <entry>
               <para>only due to failure</para>
            </entry>
            <entry>
               <para>no</para>
            </entry>
            <entry>
               <para>no</para>
            </entry>
            <entry>
               <para>yes</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section><section><title>Complete Cluster Shutdown</title>
   <para>In this scenario one shuts down all cluster nodes and resources and upgrades all the nodes before restarting the cluster.</para><section><title>Procedure</title>
   <orderedlist>
      <listitem>
         <para>On each node:</para>
	 <orderedlist>
	   <listitem>
	     Shutdown the cluster stack (Heartbeat or OpenAIS)
	   </listitem>
	   <listitem>
	     Upgrade the Pacemaker software.  This may also include upgrading the cluster stack and/or the underlying operating system..
	   </listitem>
	 </orderedlist>
      </listitem>
      <listitem>
         <para>Check the configuration manually or with the crm_verify tool if available.</para>
      </listitem>
      <listitem>
         <para>On each node:</para>
	 <orderedlist>
	   <listitem>
	     Start the cluster stack.  This can be either OpenAIS or Heartbeat and does not need to be the same as the previous cluster stack.
	   </listitem>
	 </orderedlist>
      </listitem>
   </orderedlist></section></section><section><title>Rolling (node by node)</title>
   <para>In this scenario each node is removed from the cluster, upgraded and then brought back online until all nodes are running the newest version.</para><section><title>Procedure</title>
   <para>On each node:</para>
   <orderedlist>
      <listitem>
         <para>Shutdown the cluster stack (Heartbeat or OpenAIS)</para>
      </listitem>
      <listitem>
         <para>Upgrade the Pacemaker software.  This may also include upgrading the cluster stack and/or the underlying operating system.</para>
	 <orderedlist>
	   <listitem>
	     On the first node, check the configuration manually or with the crm_verify tool if available.
	   </listitem>
	 </orderedlist>
      </listitem>
      <listitem>
         <para>Start the cluster stack.  This must be the same cluster stack that the rest of the cluster is using.</para>
      </listitem>
   </orderedlist>
   <para>Repeat for each node in the cluster</para></section><section><title>Version Compatibility</title>
   <informaltable frame="all">
      <tgroup cols="2">
         <thead>
            <row>
               <entry>
                  <para>Version being Installed</para>
               </entry>
               <entry>
                  <para>Oldest Compatible Version</para>
               </entry>
            </row>
         </thead><tbody><row>
            <entry>
               <para>Pacemaker 1.0</para>
            </entry>
            <entry>
               <para>Pacemaker 0.6 or Heartbeat 2.1.3</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>Pacemaker 0.7</para>
            </entry>
            <entry>
               <para>Pacemaker 0.6 or Heartbeat 2.1.3</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>Pacemaker 0.6</para>
            </entry>
            <entry>
               <para>Heartbeat 2.0.8</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>Heartbeat 2.1.3 (or less)</para>
            </entry>
            <entry>
               <para>Heartbeat 2.0.4</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>Heartbeat 2.0.4 (or less)</para>
            </entry>
            <entry>
               <para>Heartbeat 2.0.0</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>Heartbeat 2.0.0</para>
            </entry>
            <entry>
               <para>None.  Use an alternate upgrade strategy.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section><section><title>Crossing Compatibility Boundaries</title>
   <para>Rolling upgrades that cross compatibility boundaries must be preformed in multiple steps.  For example, to perform a rolling update from Heartbeat 2.0.1 to Pacemaker 1.0.0 one must:</para>
   <orderedlist>
      <listitem>
         <para>Perform a rolling upgrade from Heartbeat 2.0.1 to Heartbeat 2.0.4 </para>
      </listitem>
      <listitem>
         <para>Perform a rolling upgrade from Heartbeat 2.0.4 to Heartbeat 2.1.3</para>
      </listitem>
      <listitem>
         <para>Perform a rolling upgrade from Heartbeat 2.1.3 to Pacemaker 1.0.0</para>
      </listitem>
   </orderedlist></section></section><section><title>Disconnect &amp; <ulink url="http://linux-ha.org/v2/upgrade/reattach">Reattach</ulink> 
   </title>
   <para>A variant of a complete cluster shutdown, but the resources are left active and re-detected when the cluster is restarted.</para><section><title>Procedure</title>
   <orderedlist>
      <listitem>
         <para>Tell the cluster to stop managing services. This is required to allow the services to remain active after the cluster shuts down.  </para>
	 <command>crm_attribute -t crm_config -n is-managed-default -v false </command>
      </listitem>
      <listitem>
         <para>For any resource that has a value for is-managed, make sure it is set to false (so that the cluster will not stop it) </para>
	 <command>crm_resource -t primitive -r &lt;rsc_id&gt; -p is-managed -v false </command>
      </listitem>
      <listitem>
         <para>On each node:</para>
	 <orderedlist>
	   <listitem>
	     Shutdown the cluster stack (Heartbeat or OpenAIS)
	   </listitem>
	   <listitem>
	     Upgrade the cluster stack program - This may also include upgrading the underlying operating system.
	   </listitem>
	 </orderedlist>
      </listitem>
      <listitem>
         <para>Check the configuration manually or with the crm_verify tool if available.</para>
      </listitem>
      <listitem>
         <para>On each node:</para>
	 <orderedlist>
	   <listitem>
	     Start the cluster stack.  This can be either OpenAIS or Heartbeat and does not need to be the same as the previous cluster stack.
	   </listitem>
	 </orderedlist>
	      </listitem>
      <listitem>
         <para>Verify the cluster re-detected all resources correctly</para>
      </listitem>
      <listitem>
         <para>Allow the cluster to resume managing resources again </para>
	 <command>crm_attribute -t crm_config -n is-managed-default -v true </command>
      </listitem>
      <listitem>
         <para>For any resource that has a value for is-managed reset it to true (so the cluster can recover the service if it fails) if desired</para>
	 <command>crm_resource -t primitive -r &lt;rsc_id&gt; -p is-managed -v false</command>
      </listitem>
   </orderedlist>
   </section>
   <section><title>Notes</title>
     <orderedlist>
      <listitem>
         <para>Always check your existing configuration is still compatible with the version you are installing before starting the cluster.</para>
      </listitem>
      <listitem>
         <para>The oldest version of the CRM to support this upgrade type was in Heartbeat 2.0.4</para>
      </listitem>
     </orderedlist>
	</section></section>
      </section>
      </section>
   <section id="upgrade-config"><title>Appendix: Upgrading the Configuration from 0.6</title>
     <section><title>Preparation</title>
   <para>Download the latest DTD from <ulink url="http://hg.clusterlabs.org/pacemaker/dev/file-raw/tip/xml/crm.dtd">http://hg.clusterlabs.org/pacemaker/dev/file-raw/tip/xml/crm.dtd</ulink> and ensure your configuration validates.</para></section><section><title>Perform the upgrade</title><section><title>Upgrade the software</title>
   <para>Refer to the appendix: <link linkend="">Upgrading Cluster Software</link>
   </para></section><section><title>Upgrade the Configuration</title>
   <para>As XML is not the friendliest of languages, it is common for cluster administrators to have scripted some of their activities.  In such cases, it is likely that those scripts will not work with the new 1.0 syntax.</para>
   <para>In order to support such environments, it is actually possible to continue using the old 0.6 syntax.</para>
   <para>The downside however, is that not all the new features will be available and there is a performance impact since the cluster must do a non-persistent configuration upgrade before each transition.  So while using the old syntax is possible, it is not advisable to continue using it indefinitely.</para>
   <para>Even if you wish to continue using the old syntax, it is advisable to follow the upgrade procedure to ensure that the cluster is able to use your existing configuration (since it will perform much the same task internally). </para>
   <orderedlist>
      <listitem>
         <para>Create a shadow copy to work with</para>
      </listitem>
   </orderedlist>
   <para>crm_shadow --create upgrade06</para>
   <orderedlist>
      <listitem>
         <para>Verify the configuration is valid</para>
      </listitem>
   </orderedlist>
   <para>crm_verify --live-check</para>
   <orderedlist>
      <listitem>
         <para>Fix any errors or warnings</para>
      </listitem>
      <listitem>
         <para>Perform the upgrade</para>
      </listitem>
   </orderedlist>
   <para>cibadmin --upgrade</para>
   <para>If this step fails, there are three main possibilities</para>
   <orderedlist>
      <listitem>
         <para>The configuration was not valid to start with - go back to step 2</para>
      </listitem>
      <listitem>
         <para>The transformation failed - report a bug or email the project at <ulink url="mailto:pacemaker@clusterlabs.org?subject=Transformation%20failed%20during%20upgrade">pacemaker@clusterlabs.org</ulink>
         </para>
      </listitem>
      <listitem>
         <para>The transformation was successful but produced an invalid result<footnote>
               <para> The most common reason is ID values being repeated or invalid.  Pacemaker 1.0 is much stricter regarding this type of validation  </para>
            </footnote>
         </para>
      </listitem>
   </orderedlist>
   <para/>
   <para>If the result of the transformation is invalid, you may see a number of errors from the validation library.  If these are not helpful, visit <ulink url="http://clusterlabs.org/mw/Validation_FAQ">http://clusterlabs.org/mw/Validation_FAQ</ulink> and/or try the following procedure described below under “Manually Upgrading the Configuration”. </para>
   <orderedlist>
      <listitem>
         <para>Check the changes</para>
      </listitem>
   </orderedlist>
   <para>crm_shadow --diff</para>
   <para>If at this point there is anything about the upgrade that you wish to fine-tune (for example, to change some of the automatic IDs) now is the time to do so.  Since the shadow configuration is not in use by the cluster, it is safe to edit the file manually:</para>
   <para>crm_shadow --edit</para>
   <para>Will open the configuration in your favorite editor (or whichever one is specified by the standard EDITOR environment variable).</para>
   <orderedlist>
      <listitem>
         <para>Preview how the cluster will react</para>
      </listitem>
   </orderedlist>
   <para>Test what the cluster will do when you upload the new configuration</para>
   <para>ptest -VVVVV --live-check --save-dotfile upgrade06.dot</para>
   <para>graphviz upgrade06.dot</para>
   <para>Verify that either no resource actions will occur or that you are happy with any that are scheduled.  If the output contains actions you do not expect (possibly due to changes to the score calculations), you may need to make further manual changes.  See <link linkend="">Testing Your Configuration Changes</link> for further details on how to interpret the output of ptest.</para>
   <orderedlist>
      <listitem>
         <para>Upload the changes</para>
      </listitem>
   </orderedlist>
   <para>crm_shadow --commit upgrade06 --force</para>
   <para>If this step fails, something really strange has occurred.  You should report a bug. </para></section><section><title>Manually Upgrading the Configuration</title>
   <para>It is also possible to perform the configuration upgrade steps manually.  To do this</para>
   <orderedlist>
      <listitem>
         <para>Locate the upgrade06.xsl conversion script or download the latest version from <ulink url="http://hg.clusterlabs.org/pacemaker/stable-1.0/raw-file/tip/xml/upgrade06.xsl">http://hg.clusterlabs.org/pacemaker/stable-1.0/raw-file/tip/xml/upgrade06.xsl</ulink> 
         </para>
      </listitem>
      <listitem>
         <para>xsltproc /path/tp/upgrade06.xsl config06.xml &gt; config10.xml</para>
      </listitem>
      <listitem>
         <para>Locate the pacemaker.rng script.</para>
      </listitem>
      <listitem>
         <para>xmllint --relaxng /path/tp/pacemaker.rng config10.xml</para>
      </listitem>
   </orderedlist>
   <para>The advantage of this method is that it can be performed without the cluster running and any validation errors should be more informative (despite being generated by the same library!) since they include line numbers.</para>
   </section>
   </section>
   </section>
   <section id="lsb">
     <anchor id="HowCanITellifanInitScriptcopycopy"/>
     <title>Appendix: Is This init Script LSB Compatible?</title>
   <para>Assuming some_service is configured correctly and currently not active, the following sequence will help you determine if it is LSB compatible:</para>
   <orderedlist>
     <listitem>
       <para>Start (stopped): </para>
       <command>/etc/init.d/some_service start ; echo "result: $?"</command>
       <orderedlist>
	 <listitem>
	   Did the service start?
	 </listitem>
	 <listitem>
	   Did the command print result: 0 (in addition to the regular output)? 
	 </listitem>
       </orderedlist>
     </listitem>
     <listitem>
       <para>Status (running): </para>
       <command>/etc/init.d/some_service status ; echo "result: $?" </command>
       <orderedlist>
	 <listitem>
	   Did the script accept the command?
	 </listitem>
	 <listitem>
	   Did the script indicate the service was running?
	 </listitem>
	 <listitem>
	   Did the command print result: 0 (in addition to the regular output)?
	 </listitem>
       </orderedlist>
     </listitem>
     <listitem>
       <para>Start (running):</para>
       <command> /etc/init.d/some_service start ; echo "result: $?" </command>
       <orderedlist>
	 <listitem>
	   Is the service still running?
	 </listitem>
	 <listitem>
	   Did the command print result: 0 (in addition to the regular output)?
	 </listitem>
       </orderedlist>
     </listitem>
     <listitem>
       <para>Stop (running): </para>
       <command>/etc/init.d/some_service stop ; echo "result: $?" </command>
       <orderedlist>
	 <listitem>
	   Was the service stopped?
	 </listitem>
	 <listitem>
	   Did the command print result: 0 (in addition to the regular output)?
	 </listitem>
       </orderedlist>
     </listitem>
     <listitem>
       <para>Status (stopped):</para>
       <command>/etc/init.d/some_service status ; echo "result: $?" </command>
       <orderedlist>
	 <listitem>
	   Did the script accept the command?
	 </listitem>
	 <listitem>
	   Did the script indicate the service was not running? 
	 </listitem>
	 <listitem>
	   Did the command print result: 3 (in addition to the regular output)?
	 </listitem>
       </orderedlist>
     </listitem>
     <listitem>
       <para>Stop (stopped): </para>
       <command>/etc/init.d/some_service stop ; echo "result: $?" </command>
       <orderedlist>
	 <listitem>
	   Is the service still stopped?
	 </listitem>
	 <listitem>
	   Did the command print result: 0 (in addition to the regular output)?
	 </listitem>
       </orderedlist>
     </listitem>
     <listitem>
       <para>Status (failed): </para>
       <para>This step is not readily testable and relies on manual inspection of the script.</para>
       <para>The script can use one of the error codes (other than 3) listed in the LSB spec to indicate that it is active but failed.</para>
       <para>This tells the cluster that before moving the resource to another node, it needs to stop it on the existing one first.</para>
     </listitem>
   </orderedlist>
   <para>        This step is not readily testable and relies on manual inspection of the script.</para>
   <para>The script can use one of the error codes (other than 3) listed in the LSB spec to indicate that it is active but failed. This tells the cluster that before moving the resource to another node, it needs to stop it on the existing one first. </para>
   <para>If the answer to any of the above questions is no, then the script is not LSB compliant. Your options are then to either fix the script or write an OCF agent based on the existing script.</para>
   </section>
   <section id="samples"><title>Appendix: Sample Configurations</title>
     <section><title>An Empty Configuration</title>
   <para>&lt;cib admin_epoch="0" epoch="0" num_updates="0" have-quorum="false"&gt;</para>
   <para>  &lt;configuration&gt;</para>
   <para>    &lt;crm_config/&gt;</para>
   <para>    &lt;nodes/&gt;</para>
   <para>    &lt;resources/&gt;</para>
   <para>    &lt;constraints/&gt;</para>
   <para>  &lt;/configuration&gt;</para>
   <para>  &lt;status/&gt;</para>
   <para>&lt;/cib&gt;</para>
   <para>An empty configuration</para></section><section><title>A Simple Configuration</title>
   <para>&lt;cib admin_epoch="0" epoch="1" num_updates="0" have-quorum="false" validate-with=”pacemaker-1.0”&gt;</para>
   <para>    &lt;configuration&gt;</para>
   <para>        &lt;crm_config&gt;</para>
   <para>            &lt;nvpair id="option-1" name="symmetric-cluster" value="true"/&gt;</para>
   <para>            &lt;nvpair id="option-2" name="no-quorum-policy" value="stop"/&gt;</para>
   <para>        &lt;/crm_config&gt;</para>
   <para>        &lt;op_defaults&gt;</para>
   <para>            &lt;nvpair id="op-default-1" name="timeout" value="30s"/&gt;</para>
   <para>        &lt;/op_defaults&gt;</para>
   <para>        &lt;rsc_defaults&gt;</para>
   <para>            &lt;nvpair id="rsc-default-1" name="resource-stickiness" value="100"/&gt;</para>
   <para>            &lt;nvpair id="rsc-default-2" name="migration-threshold" value="10"/&gt;</para>
   <para>        &lt;/rsc_defaults&gt;</para>
   <para>        &lt;nodes&gt;</para>
   <para>           &lt;node id="xxx" uname="c001n01" type="normal"/&gt;</para>
   <para>           &lt;node id="yyy" uname="c001n02" type="normal"/&gt;</para>
   <para>        &lt;/nodes&gt;</para>
   <para>        &lt;resources&gt;</para>
   <para>            &lt;primitive id="myAddr" class="ocf" provider="heartbeat" type="IPaddr"&gt;</para>
   <para>                &lt;operations&gt;</para>
   <para>                   &lt;op id="myAddr-monitor" name="monitor" interval="300s"/&gt;</para>
   <para>                &lt;/operations&gt;</para>
   <para>                &lt;instance_attributes&gt;</para>
   <para>                       &lt;nvpair name="ip" value="10.0.200.30"/&gt;</para>
   <para>                &lt;/instance_attributes&gt;</para>
   <para>            &lt;/primitive&gt;</para>
   <para>        &lt;/resources&gt;</para>
   <para>        &lt;constraints&gt;</para>
   <para>           &lt;rsc_location id=”myAddr-preferred-host” rsc=”myAddr” node=”c001n01” score=”INFINITY”/&gt;</para>
   <para>        &lt;/constraints&gt;</para>
   <para>    &lt;/configuration&gt;</para>
   <para>    &lt;status/&gt;</para>
   <para>&lt;/cib&gt;</para>
   <para>2 nodes, some cluster options and a resource</para>
   <para>In this example, we have one resource (an IP address) that we check every five minutes and will run on host c001n01 until either the resource fails 10 times or the host shuts down.</para></section><section><title>An Advanced Configuration</title>
   <para/>
   <para>&lt;cib admin_epoch="0" epoch="1" num_updates="0" have-quorum="false" validate-with=”pacemaker-1.0”&gt;</para>
   <para>    &lt;configuration&gt;</para>
   <para>        &lt;crm_config&gt;</para>
   <para>            &lt;nvpair id="option-1" name="symmetric-cluster" value="true"/&gt;</para>
   <para>            &lt;nvpair id="option-2" name="no-quorum-policy" value="stop"/&gt;</para>
   <para>            &lt;nvpair id="option-3" name="stonith-enabled" value="true"/&gt;</para>
   <para>        &lt;/crm_config&gt;</para>
   <para>        &lt;op_defaults&gt;</para>
   <para>            &lt;nvpair id="op-default-1" name="timeout" value="30s"/&gt;</para>
   <para>        &lt;/op_defaults&gt;</para>
   <para>        &lt;rsc_defaults&gt;</para>
   <para>            &lt;nvpair id="rsc-default-1" name="resource-stickiness" value="100"/&gt;</para>
   <para>            &lt;nvpair id="rsc-default-2" name="migration-threshold" value="10"/&gt;</para>
   <para>        &lt;/rsc_defaults&gt;</para>
   <para>        &lt;nodes&gt;</para>
   <para>           &lt;node id="xxx" uname="c001n01" type="normal"/&gt;</para>
   <para>           &lt;node id="yyy" uname="c001n02" type="normal"/&gt;</para>
   <para>           &lt;node id="zzz" uname="c001n03" type="normal"/&gt;</para>
   <para>        &lt;/nodes&gt;</para>
   <para>        &lt;resources&gt;</para>
   <para>            &lt;primitive id="myAddr" class="ocf" provider="heartbeat" type="IPaddr"&gt;</para>
   <para>                &lt;operations&gt;</para>
   <para>                   &lt;op id="myAddr-monitor" name="monitor" interval="300s"/&gt;</para>
   <para>                &lt;/operations&gt;</para>
   <para>                &lt;instance_attributes&gt;</para>
   <para>                       &lt;nvpair name="ip" value="10.0.200.30"/&gt;</para>
   <para>                &lt;/instance_attributes&gt;</para>
   <para>            &lt;/primitive&gt;</para>
   <para>            &lt;group id=”myGroup”&gt;</para>
   <para>               &lt;primitive id="database" class="lsb" type="oracle"&gt;</para>
   <para>                    &lt;operations&gt;</para>
   <para>                       &lt;op id="database-monitor" name="monitor" interval="300s"/&gt;</para>
   <para>                    &lt;/operations&gt;</para>
   <para>                &lt;/primitive&gt;</para>
   <para>               &lt;primitive id="webserver" class="lsb" type="apache"&gt;</para>
   <para>                    &lt;operations&gt;</para>
   <para>                       &lt;op id="webserver-monitor" name="monitor" interval="300s"/&gt;</para>
   <para>                    &lt;/operations&gt;</para>
   <para>                &lt;/primitive&gt;</para>
   <para>            &lt;/group&gt;</para>
   <para>            &lt;clone id="STONITH”"&gt;</para>
   <para>                 &lt;meta_attributes id="stonith-options"&gt;</para>
   <para>                         &lt;nvpair id="stonith-option-1" name="globally-unique" value="false"/&gt;</para>
   <para>                 &lt;/meta_attributes&gt;</para>
   <para>                 &lt;primitive id="stonithclone" class="stonith" type="external/ssh"&gt;</para>
   <para>                     &lt;operations&gt;</para>
   <para>                         &lt;op id="stonith-op-mon" name="monitor" interval="5s"/&gt;</para>
   <para>                     &lt;/operations&gt;</para>
   <para>                     &lt;instance_attributes id="stonith-attrs"&gt;</para>
   <para>                         &lt;nvpair id="stonith-attr-1" name="hostlist" value="c001n01,c001n02"/&gt;</para>
   <para>                      &lt;/instance_attributes&gt;</para>
   <para>                 &lt;/primitive&gt;</para>
   <para>            &lt;/clone&gt;</para>
   <para>       &lt;/resources&gt;</para>
   <para>        &lt;constraints&gt;</para>
   <para>           &lt;rsc_location id=”myAddr-preferred-host” rsc=”myAddr” node=”c001n01” score=”INFINITY”/&gt;</para>
   <para>           &lt;rsc_colocation id=”group-with-ip” rsc=”myGroup” with-rsc=”myAddr” score=”INFINITY”/&gt;</para>
   <para>        &lt;/constraints&gt;</para>
   <para>    &lt;/configuration&gt;</para>
   <para>    &lt;status/&gt;</para>
   <para>&lt;/cib&gt;</para>
   <para>groups and clones with stonith</para>
   </section>
   </section>
   <section id="more"><title>Appendix: Further Reading</title>
     <section><title/><section><title>Project Website</title>
   <para>
      <ulink url="http://www.clusterlabs.org/">http://www.clusterlabs.org</ulink>
   </para></section></section><section><title/><section><title>Cluster Commands</title>
   <para>A comprehensive guide to cluster commands has been written by Novell and can be found at:</para>
   <para>
      <ulink url="http://www.novell.com/documentation/sles11/book_sleha/index.html?page=/documentation/sles11/book_sleha/data/book_sleha.html">http://www.novell.com/documentation/sles11/book_sleha/index.html?page=/documentation/sles11/book_sleha/data/book_sleha.html</ulink>
   </para></section></section><section><title/><section><title>Heartbeat configuration</title>
   <para>
      <ulink url="http://www.linux-ha.org/">http://www.linux-ha.org</ulink>
   </para></section></section><section><title/><section><title>OpenAIS Configuration</title>
   <para>
      <ulink url="http://www.openais.org/">http://www.openais.org</ulink>
   </para>
   <para/></section></section></section>
</article>
